C****************************************************************
C****************************************************************
C**PROPERTIES
C****************************************************************
C****************************************************************
      SUBROUTINE RESUME(W,LDUMP)
      PARAMETER (MSEG=200)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/FILASS/IOUT,INP
C**************************************************ASSIGN TOTAL STORAGE
      DIMENSION W(1)
      COMMON/CMEMO/NADD,NSEG,KFREE,LFREE,KINF,MADD
      COMMON/CSIZE/KADD(MSEG)
      COMMON/CADDR/LADD(MSEG)
**ORIGINAL SETTINGS
C     COMMON/CADDR/LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LH,LXK,LXQ,LXW,LNBF,
C    1LMBF,LWK,LEVAL,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
C    2LAB,LB,LAA,LBB,LQQ,LESCF,LXA,LS,LHL,LHR,
C    3LSUP4,LOV,LV1,LV2,LV3,LV4,LIP,LJP,LTEMP,LC1,
C    4LC2,LC3,LC4,LXK0,LXL0,LXN0,LXM0,LEJK1,LEJK2,LEJK3,
C    5LEJK4,LW21,LSS,LSSX,LX21,LE21,LJSTAT,LKSTAT,LESTAT,LWSTAT,
C    6LVM1,LVM2,LVM3,LVM4,LCFS,LEVCI,LASSIG,LYL,LYZ,LY0,
C    7LYK,LSK,LWRK,LVK,LZK,LXKL,LXKLC,LEN,LEL,LNV,
C    8LWKL,LIP1,LJP1,LIP2,LJP2,LIP3,LJP3,LIP4,LJP4,LXA1,
C    9LXA2,LXA3,LXA4,LIPL,LIPR,LXV,LQM,LMXBAS,LNDUMP,LNVF,
C    1LMODNT,LC0,LVM0,LEJK0,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,LXTANH,
C    2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
C    3LJPL,LJPR,LXJ0,LXI0,LXA5,LXA6,LNP1,LCP1,LMP1,LNP2,
C    4LCP2,LMP2,LINDK,LNP3,LCP3,LMP3,LINDL,LNP4,LCP4,LMP4,
C    5LINDN,LNP5,LCP5,LMP5,LINDM,LTEMP5,LXKAN,LV5,LV6,LIP6,
C    6LVP1,LDP1,LVP2,LDP2A,LDP2B,LVP3,LDP3A,LDP3B,LDP3C,LVP4,
C    7LDP4A,LDP4B,LDP4C,LDP4D,LXP,LJP6
**ORIGINAL SETTINGS
      COMMON/TRANSF/LTRAN
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
C**ONLY KEEP THOSE SET UP PRIOR TO CALL
C**************************************************ASSIGN TOTAL STORAGE
C**LXK
      LADD(7)=0
      KADD(7)=0
C**LWK,LEVAL
      DO N=12,13
        LADD(N)=0
        KADD(N)=0
      END DO
C**LESCF TO LQM
      DO N=26,97
        LADD(N)=0
        KADD(N)=0
      END DO
C**LNDUMP
      KADD(99)=0
      LADD(99)=0
      NADD=MSEG
C**LC0 TO LDPD4
      DO N=102,164
        KADD(N)=0
        LADD(N)=0
      END DO
      CALL PROP(W,LDUMP,W(LADD(98)),NSMODE)
      WRITE(IOUT,66) LTRAN-KINF,LTRAN
 66   FORMAT('USED MEMORY:',I10,3X,'OF',I10)
      CALL TIMIT(4)
      CALL TIMIT(5)
      STOP 'END OF MULTIMODE'
      END
C****************************************************************
C****************************************************************
      SUBROUTINE PROP(W,LDUMP,MAXBAS,KMXBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL LINEAR,TRIAT
      CHARACTER*3 CHSYM(8)
      CHARACTER*2 SYMBOL(100)
      CHARACTER*80 FILEV,FILER,FILEI,FILEB,FILEG,FILES,IROT
C**************************************************ASSIGN TOTAL STORAGE
      DIMENSION W(1),MAXBAS(KMXBAS,6,2),VAL(3)
      COMMON/CMEMO/NADD,NSEG,KFREE,LFREE,KINF,MADD
C**CURRENT SETTINGS
      COMMON/CADDR/
     &LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LOLDH,LXK,LOLDXQ,LXW,LNBF,
     1LMBF,LSCF,LSX,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
     2LAB,LB,LAA,LBB,LQQ,LMVB,LH,LXQ,LTEMP,LCONTR,
     3LDUM2A(2),LV1,LV2,LV3,LV4,LDUM2B(4),
     4LDUM3A(3),LXK0,LXL0,LXN0,LXM0,LDUM3B(3),
     5LISIZE,LW21,LSS,LSSX,LX21,LE21,LIDUMP,LNDUMP,LIP,LVCI,
     6LNFC,LRCI,LRVAL,LWRK,LDDPM,LXDIP,LRASS,LDUM6(3),
     7LDUM7(10),
     8LXA,LXA1,LXA2,LXA3,LXA4,LEVAL,LIP1,LIP2,LIP3,LIP4,
     9LPD1,LPD2,LPD3,LPD4,LPD5,LPD6,LPD7,LMXBAS,LKDUMP,LNVF,
     1LMODNT,LJP1,LJP2,LJP3,LJP4,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,
     2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
     3LDUM8(10),
     4LDUM9(10),
     5LDM10A(5),LTEMP5,LDM10B(4),
     6LDUM11(10),
     7LDUM12(4),LXP,LJP6,LXPLOT,LYPLOT,LFPLOT
     8LDUM13(6),LTEMP6,LTEMP7,LTEMP8,LTEMP9
C**CURRENT SETTINGS
C**************************************************ASSIGN TOTAL STORAGE
      COMMON/DIPNO/NUMDIP
C*****
      COMMON/ISET/ISET
      COMMON/TITLE/TITLE
      COMMON/HERM/IHERM
      COMMON/CHECK/MCHECK
      COMMON/SADDLE/JNORM
      COMMON/PATH/ISCFCI
      COMMON/CYCLE/ICYCLE
      COMMON/DUMP/JJDUMP(10),IDUMP,KDUMP,MDUMP,LLDUMP
      COMMON/VMIN/VMIN
      COMMON/RETURN/IRET
      COMMON/CURVE/ICURV,ICORR
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT
      COMMON/ENTER/IENTER,IENTMX(5),NTOT1,NTOT2,NTOT3,NTOT4,NTOT5
      COMMON/SINCOS/ICS
      COMMON/AVCON/AVCON
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FITTER/MFIT,MFIT1(4),XFIT1,MFIT2(4),XFIT2,MFIT3(4),XFIT3,
     1MFIT4(4),XFIT4
      COMMON/LANCZO/LANCZ,LANZA,LANZB
      COMMON/TRIATO/TRIAT
      COMMON/LANTOL/TOLLAN
      COMMON/CYCLES/NCYCLE
      COMMON/MAXLAN/LANMAX,LLAN20,INP20
      COMMON/INDWR/INDW,INDR
      COMMON/GIVEN/LGIV,IGIV
      COMMON/MATSIZ/MATSIZ
      COMMON/TYPE/LINEAR
      COMMON/ECKIND/INDECK
      COMMON/ROTIND/ANGSAV(3),INDROT
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/FILASS/IOUT,INP,MOUTIN,INP4,INP5,INP6,INP7,INP8,
     1INP9,INP10
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/TOLS/TOL,EPS
      COMMON/ECKCNT/ICNT,INTC
      COMMON/ABINIT/ABINIT
      COMMON/EVL/EVL,CUT
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/WHICH/IWHICH
      COMMON/NCPOT/NPOT
      COMMON/FACTOR/FACTOR(6),FACTS(6)
      COMMON/VCIMAX/NMAX
      COMMON/ROTS/JMAX,KMAX,J21,KEL21,KEL
      COMMON/RPHROT/IROTV
      COMMON/ESTATE/IORDER
      COMMON/JKAKC/JTHIS,KA,KC
      COMMON/AXES/MX(3),MXDIP(5),MXROT(3),ISYMT
      COMMON/CIDIAG/ICID,ICI,JCI
      COMMON/FBASIS/NBAS(6,2,2),MAXSUM(6,2,2)
      COMMON/TBASIS/NTBAS(6,2),NTAU(6)
C**TEMPORARY (DIMENSIONS)
      COMMON/FSYMM/NFTOT(10,2),NRTOT(10,2,2)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/SPIN/NSPSYM(10),NSPIN(5,10),NSINDL(10),NSINDR(10)
      COMMON/SYMM0/MVSYM0
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      DIMENSION IV1(60),IV2(60)
      COMMON/CONTDP/ICONDP
      COMMON/CSAVES/NNMODS,NAMODS,NVMODS,ICOUPS,JREACS,NREACS
      COMMON/NCREC/NREC(6),MAXBUF(6),NUNITR,NUNITW
      COMMON/CVAL/NCVAL(2,10),NCSIZE(10)
      COMMON/CSIZES/ISIZM1,ISIZM2,NVAL1,NVAL2,ICSIZ1,ICSIZ2,
     1IPSIZ1,IPSIZ2
      COMMON/CONTX/LCOUNT,ISIZC(2,10)
      COMMON/CONTS/NCCNT,ICONT(2),JCONT(2,100),NCOUPL(2),NCOUPC(2)
      COMMON/CONTY/LLCNT
      COMMON/FCONTS/NCONT(2)
      COMMON/CONTZ/NONC1,NONC2
      COMMON/CONSCH/NC1,NC2,NCL1(5),NCR1(5),NCL2(5),NCR2(5),MC1(5),
     1MC2(5),JC1(5),JC2(5)
      COMMON/UNITNO/I61,I62,I63,I64,I71,I72,I73,I74,I81,I82,I83,I84,
     1I91,I92,I93,I94
      COMMON/UNITEX/I75,I76
C************************
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/MAXPT/MBFMAX,MBFMX1,MBFMX2,MBFMX3,MBFMX4,MBFMIN
      COMMON/DISC/IDISC
      COMMON/MODES/NMODE,NATOM
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/DISCSZ/KLC0,KEJK0,KLV1,KLC1,KEJK1,KLV2,KLC2,KEJK2,
     1KLV3,KLC3,KEJK3,KLV4,KLC4,KEJK4
      COMMON/SIZES/KTEMP,ISIZE1,ISIZE2,ISIZE3,ISIZE4,ISIZE5,ISIZE6,
     1ISIZE,JSIZE,ISIZMX
      COMMON/KJSZS/KJP1,KJP2,KJP3,KJP4,KJP5,KJP6
      COMMON/KPSZS/KIP1,KIP2,KIP3,KIP4,KIP5,KIP6,JCC1,JCC2,JCC3,JCC4,
     1JCC5,JCC6
      COMMON/IPSZS/KPPP1,KPPP2,KPPP3,KPPP4,KPPP5,KPPP6
      COMMON/SIZEJ/JSIZE1(2),JSIZE2(2),JSIZE3(2),JSIZE4(2),JSIZE5(2),
     1JSIZE6(2)
      COMMON/TOTALS/ITOT1(2),ITOT2(2),ITOT3(2),ITOT4(2),ITOT5(2),
     1ITOT6(2),ITOT
      COMMON/TOTK/KTOT(6,2)
      COMMON/MATRIX/NVAL,NVALR,KSTEP,KSIGN,NVALCF
      COMMON/NVALV/NVALV(2)
      COMMON/TRANS/TEMP,TCUT,ECUT
      COMMON/MAXMIN/EMIN,EMAX
      COMMON/QPART/QCALC
574   FORMAT(//,1X,'READ INTENSITY DATA',/,
     11X,'BOLTZMANN WEIGHT FOR ',F10.2,' K',/,
     21X,'TRANSITIONS MOMENTS BELOW ',E15.6,' AU**2 NEGLECTED',/,
     31X,'TRANSITION ENERGIES BELOW ',E15.6,' CM-1 NEGLECTED',/)
575   FORMAT(//,1X,'READ INTENSITY DATA',/,
     11X,'BOLTZMANN WEIGHT FOR ',F10.2,' K',/,
     21X,'TRANSITIONS MOMENTS BELOW ',E15.6,' AU**2 NEGLECTED',/,
     31X,'TRANSITION ENERGIES ABOVE ',E15.6,' CM-1 NEGLECTED',/)
576   FORMAT(/' OUTPUT VIBRATION FILE [.VIB]: ',//,A80)
577   FORMAT(/' OUTPUT ROTATION FILE [.ROT]: ',//,A80)
578   FORMAT(/' OUTPUT INTENSITY FILE [.INT]: ',//,A80)
579   FORMAT(/' OUTPUT SPECTRUM (BRANCH) FILE [.PQR]: ',//,A80)
580   FORMAT(/' OUTPUT SPECTRUM (GAUSS) FILE [.GAU]: ',//,A80)
581   FORMAT(/' OUTPUT SPECTRUM (PLOT) FILE [.SPE]: ',//,A80)
C**************************************************************
C**************************************************************
      DO I=1,10
        DO K=1,2
          NFTOT(I,K)=0
        END DO
      END DO
      DO I=1,6
        DO J=1,2
          DO K=1,2
            MAXSUM(I,J,K)=0
            NBAS(I,J,K)=0
          END DO
        END DO
      END DO
      IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)THEN
        NUMDIP=3
C       IF(TRIAT)NUMDIP=2
      END IF
C**INITIALLY REFERS TO 6 CARTESION POLARISABILITY COMPONENTS, 
C**BUT WILL BE CHANGED TO 5 SPHERICAL POLARISABILITY COMPONENTS.
      IF(LDUMP.EQ.8)NUMDIP=5
      IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)THEN
        NUMDIP=NMODE
        ICOUPL=1
        IF(JCOUPL.LT.0)THEN
          JCOUPL=-1
        ELSE
          JCOUPL=1
        END IF
        ICOUPC=ICOUPL
        JCOUPC=JCOUPL
      END IF
      IF(LDUMP.EQ.5)THEN
        READ(INP,*)
        READ(INP,*)NUMDIP
        IF(NUMDIP.GT.10)THEN
          WRITE(IOUT,*)'MAXIMUM PROPERTIES OF 10'
          STOP 'TOO MANY PROPERTIES'
        ELSE
          WRITE(IOUT,*)NUMDIP,' USER-DEFINED PROPERTIES'
          WRITE(IOUT,*)
        END IF
      END IF
C**DEFAULT J=0
      IF(IABS(LDUMP).LT.7)JMAX=0
      JCURR=0
      JMAX1=1
      JSTORE=1

C****************************************************************
      QCALC=0
C**OUTPUT/INPUT VIBRATION FILE(S) [.VIB]
      READ(INP,*)
      READ(INP,'(A)')FILEV
      WRITE(IOUT,576)FILEV
      OPEN(UNIT=INP4,FILE=FILEV,FORM='UNFORMATTED',
     1STATUS='UNKNOWN')
      IF(IABS(LDUMP).GE.7)THEN
C**OUTPUT/INPUT ROTATION FILE(S) [.ROT]
        READ(INP,*)
        READ(INP,'(A)')FILER
        WRITE(IOUT,577)FILER
        OPEN(UNIT=INP5,FILE=FILER,FORM='UNFORMATTED',
     1  STATUS='UNKNOWN')
        READ(INP,*)
C**TEMPERATURE [deg K]
        READ(INP,*)TEMP
        READ(INP,*)
C**TCUT IS THE (MINIMUM) THRESHOLD FOR TRANSITION MOMENTS
        READ(INP,*)TCUT
        READ(INP,*)
C**ECUT IS THE (MINIMUM) THRESHOLD FOR TRANSITION ENERGIES (ECUT<0)
C**ECUT IS THE (MAXIMUM) THRESHOLD FOR TRANSITION ENERGIES (ECUT>0)
        READ(INP,*)ECUT
        IF(ECUT.LE.0)WRITE(IOUT,574)TEMP,TCUT,DABS(ECUT)
        IF(ECUT.GT.0)WRITE(IOUT,575)TEMP,TCUT,ECUT
        READ(INP,*)
C**OUTPUT/INPUT INTENSITY FILE [.INT]
        READ(INP,'(A)')FILEI
        WRITE(IOUT,578)FILEI
        OPEN(UNIT=INP10,FILE=FILEI,STATUS='UNKNOWN')
C**USE INPUT VALUE OF JMAX
        JMAX1=JMAX
        IF(JMAX.EQ.0)JMAX1=1
        JSTORE=2
      END IF
C****************************************************************

      J21MAX=2*JMAX+1
      CALL MEMO(1,LMVB,NMODE,0,0,0,0,0,0,0,0)
C**TEMPORARY
      WRITE(IOUT,*)
      WRITE(IOUT,*)'NUMBER CONTRACTION SCHEMES = ',LLCNT
C**TEMPORARY
      DO 9999 LCONT=1,LLCNT
      WRITE(IOUT,*)
      WRITE(IOUT,*)'PROPERTIES OF CONTRACTION SCHEME ',LCONT
      WRITE(IOUT,*)
      NUMBER=ICONT(LCONT)
      JREACT=0
      NREACT=0
      DO I=1,NUMBER
        J=JCONT(LCONT,I)
        IF(J.EQ.IREACT)JREACT=IREACT
      END DO
      IF(JREACT.NE.0)NREACT=1
      NAMODE=NUMBER-NREACT
      NVMODE=NUMBER
      ICOUPL=NCOUPL(LCONT)
      ICOUPC=NCOUPC(LCONT)
      ICOUPL=MIN0(ICOUPL,NAMODE)
      ICOUPC=MIN0(ICOUPC,NAMODE)

      DO ICPL=1,ICOUPL
        FACTOR(ICPL)=1.D0
        DO I=2,NAMODE
          FACTOR(ICPL)=FACTOR(ICPL)*I
        END DO
        DO I=1,ICPL
          FACTOR(ICPL)=FACTOR(ICPL)/I
        END DO
        IDENOM=NAMODE-ICPL
        DO I=1,IDENOM
          FACTOR(ICPL)=FACTOR(ICPL)/I
        END DO
        IF(JREACT.GT.0)FACTOR(ICPL)=FACTOR(ICPL)+1
      END DO

      MAXCON=0
      MAXPRM=0
      MAXPTS=0
      MAXDMP=0
      MAXCI=0
      MAXRT=0
      ILOOP=1
      IF(LDUMP.EQ.6)THEN
        NUMDIP=1
        ICOUPL=1
        ILOOP=2
      END IF
C**************************************************************
      IF(IABS(LDUMP).GE.7)THEN
C**GET SPECTRUM
        READ(INP,*)
C**OUTPUT/INPUT BRANCH FILE [.PQR]
        READ(INP,'(A)')FILEB
        WRITE(IOUT,579)FILEB
        OPEN(UNIT=INP7,FILE=FILEB,STATUS='UNKNOWN')
        READ(INP,*)
C**OUTPUT/INPUT SPECTRUM FILE [.SPE]
        READ(INP,'(A)')FILES
        WRITE(IOUT,581)FILES
        OPEN(UNIT=INP8,FILE=FILES,FORM='UNFORMATTED',
     1  STATUS='UNKNOWN')
        READ(INP,*)
C**OUTPUT GAUSS FILE [.GAU]
        READ(INP,'(A)')FILEG
        WRITE(IOUT,580)FILEG
        OPEN(UNIT=INP9,FILE=FILEG,STATUS='UNKNOWN')
        READ(INP,*)
C**COMPLETE OR SPECIAL [0/1]
        READ(INP,*)KWHICH
        READ(INP,*)
C**PARTITION SUM (IR), INPUT FREQUENCY (RAMAN)
        READ(INP,*)QR,FREQ0
        READ(INP,*)
C**NO. PARENT SYMMETRIES FOR CURRENT RO-VIB SYMMETRY
        READ(INP,*)(NSPSYM(I),I=1,NRSYM)
        READ(INP,*)
C**NUCLEAR SPIN STATISTICS
        READ(INP,*)((NSPIN(J,I),J=1,NSPSYM(I)),I=1,NRSYM)
        READ(INP,*)
C**GAUSS HALF-WIDTH
        READ(INP,*)WDT
        READ(INP,*)
C**MINIMUM-MAXIMUM TRANSITION ENERGIES
        READ(INP,*)EMIN,EMAX
        IF(KWHICH.NE.0)THEN
          READ(INP,*)
C**INITIAL VIBRATIONAL LEVEL [v1,v2,v3...]
          READ(INP,*)(IV1(I),I=1,NMODE)
          READ(INP,*)
C**FINAL VIBRATIONAL LEVEL [v1,v2,v3...]
          READ(INP,*)(IV2(I),I=1,NMODE)
          READ(INP,*)
C**ROTATIONAL BRANCH [P,Q,R,A{all}]
          READ(INP,'(A)')IROT
        END IF
      END IF
      IF(LDUMP.LT.0)THEN
        CALL SPECTRUM(FILEG,WDT)
        CLOSE(INP8)
        RETURN
      END IF
C**************************************************************

C**RPH ODD K
      ILLPP=ILOOP
      IF(JREACT.GT.0)ILLPP=2
C**RPH ODD K
      ICOUPX=ICOUPL
C**P,Q,R-LOOP OVER ALL J IN PAIRS (JPREV & JCURR)
      DO 9998 JPREV=0,JMAX1-1
      IF(LDUMP.GE.7)JCURR=JPREV+1
      IJV=INP4-1
      DO 1000 ISWEEP=1,ILOOP
      IJV=IJV+1
C**READ ALL DATA UNTIL REQUIRED Js FOUND
      DO 9997 JREAD=0,JCURR
      IF(JREAD.EQ.0)REWIND IJV
      IF(JREAD.GT.0)GO TO 9997
C
C**FIRST SWEEP OF FILE (60)
C**************************************************************
C**************************************************************
      READ(IJV,END=10000)MMODE
      IF(MMODE.NE.NMODE)STOP 'WRONG MOLECULE'
      DO MODE=1,NMODE
C**NUMBER CONTRACTED AND PRIMITIVE FUNCTIONS (INPUT)
        READ(IJV)NVV,NBB
        IF(NVV.GT.MAXCON)MAXCON=NVV
        IF(NBB.GT.MAXPRM)MAXPRM=NBB
C**OMEGA AND NUMBER INTEGRATION POINTS (INPUT)
        READ(IJV)YLAM,MBB
        IF(MBB.GT.MAXPTS)MAXPTS=MBB
        CALL MEMO(1,LTEMP,MBB,0,0,0,0,0,0,0,0)
C**INTEGRATION POINTS (INPUT)
        CALL INP60R(MBB,W(LTEMP),IJV)
        CALL MEMO(-1,LTEMP,MBB,0,0,0,0,0,0,0,0)
      END DO
9997  CONTINUE
1000  CONTINUE
      CALL MEMO(5,LCONTR,MAXPRM*MAXCON*NMODE*ILOOP,LXQ,MAXPTS*NMODE,
C**RPH ODD K
     2LSCF,MAXCON*MAXCON*NMODE*ILOOP,LH,MAXCON*MAXPTS*3*NMODE*ILLPP,
C**RPH ODD K
     3LSX,MAXCON*MAXCON*NMODE*ILOOP)
      CALL MEMO(3,LISIZE,NVSYM*ILOOP,LIDUMP,NVSYM*ILOOP*JSTORE*J21MAX,
     1LNDUMP,NVSYM*ILOOP*JSTORE*J21MAX,0,0,0,0)
      CALL MEMO(1,LNFC,NMODE*2,0,0,0,0,0,0,0,0)
      IJV=INP4-1
      DO 2000 ISWEEP=1,ILOOP
      IJV=IJV+1
C**READ ALL DATA UNTIL REQUIRED Js FOUND
      DO 9977 JREAD=0,JCURR
      IF(JREAD.EQ.0)REWIND IJV
C
C**SECOND SWEEP OF FILE (60)
C**************************************************************
C**************************************************************
C**NUMBER OF MODES (INPUT)
      READ(IJV,END=10000)MMODE
      IF(MMODE.NE.NMODE)STOP 'WRONG MOLECULE'
      DO MODE=1,NMODE
C**NUMBER CONTRACTED AND PRIMITIVE FUNCTIONS (INPUT)
        READ(IJV)NVV,NBB
        CALL PUTINT(W(LNFC+NMODE*(ISWEEP-1)),MODE,NVV)
CC      NFC(MODE)=NVV
        CALL PUTINT(W(LNBF),MODE,NBB)
CC      NBF(MODE)=NBB
C**OMEGA AND NUMBER INTEGRATION POINTS (INPUT)
        READ(IJV)YLAM,MBB
        IF(ISWEEP.EQ.2)CALL COMPGS(W(LOMEGA),W(LMVB),YLAM,MBB,MODE)
        W(LOMEGA+MODE-1)=1/(YLAM*YLAM)
CC      OMEGA(MODE)=1/(YLAM*YLAM)
        CALL PUTINT(W(LMVB),MODE,MBB)
CC      MVB(MODE)=MBB
        CALL MEMO(1,LTEMP,MBB,0,0,0,0,0,0,0,0)
C**INTEGRATION POINTS (INPUT)
        CALL INP60R(MBB,W(LTEMP),IJV)
        CALL MEMO(-1,LTEMP,MBB,0,0,0,0,0,0,0,0)
      END DO
C  XQ is now the normal mode coordinate at point m mode mode
C**********************************
      DO MODE=1,NMODE
        CALL GETINT(W(LNFC+NMODE*(ISWEEP-1)),MODE,NVV)
CC      NVV=NFC(MODE)
        CALL GETINT(W(LMVB),MODE,MBB)
CC      MBB=MVB(MODE)
C**RPH ODD K
        INDMX=1
        IF(JREACT.GT.0.AND.MODE.EQ.NSMODE.AND.JREAD.GT.0)INDMX=2
        DO IND=1,INDMX
          DO K=1,3
            DO M=1,MBB
              CALL MEMO(1,LTEMP,NVV,0,0,0,0,0,0,0,0)
C**VSCF/VCI FUNCTIONS, 1ST AND 2ND DERIVATIVES AT INTEGRATION POINTS
**WITH SQRT(WEIGHT) INCLUDED (INPUT)
              CALL IN60(NVV,W(LTEMP),IJV)
              IF(JREACT.EQ.0)
     1        CALL IN4(W(LH),MAXCON,MAXPTS,NMODE,M,K,MODE,W(LTEMP),NVV,
     2        ILOOP,ISWEEP)
              IF(JREACT.NE.0)
     1        CALL IN4(W(LH),MAXCON,MAXPTS,NMODE,M,K,MODE,W(LTEMP),NVV,
     2        ILLPP,IND)
CC            DO IY=1,NVV
CC              H(IY,M,K,MODE)=W(IY)
CC            END DO
              CALL MEMO(-1,LTEMP,NVV,0,0,0,0,0,0,0,0)
            END DO
          END DO
        END DO
C**RPH ODD K
      END DO
C**********************************
      DO 1111 LC=1,LLCNT
C**NNMODE LIKE NSMODE.......TOTAL MODES IN VCI
      NNMODE=ICONT(LC)
C**NUMBER VCI SYMMETRIES (INPUT)
      READ(IJV)JTHIS,KSTEP,MVSYM,
     1(MWSYM(I),I=1,MVSYM),ICI,NMAX,NCONT(ISWEEP),
     2((NBAS(I,J,ISWEEP),I=1,6),J=1,2),
     3((MAXSUM(I,J,ISWEEP),I=1,6),J=1,2),
     4((MAXBAS(I,J,ISWEEP),I=1,NSMODE),J=1,IABS(NMAX))
      J21=2*JTHIS+1
C**USE TWO VALUES OF J AT A TIME
      IF(JTHIS.NE.JPREV.AND.JTHIS.NE.JCURR)JPUT=1
      IF(JTHIS.EQ.JPREV)JPUT=1
      IF(JTHIS.EQ.JCURR.AND.JMAX.GT.0)JPUT=2
      MMSS=MVSYM
      IF(JTHIS.GT.0)MMSS=NVSYM
      DO IYSYM=1,MMSS
        IF(JTHIS.EQ.0)THEN
          IVSYM=MWSYM(IYSYM)
        ELSE
          IVSYM=IYSYM
        END IF
C**SIZE OF VCI MATRIX (INPUT)
        READ(IJV)JSIZE
        NFTOT(IVSYM,ISWEEP)=JSIZE
        IF(JSIZE.EQ.0)GO TO 1112
        IF(JSIZE.GT.MAXCI)MAXCI=JSIZE
        CALL PUTINT(W(LISIZE+NVSYM*(ISWEEP-1)),IVSYM,JSIZE)
CC      ISIZE(IVSYM)=JSIZE
        DO I=1,JSIZE
          CALL MEMO(1,LTEMP,NNMODE,0,0,0,0,0,0,0,0)
          CALL INP60I(NNMODE,W(LTEMP),IJV)
          CALL MEMO(-1,LTEMP,NNMODE,0,0,0,0,0,0,0,0)
        END DO
C**LOOP OVER Ka
        DO KROT=1,J21,KSTEP
C**NUMBER OF CI FUNCTIONS (INPUT)
          READ(IJV)JDUMP
          IF(JDUMP.GT.MAXDMP)MAXDMP=JDUMP
          CALL PUTNT1(W(LIDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,ISWEEP,
     1    JPUT,KROT,JDUMP)
CC        IDUMP(IVSYM)=JDUMP
          CALL PUTNT1(W(LNDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,ISWEEP,
     1    JPUT,KROT,0)
CC        NDUMP(IVSYM)=0
          DO J=1,JDUMP
C**SPECIFIC CI FUNCTION AND ENERGY (INPUT)
            READ(IJV)K
            IF(K.GE.0)THEN
              READ(IJV)ENERGY
              CALL GETNT1(W(LNDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1        ISWEEP,JPUT,KROT,II)
CC            II=NDUMP(IVSYM)
              II=II+1
              CALL PUTNT1(W(LNDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1        ISWEEP,JPUT,KROT,II)
CC            NDUMP(IVSYM)=II
              CALL MEMO(1,LTEMP,2+NMODE,0,0,0,0,0,0,0,0)
C**ASSIGNMENTS FOR Jth EIGENFUNCTION (INPUT)
              CALL INP60A(NMODE,1,1,W(LTEMP),1,1,1,IJV)
              CALL MEMO(-1,LTEMP,2+NMODE,0,0,0,0,0,0,0,0)
              CALL MEMO(1,LTEMP,JSIZE,0,0,0,0,0,0,0,0)
C**CI COEFFICIENTS FOR Jth EIGENFUNCTION (INPUT)
              CALL INP60R(JSIZE,W(LTEMP),IJV)
              CALL MEMO(-1,LTEMP,JSIZE,0,0,0,0,0,0,0,0)
            END IF
          END DO
        END DO
1112    CONTINUE
      END DO

      IF(JTHIS.EQ.0)GO TO 1111
      IJR=INP5
      IF(JREAD.EQ.1)REWIND IJR
      DO IYSYM=1,MVSYM
        IVSYM=MWSYM(IYSYM)
C       IF(TRIAT)THEN
C         IF(IVSYM.LE.NVSYM)J21=JTHIS+1
C         IF(IVSYM.GT.NVSYM)J21=JTHIS
C       END IF
C**SIZE OF VCI MATRIX
        READ(IJR)JSIZE
        IF(JSIZE.EQ.0)GO TO 1113
C**SIZE OF EACH Ka BLOCK
C**NUMBER OF CI FUNCTIONS
        READ(IJR)NVAL,JDUMM,JDUMP
        J21=JSIZE/NVAL
        NVALV(JPUT)=NVAL
        NRTOT(IVSYM,ISWEEP,JPUT)=JSIZE
C**SET DEFAULTS FOR J=0 (LHS)
        IF(JPREV.EQ.0)THEN
          CALL GETNT1(W(LNDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1    ISWEEP,1,1,II)
CC        II=NDUMP(IVSYM)
          NRTOT(IVSYM,ISWEEP,1)=II
C         NVALV(1)=II
          IF(II.NE.0)NVALV(1)=II
          CALL PUTNT1(W(LIDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1    ISWEEP,1,1,II)
        END IF
CCCC    IF(JSIZE.EQ.0)GO TO 1113
        IF(JSIZE.GT.MAXRT)MAXRT=JSIZE
        CALL PUTINT(W(LISIZE+NVSYM*(ISWEEP-1)),IVSYM,JSIZE)
CC      ISIZE(IVSYM)=JSIZE
        IF(JDUMP.GT.MAXDMP)MAXDMP=JDUMP
        CALL PUTNT1(W(LIDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,ISWEEP,
     1  JPUT,1,0)
CC      IDUMP(IVSYM)=0
        DO J=1,JDUMP
C**SPECIFIC CI FUNCTION AND ENERGY (INPUT)
          READ(IJR)K
          IF(K.GE.0)THEN
            READ(IJR)ENERGY
            CALL GETNT1(W(LIDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1      ISWEEP,JPUT,1,II)
CC          II=IDUMP(IVSYM)
            II=II+1
            CALL PUTNT1(W(LIDUMP),NVSYM,ILOOP,JSTORE,J21MAX,IVSYM,
     1      ISWEEP,JPUT,1,II)
CC          IDUMP(IVSYM)=II
            CALL MEMO(1,LTEMP,2+NMODE,0,0,0,0,0,0,0,0)
C**ASSIGNMENTS FOR Jth EIGENFUNCTION (INPUT)
            CALL INP60A(NMODE,1,1,W(LTEMP),1,1,1,IJR)
            CALL MEMO(-1,LTEMP,2+NMODE,0,0,0,0,0,0,0,0)
            DO IK=1,J21
              CALL MEMO(1,LTEMP,NVAL,0,0,0,0,0,0,0,0)
              CALL INP60R(NVAL,W(LTEMP),IJR)
              CALL MEMO(-1,LTEMP,NVAL,0,0,0,0,0,0,0,0)
            END DO
          END IF
        END DO
1113    CONTINUE
      END DO

      IF(LC.EQ.LCONT)GO TO 9977
1111  CONTINUE
C**USE TWO VALUES OF J AT A TIME
C     IF(JTHIS.NE.JPREV.AND.JTHIS.NE.JCURR)GO TO 2000
9977  CONTINUE
2000  CONTINUE
      MAXSYM=NVSYM
      IF(LDUMP.EQ.6)MAXSYM=1
      CALL MEMO(5,LIP,MAXCI*NMODE*NVSYM*ILOOP,LVCI,MAXCI*MAXDMP*MAXSYM*
C    1ILOOP*JSTORE*J21MAX,LKDUMP,MAXDMP*NVSYM*ILOOP*JSTORE*J21MAX,LXK,
     1ILOOP*JSTORE,LKDUMP,MAXDMP*NVSYM*ILOOP*JSTORE*J21MAX,LXK,
     2MAXDMP*MAXDMP*NVSYM*NVSYM,LEVAL,MAXDMP*MAXSYM*ILOOP*JSTORE*
     3J21MAX)
      CALL MEMO(1,LCASS,MAXDMP*(2+NMODE)*MAXSYM*JSTORE,0,0,0,0,0,0,0,0)
      IF(LDUMP.GE.7)
     1CALL MEMO(3,LRCI,MAXRT*MAXDMP*NRSYM*ILOOP*JSTORE,
     2LRVAL,MAXDMP*NRSYM*ILOOP*JSTORE,LRASS,MAXDMP*(2+NMODE)*NRSYM*
     3JSTORE,0,0,0,0)
      IJV=INP4-1
      DO 3000 ISWEEP=1,ILOOP
      IJV=IJV+1
C**READ ALL DATA UNTIL REQUIRED Js FOUND
      DO 9777 JREAD=0,JCURR
      IF(JREAD.EQ.0)REWIND IJV
C
C**THIRD SWEEP OF FILE (60)
C**************************************************************
C**************************************************************
C**NUMBER OF MODES (INPUT)
      READ(IJV)NMODE
      DO MODE=1,NMODE
C**NUMBER CONTRACTED AND PRIMITIVE FUNCTIONS (INPUT)
        READ(IJV)NVV,NBB
C**OMEGA AND NUMBER INTEGRATION POINTS (INPUT)
        READ(IJV)YLAM,MBB
        CALL MEMO(1,LTEMP,MBB,0,0,0,0,0,0,0,0)
C**INTEGRATION POINTS (INPUT)
        CALL INP60R(MBB,W(LTEMP),IJV)
        CALL IN2R(W(LXQ),MAXPTS,MODE,W(LTEMP),MBB)
CC      READ(IJV)(XQ(M,MODE),M=1,MBB)
        CALL MEMO(-1,LTEMP,MBB,0,0,0,0,0,0,0,0)
      END DO
C  XQ is now the normal mode coordinate at point m mode mode
C**********************************
      DO MODE=1,NMODE
        CALL GETINT(W(LNFC+NMODE*(ISWEEP-1)),MODE,NVV)
CC      NVV=NFC(MODE)
        CALL GETINT(W(LMVB),MODE,MBB)
CC      MBB=MVB(MODE)
C**RPH ODD K
        INDMX=1
        IF(JREACT.GT.0.AND.MODE.EQ.NSMODE.AND.JREAD.GT.0)INDMX=2
        DO IND=1,INDMX
          DO K=1,3
            DO M=1,MBB
              CALL MEMO(1,LTEMP,NVV,0,0,0,0,0,0,0,0)
              CALL IN60(NVV,W(LTEMP),IJV)
              CALL MEMO(-1,LTEMP,NVV,0,0,0,0,0,0,0,0)
            END DO
          END DO
        END DO
C**RPH ODD K
      END DO
C**********************************
      DO 2222 LC=1,LLCNT
C**NNMODE LIKE NSMODE.......TOTAL MODES IN VCI
      NNMODE=ICONT(LC)
C**NUMBER VCI SYMMETRIES (INPUT)
      READ(IJV)JTHIS,KSTEP,MVSYM,
     1(MWSYM(I),I=1,MVSYM),ICI,NMAX,NCONT(ISWEEP),
     2((NBAS(I,J,ISWEEP),I=1,6),J=1,2),
     3((MAXSUM(I,J,ISWEEP),I=1,6),J=1,2),
     4((MAXBAS(I,J,ISWEEP),I=1,NSMODE),J=1,IABS(NMAX))
      J21=2*JTHIS+1
C**USE TWO VALUES OF J AT A TIME
      IF(JTHIS.NE.JPREV.AND.JTHIS.NE.JCURR)JPUT=1
      IF(JTHIS.EQ.JPREV)JPUT=1
      IF(JTHIS.EQ.JCURR.AND.JMAX.GT.0)JPUT=2
      MMSS=MVSYM
      IF(JTHIS.GT.0)MMSS=NVSYM
      MPUT=195+5*(JPUT-1)
      REWIND MPUT
      DO IYSYM=1,MMSS
        IF(JTHIS.EQ.0)THEN
          IVSYM=MWSYM(IYSYM)
        ELSE
          IVSYM=IYSYM
        END IF
C**SIZE OF VCI MATRIX (INPUT)
        READ(IJV)JSIZE
        IF(LDUMP.NE.6)WRITE(MPUT)JSIZE
        IF(JSIZE.EQ.0)GO TO 2223
        DO I=1,JSIZE
          CALL MEMO(1,LTEMP,NNMODE,0,0,0,0,0,0,0,0)
C**VCI BASIS (INPUT)
          CALL INP60I(NNMODE,W(LTEMP),IJV)
c  IP(I,J,IVSYM): I refers to the eigenvector index, J is the mode
c  and IP is the corrsponding basis function no. for the Jth mode.
          CALL IN3I(W(LIP),MAXCI,NNMODE,NVSYM,I,IVSYM,W(LTEMP),ISWEEP)
CC        READ(IJV)(IP(I,J,IVSYM),J=1,NNMODE)
          CALL MEMO(-1,LTEMP,NNMODE,0,0,0,0,0,0,0,0)
        END DO
C**LOOP OVER Ka
        DO KROT=1,J21,KSTEP
C**NUMBER of  CI FUNCTIONS (INPUT)
          READ(IJV)JDUMP
          DO J=1,JDUMP
C**SPECIFIC CI FUNCTION AND ENERGY (INPUT)
            READ(IJV)K
            CALL IN2I(W(LKDUMP),MAXDMP,NVSYM,J,IVSYM,K,ISWEEP,ILOOP,
     1      JSTORE,JPUT,KROT)
CC          KDUMP(J,IVSYM)=K
            IF(K.GE.0)THEN
              READ(IJV)ENERGY
              CALL IN2D(W(LEVAL),MAXDMP,MAXSYM,J,IVSYM,ENERGY,ISWEEP,
     1        ILOOP,JSTORE,JPUT,KROT)
CC            EVAL(J,IVSYM)=ENERGY
C**ASSIGNMENTS FOR Jth EIGENFUNCTION (INPUT)
              CALL INP60A(NMODE,MAXDMP,MAXSYM,W(LCASS),J,IVSYM,
     1        JPUT,IJV)
              CALL MEMO(1,LTEMP,JSIZE,0,0,0,0,0,0,0,0)
C**CI COEFFICIENTS FOR Jth EIGENFUNCTION (INPUT)
              CALL INP60R(JSIZE,W(LTEMP),IJV)
              CALL IN3R(W(LVCI),MAXCI,MAXDMP,MAXSYM,J,IVSYM,W(LTEMP),
C    1        JSIZE,ISWEEP,ILOOP,JSTORE,LDUMP,JPUT,KROT,0)
     1        JSIZE,ISWEEP,ILOOP,JSTORE,LDUMP,JPUT,MPUT,0)
CC            READ(IJV)(VCI(I,J,IVSYM),I=1,JSIZE)
              CALL MEMO(-1,LTEMP,JSIZE,0,0,0,0,0,0,0,0)
            END IF
          END DO
        END DO
2223    CONTINUE
      END DO

C**IF J=0, MAKE SURE RCI,RVAL,RASS ARE SET UP FROM VCI,EVAL,CASS
      IF(JTHIS.EQ.0)THEN
        IF(LDUMP.GE.7)THEN
          MVSYM0=MVSYM
C**IF CURRENT J=1, NEED COEFFICIENTS FOR J=0 (LHS)
          CALL J0CDIP(W(LRCI),MAXRT,MAXDMP,NRSYM,ILOOP,JSTORE)
C**IF CURRENT J=1, NEED ASSIGNMENTS FOR J=0 (LHS)
          CALL J0ADIP(W(LRASS),W(LCASS),NMODE,MAXDMP,NRSYM,MAXSYM,
     1    JSTORE)
C**IF CURRENT J=1, NEED ENERGIES FOR J=0 (LHS)
          CALL J0EDIP(W(LRVAL),W(LEVAL),MAXDMP,NRSYM,MAXSYM,ILOOP,
     1    JSTORE)
        END IF
        GO TO 2222
      END IF
      IJR=INP5
      IF(JREAD.EQ.1)REWIND IJR
      DO IYSYM=1,MVSYM
        IVSYM=MWSYM(IYSYM)
C       IF(TRIAT)THEN
C         IF(IVSYM.LE.NVSYM)J21=JTHIS+1
C         IF(IVSYM.GT.NVSYM)J21=JTHIS
C       END IF
C**SIZE OF VCI MATRIX
        READ(IJR)JSIZE
        IF(JSIZE.EQ.0)GO TO 1114
C**SIZE OF EACH Ka BLOCK
C**NUMBER OF CI FUNCTIONS
        READ(IJR)NVAL,JDUMM,JDUMP
        J21=JSIZE/NVAL
CCCC    IF(JSIZE.EQ.0)GO TO 1114
        DO J=1,JDUMP
C**SPECIFIC CI FUNCTION AND ENERGY (INPUT)
          READ(IJR)K
          IF(K.GE.0)THEN
            READ(IJR)ENERGY
            CALL IN2D(W(LRVAL),MAXDMP,NRSYM,J,IVSYM,ENERGY,ISWEEP,
     1      ILOOP,JSTORE,JPUT,1)
CCCC        RVAL(J,IVSYM)=ENERGY
C**ASSIGNMENTS FOR Jth EIGENFUNCTION (INPUT)
            CALL INP60A(NMODE,MAXDMP,NRSYM,W(LRASS),J,IVSYM,
     1      JPUT,IJR)
            IOFF=0
            DO IK=1,J21
              CALL MEMO(1,LTEMP,NVAL,0,0,0,0,0,0,0,0)
C**CI COEFFICIENTS FOR Jth EIGENFUNCTION (INPUT)
              CALL INP60R(NVAL,W(LTEMP),IJR)
              CALL IN3R(W(LRCI),MAXRT,MAXDMP,NRSYM,J,IVSYM,W(LTEMP),
C    1        NVAL,ISWEEP,ILOOP,JSTORE,LDUMP,JPUT,1,IOFF)
     1        NVAL,ISWEEP,ILOOP,JSTORE,LDUMP,JPUT,0,IOFF)
CCCC          READ(IJR)(RCI(I,J,IVSYM),I=1,JSIZE)
              CALL MEMO(-1,LTEMP,NVAL,0,0,0,0,0,0,0,0)
              IOFF=IOFF+NVAL
            END DO
          END IF
        END DO
1114    CONTINUE
      END DO

      IF(LC.EQ.LCONT)GO TO 9777
2222  CONTINUE
C**USE TWO VALUES OF J AT A TIME
C     IF(JTHIS.NE.JPREV.AND.JTHIS.NE.JCURR)GO TO 3000
9777  CONTINUE
3000  CONTINUE
      CALL MEMO(-1,LCASS,MAXDMP*(2+NMODE)*MAXSYM*JSTORE,
     10,0,0,0,0,0,0,0)
      IF(JPREV.GT.0.OR.LDUMP.EQ.9)GO TO 4444
      IF(LDUMP.EQ.4)THEN
        CALL PLOTIN(W,MAXCON,MAXPTS,MAXCI,MAXDMP,W(LNDUMP),
     1  W(LKDUMP))
        RETURN
      END IF
C**********************************************************************
C**********************************************************************
C**DUMP DIPOLE GRIDS
C**********************************************************************
C**********************************************************************
      IF(LDUMP.NE.6.AND.LCONT.EQ.1)THEN
        CALL GRIDS(W(1),W(LXQ),MAXPTS,W(LMVB),NMODE,NATOM,LDUMP)
      END IF
C**********************************************************************
C**TEMPORARY TEST OVERLAPS
C**********************************************************************
      IF(LDUMP.LT.7)THEN
C       WRITE(IOUT,*)'OVERLAPS FOR SCHEME ',LCONT
C       CALL PROV(W(LNFC),W(LMVB),NMODE,W(LSX),MAXCON,W(LH),MAXPTS,
C    1  ILOOP)
C       CALL CIOV(W(LIDUMP),W(LNDUMP),NVSYM,ILOOP,JSTORE,
C    1  W(LISIZE),W(LXK),W(LKDUMP),
C    1  W(LVCI),MAXCI,MAXDMP,MAXSYM,W(LIP),NNMODE)
C       GO TO 9996
      END IF
C**********************************************************************
C**TEMPORARY TEST OVERLAPS
C**********************************************************************
      IF(LDUMP.GT.8)GO TO 9999
C**********************************************************************
C**********************************************************************
C**GET BASIS SETS FOR BASIC INTEGRALS
C**********************************************************************
C**********************************************************************
C**RESET NMAX IF UNRESTRICTED
      IF(NMAX.EQ.0)NMAX=-ICI*NMODE
      NBFMIN=100000
      DO ISWEEP=1,ILOOP
        DO K=1,NMODE
          CALL GETINT(W(LNFC+NMODE*(ISWEEP-1)),K,IK3)
          IF(IK3.LT.NBFMIN)NBFMIN=IK3
        END DO
      END DO
C**********************************************************************
C**********************************************************************
C**                                                                 VCI
C**********************************************************************
C**********************************************************************
      IF(ICI.LT.0.AND.NMAX.GE.0)THEN
        JCI=-ICI
        IF(NMAX.GT.0)THEN
C********************************************************************
C**CONVERT NMAX FROM NUMBER OF FUNCTIONS TO ORIGINAL NUMBER OF QUANTA
          NMAX=NMAX-NMODE
C********************************************************************
C**ONLY GET NMAX +1 (MAXIMUM) INTEGRALS
          IF(NMAX+1.LT.JCI)JCI=NMAX+1
C**OR NBFMIN (MAXIMUM) INTEGRALS (WHICHEVER IS SMALLER)
          IF(JCI.GT.NBFMIN)JCI=NBFMIN
C**CONVERT NMAX FROM QUANTA TO NUMBER OF FUNCTIONS
          NMAX=NMAX+NMODE
        END IF
      END IF
      IF(ICI.LT.0)THEN
        NVSYMX=NVSYM
        NVSYM=1
C**NNMAX USED AS INDICATOR AS TO WHICH ALGORITHM
        NNMAX=NMAX
        IF(NNMAX.GE.0)THEN
C********************************************************************
C**NMAX SAVED IN NMAXMX (RE-LOADED LATER)
          NMAXMX=NMAX
C********************************************************************
          DO I=1,6
C**MAX POSSIBLE QUANTA
            NBAS(I,1,1)=JCI-1
C**MAX POSSIBLE SUM
            MAXSUM(I,1,1)=I*NBAS(I,1,1)
            IF(NNMAX.GT.0)MAXSUM(I,1,1)=MIN0(NNMAX,I*NBAS(I,1,1))
          END DO
C**INDIVIDUAL QUANTUM
          CALL DEFMAX(W(LMXBAS),NMODE,JCI)
          JCI1=JCI
          JCI2=JCI
          JCI3=JCI
          JCI4=JCI
          JCI5=JCI
          JCI6=JCI
        ELSE
C**MAX POSSIBLE QUANTA
          JCI1=0
          JCI2=0
          JCI3=0
          JCI4=0
          JCI5=0
          JCI6=0
          DO ISWEEP=1,ILOOP
            DO K=1,NCONT(ISWEEP)
              ICI1=NBAS(1,K,ISWEEP)+1
              ICI2=MAX0(NBAS(1,K,ISWEEP)+1,NBAS(2,K,ISWEEP)+1)
              ICI3=MAX0(NBAS(1,K,ISWEEP)+1,NBAS(2,K,ISWEEP)+1,
     1        NBAS(3,K,ISWEEP)+1)
              ICI4=MAX0(NBAS(1,K,ISWEEP)+1,NBAS(2,K,ISWEEP)+1,
     1        NBAS(3,K,ISWEEP)+1,NBAS(4,K,ISWEEP)+1)
              ICI5=MAX0(NBAS(1,K,ISWEEP)+1,NBAS(2,K,ISWEEP)+1,
     1        NBAS(3,K,ISWEEP)+1,NBAS(4,K,ISWEEP)+1,NBAS(5,K,ISWEEP)+1)
              ICI6=MAX0(NBAS(1,K,ISWEEP)+1,NBAS(2,K,ISWEEP)+1,
     1        NBAS(3,K,ISWEEP)+1,NBAS(4,K,ISWEEP)+1,NBAS(5,K,ISWEEP)+1,
     2        NBAS(6,K,ISWEEP)+1)
              IF(ICI1.GT.JCI1)JCI1=ICI1
              IF(ICI2.GT.JCI2)JCI2=ICI2
              IF(ICI3.GT.JCI3)JCI3=ICI3
              IF(ICI4.GT.JCI4)JCI4=ICI4
              IF(ICI5.GT.JCI5)JCI5=ICI5
              IF(ICI6.GT.JCI6)JCI6=ICI6
            END DO
          END DO
        END IF
C*******************************************************
C**GET SIZES OF 1-,2-,3-,4-,5- MODE BASIC BASES - START
C*******************************************************
        IF(ICOUPL.GT.0.OR.(NNMAX.LT.0.AND.ICI.LT.0))THEN
          NMAX1=MAXSUM(1,1,1)+1
          NMAX2=MAXSUM(1,2,1)+1
          NMAX3=MAXSUM(1,1,2)+1
          NMAX4=MAXSUM(1,2,2)+1
          NMAX=MAX0(NMAX1,NMAX2,NMAX3,NMAX4)
          ISIZE1=JCI1
C**FIRST GET SIZE (ISIZE1 MODIFIED IN GETSZ FOR NMAX)
          CALL GETSZ(ISIZE1,1,JCI1,0)
          NSIZE1=ISIZE1
          KIP1=ISIZE1
          CALL MEMO(1,LIP1,KIP1*ILOOP,0,0,0,0,0,0,0,0)
        END IF
C
        IF((ICOUPL.GT.1.OR.(NNMAX.LT.0.AND.ICI.LT.-1)).OR.
     1    (ICOUPL.EQ.1.AND.IREACT.NE.0))THEN
          NMAX1=MAX0(MAXSUM(1,1,1)+2,MAXSUM(2,1,1)+2)
          NMAX2=MAX0(MAXSUM(1,2,1)+2,MAXSUM(2,2,1)+2)
          NMAX3=MAX0(MAXSUM(1,1,2)+2,MAXSUM(2,1,2)+2)
          NMAX4=MAX0(MAXSUM(1,2,2)+2,MAXSUM(2,2,2)+2)
          NMAX=MAX0(NMAX1,NMAX2,NMAX3,NMAX4)
          ISIZE2=JCI2**2
C**FIRST GET SIZE (ISIZE2 MODIFIED IN GETSZ FOR NMAX)
          CALL GETSZ(ISIZE2,2,JCI2,0)
          NSIZE2=ISIZE2
          KIP2=ISIZE2*2
          CALL MEMO(1,LIP2,KIP2*ILOOP,0,0,0,0,0,0,0,0)
        END IF
C
        IF((ICOUPL.GT.2.OR.(NNMAX.LT.0.AND.ICI.LT.-2)).OR.
     1    (ICOUPL.EQ.2.AND.IREACT.NE.0))THEN
          NMAX1=MAX0(MAXSUM(1,1,1)+3,MAXSUM(2,1,1)+3,MAXSUM(3,1,1)+3)
          NMAX2=MAX0(MAXSUM(1,2,1)+3,MAXSUM(2,2,1)+3,MAXSUM(3,2,1)+3)
          NMAX=MAX0(NMAX1,NMAX2)
          ISIZE3=JCI3**3
C**FIRST GET SIZE (ISIZE3 MODIFIED IN GETSZ FOR NMAX)
          CALL GETSZ(ISIZE3,3,JCI3,0)
          NSIZE3=ISIZE3
          KIP3=ISIZE3*3
          CALL MEMO(1,LIP3,KIP3,0,0,0,0,0,0,0,0)
        END IF
C  
        IF((ICOUPL.GT.3.OR.(NNMAX.LT.0.AND.ICI.LT.-3)).OR.
     1    (ICOUPL.EQ.3.AND.IREACT.NE.0))THEN
          NMAX1=MAX0(MAXSUM(1,1,1)+4,MAXSUM(2,1,1)+4,MAXSUM(3,1,1)+4,
     1    MAXSUM(4,1,1)+4)
          NMAX2=MAX0(MAXSUM(1,2,1)+4,MAXSUM(2,2,1)+4,MAXSUM(3,2,1)+4,
     1    MAXSUM(4,2,1)+4)
          NMAX=MAX0(NMAX1,NMAX2)
          ISIZE4=JCI4**4
C**FIRST GET SIZE (ISIZE4 MODIFIED IN GETSZ FOR NMAX)
          CALL GETSZ(ISIZE4,4,JCI4,0)
          NSIZE4=ISIZE4
          KIP4=ISIZE4*4
          CALL MEMO(1,LIP4,KIP4,0,0,0,0,0,0,0,0)
        END IF
C
        IF((ICOUPL.GT.4.OR.(NNMAX.LT.0.AND.ICI.LT.-4)).OR.
     1    (ICOUPL.EQ.4.AND.IREACT.NE.0))THEN
          NMAX1=MAX0(MAXSUM(1,1,1)+5,MAXSUM(2,1,1)+5,MAXSUM(3,1,1)+5,
     1    MAXSUM(4,1,1)+5,MAXSUM(5,1,1)+5)
          NMAX2=MAX0(MAXSUM(1,2,1)+5,MAXSUM(2,2,1)+5,MAXSUM(3,2,1)+5,
     1    MAXSUM(4,2,1)+5,MAXSUM(5,2,1)+5)
          NMAX=MAX0(NMAX1,NMAX2)
          ISIZE5=JCI5**5
C**FIRST GET SIZE (ISIZE5 MODIFIED IN GETSZ FOR NMAX)
          CALL GETSZ(ISIZE5,5,JCI5,0)
          NSIZE5=ISIZE5
          KIP5=ISIZE5*5
          CALL MEMO(1,LIP5,KIP5,0,0,0,0,0,0,0,0)
        END IF
C*******************************************************
C**GET SIZES OF 1-,2-,3-,4-,5- MODE BASIC BASES - END
C*******************************************************
        NVSYM=NVSYMX
      END IF
C**********************************************************************
C**********************************************************************
C**GET BASIC INTEGRALS FOR VIBRATIONAL BASIS
C**********************************************************************
C**********************************************************************
4500  CONTINUE
      ITIM=-1
      IF(IREACT.GT.0)THEN
        REWIND 20
        REWIND 30
        REWIND 40
        IF(LDUMP.EQ.8)THEN
          REWIND 50
          REWIND 60
        END IF
      END IF
      IF(ICOUPL.GE.0)THEN
        REWIND 21
        REWIND 31
        REWIND 41
        IF(LDUMP.EQ.8)THEN
          REWIND 51
          REWIND 61
        END IF
      END IF
      IF(ICOUPL.GT.1)THEN
        REWIND 22
        REWIND 32
        REWIND 42
        IF(LDUMP.EQ.8)THEN
          REWIND 52
          REWIND 62
        END IF
      END IF
      IF(ICOUPL.GT.2)THEN
        REWIND 23
        REWIND 33
        REWIND 43
        IF(LDUMP.EQ.8)THEN
          REWIND 53
          REWIND 63
        END IF
      END IF
      IF(ICOUPL.GT.3)THEN
        REWIND 24
        REWIND 34
        REWIND 44
        IF(LDUMP.EQ.8)THEN
          REWIND 54
          REWIND 64
        END IF
      END IF
C****************************
C**X,Y,Z COMPONENTS OF DIPOLE
C****************************
C**RPH ODD K
      KLOOP=1
      IF(JREACT.GT.0.AND.(LDUMP.EQ.7.OR.LDUMP.EQ.8))KLOOP=IFLAUD
      DO 33000 KROTR=1,KLOOP
      DO 33000 KROTL=1,KLOOP
C**RPH ODD K
      ISUBTR=0
C**TRIATOMICS ALWAYS ONLY HAVE Y,Z COMPONENTS
      NUMST=1
      IF(TRIAT)NUMST=2
      DO 33000 IDIP=NUMST,NUMDIP
      IXDIP=IDIP-ISUBTR
      ITIM=ITIM+1
      IF(IREACT.GT.0)THEN
        REWIND 71
        REWIND 81
        REWIND 91
        IF(LDUMP.EQ.8)THEN
          REWIND 101
          REWIND 111
        END IF
      END IF
      IF(ICOUPL.GT.0)THEN
        REWIND 72
        REWIND 82
        REWIND 92
        IF(LDUMP.EQ.8)THEN
          REWIND 102
          REWIND 112
        END IF
      END IF
      IF(ICOUPL.GT.1)THEN
        REWIND 73
        REWIND 83
        REWIND 93
        IF(LDUMP.EQ.8)THEN
          REWIND 103
          REWIND 113
        END IF
      END IF
      IF(ICOUPL.GT.2)THEN
        REWIND 74
        REWIND 84
        REWIND 94
        IF(LDUMP.EQ.8)THEN
          REWIND 104
          REWIND 114
        END IF
      END IF
      IF(ICOUPL.GT.3)THEN
        REWIND 75
        REWIND 85
        REWIND 95
        IF(LDUMP.EQ.8)THEN
          REWIND 105
          REWIND 115
        END IF
      END IF
C**GET TORSION-ONLY INTEGRALS IF RPH
      IF(JREACT.GT.0)THEN
C**GET POINTERS TO TAU FUNCTIONS
        K2TAU=0
        K3TAU=0
        DO I=1,NSMODE-1
C**RPH ODD K
          K2TAU=K2TAU+3*MAXCON*MAXPTS*ILLPP
C**RPH ODD K
          K3TAU=K3TAU+MAXPTS
        END DO
C*****************************   LIKE V0DP1 (NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR SINGLE MODE
        CALL GETBP1(W(LIP1),ISIZE1,NSMODE,NSMODE,W(LMXBAS),NSIZE1,0)
        KXA1=NSIZE1*(NSIZE1+1)/2
        CALL MEMO(1,LXA0,KXA1,0,0,0,0,0,0,0,0)
C**ZEROISE MATRIX
        CALL DIAGZ(NSIZE1,NSIZE1,W(LXA0),NSIZE1,W(LXA0),ICI)
        CALL GETINT(W(LMVB),NSMODE,IK2TAU)
        CALL GETINT(W(LNVF),NSMODE,IK3TAU)
        CALL V0DV0(NAMODE,1,MAXCON,MAXPTS,W(LH+K2TAU),W(LXQ+K3TAU),
     1  W(LXA0),NSIZE1,IK3TAU,IK2TAU,W(LIP1),ISIZE1,KROTL,KROTR,IDIP,
     2  IXDIP,NMODE,NATOM,W(LQQ),W(LRR),W(LXX),W(LXM),NPOT,W(LIPOT),
     3  W(LJPOT),W(LCPOT),W(LMODNT))
        CALL MATOUT(W(LXA0),W(LXA0),NSIZE1,10*IXDIP+10)
        CALL MEMO(-1,LXA0,KXA1,0,0,0,0,0,0,0,0)
C**
C*****************************   LIKE V0DP1 (NMODE)
      END IF
      IF(ICOUPL.EQ.0)GO TO 3300
C**INTEGRATE OVER SINGLE NORMAL COORDINATE
      K=0
      K2=0
      K3=0
      KRK=1
      DO KK=1,NAMODS
        IF(KK.EQ.1.AND.ITIM.EQ.0)ITIM1A=0
        IF(LLCNT.GT.1)THEN
          IF(KRK.LE.NAMODE)THEN
            KNEXT=JCONT(LCONT,KRK)
            IF(KK.EQ.KNEXT)KRK=KRK+1
          ELSE
            KNEXT=0
          END IF
        ELSE
          KNEXT=KK
        END IF
C**NEXT K
        K=KNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK?
        IF(KK.NE.KNEXT)THEN
C**DUMMY READ IF MISSING MODE KK
          CALL GETINT(W(LMVB),KK,IK2)
          IF(JREACT.LE.0)
     1    THEN
            IF(ICOUPX.GT.0.AND.IREACT.EQ.0)
     1      CALL DUMDD1(IK2,W(LV1),W(LV1),IXDIP)
          ELSE
C           IF(ICOUPX.GT.0)CALL DUMVV1(KK,IK2,IK2TAU,W(LV1),W(LV1),
C    1      W(LC1),W(LC1),W(LEJK1),W(LEJK1),J21,W(LMODNT))
          END IF
          GO TO 331
        END IF

C**SKIP IF UNWANTED KK
        IF(KNEXT.EQ.0.OR.KK.NE.KNEXT)GO TO 331
        IF(JREACT.LE.0)THEN
          IF(LDUMP.EQ.6)THEN
C**GET BASIC INTEGRAL BASIS FOR SINGLE MODE
            CALL GETBP1(W(LIP1),ISIZE1,NSMODE,K,MAXBAS,NSIZER,0)
            CALL GETBP1(W(LIP1+ISIZE1),ISIZE1,NSMODE,K,
     1      MAXBAS(1,1,2),NSIZEL,0)
            KXA1=NSIZEL*NSIZER
            CALL MEMO(1,LXA1,KXA1,0,0,0,0,0,0,0,0)
C**ZEROISE MATRIX
            CALL DIAGZ(NSIZEL,NSIZER,W(LXA1),NSIZEL,W(LXA1),IABS(ICI))
            CALL GETINT(W(LMVB),K,IK2)
            CALL V0FP1(1,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),W(LXA1),
     1      NSIZEL,NSIZER,IK2,W(LIP1),ISIZE1)
            CALL FATOUT(W(LXA1),W(LXA1),NSIZEL,NSIZER,10*IXDIP+11)
            CALL MEMO(-1,LXA1,KXA1,0,0,0,0,0,0,0,0)
          ELSE
C**GET BASIC INTEGRAL BASIS FOR SINGLE MODE
            CALL GETBP1(W(LIP1),ISIZE1,NSMODE,K,W(LMXBAS),NSIZE1,0)
            KXA1=NSIZE1*(NSIZE1+1)/2
            CALL MEMO(1,LXA1,KXA1,0,0,0,0,0,0,0,0)
C**ZEROISE MATRIX
            CALL DIAGZ(NSIZE1,NSIZE1,W(LXA1),NSIZE1,W(LXA1),ICI)
            CALL GETINT(W(LMVB),K,IK2)
            CALL GETINT(W(LNVF),K,IK3)
            CALL V0DP1(NAMODE,1,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),
     1      W(LXA1),NSIZE1,IK3,IK2,W(LIP1),ISIZE1,W(LV1),W(LV1),IDIP,
     2      IXDIP,K,W(LMODNT))
            CALL MATOUT(W(LXA1),W(LXA1),NSIZE1,10*IXDIP+11)
            CALL MEMO(-1,LXA1,KXA1,0,0,0,0,0,0,0,0)
          END IF
        ELSE
C*****************************   LIKE V0DP2 (K+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
          CALL GETBP2(W(LIP2),ISIZE2,NSMODE,K,NSMODE,W(LMXBAS),NSIZE2,
     1    0)
          KXA2=NSIZE2*(NSIZE2+1)/2
          CALL GETINT(W(LMBF),K,IK2)
          CALL GETINT(W(LNVF),K,IK3)
          JCI=MAXBFN(W(LMXBAS),NSMODE,K,1)
          JCIM=MAXBFN(W(LMXBAS),NSMODE,NSMODE,1)
          KTEMP=JCI*JCI
          KXK0=JCI*JCI*IK2
          KXL0=JCIM*JCIM*IK2TAU
          CALL MEMO(2,LXA1,KXA2,LTEMP,KTEMP,0,0,0,0,0,0)
          CALL MEMO(2,LXK0,KXK0,LXL0,KXL0,0,0,0,0,0,0)
C**ZEROISE MATRIX
          CALL DIAGZ(NSIZE2,NSIZE2,W(LXA1),NSIZE2,W(LXA1),ICI)
          CALL V0DV1(NAMODE,1,2,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),
     1    W(LH+K2TAU),W(LXQ+K3TAU),W(LXA1),NSIZE2,IK3,IK2,IK3TAU,
     2    IK2TAU,W(LIP2),ISIZE2,W(LTEMP),JCI,JCIM,W(LXK0),W(LXL0),
     3    W(LV1),W(LV1),KROTL,KROTR,IDIP,IXDIP,NMODE,NATOM,W(LQQ),
     4    W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),
     5    K,W(LMODNT))
          CALL MATOUT(W(LXA1),W(LXA1),NSIZE2,10*IXDIP+11)
          CALL MEMO(-2,LXA1,KXA2,LTEMP,KTEMP,0,0,0,0,0,0)
          CALL MEMO(-2,LXK0,KXK0,LXL0,KXL0,0,0,0,0,0,0)
C**
C*****************************   LIKE V0DP2 (K+NMODE)
        END IF
331   CONTINUE
        IF(ICOUPL.EQ.1)GO TO 3301
C**INTEGRATE OVER TWO NORMAL COORDINATES
        L=0
        L2=0
        L3=0
        LRL=1
        DO LL=1,KK-1
          IF(LL.EQ.1.AND.KK.EQ.2.AND.ITIM.EQ.0)ITIM2A=0
          IF(LLCNT.GT.1)THEN
            IF(LRL.LE.NAMODE)THEN
              LNEXT=JCONT(LCONT,LRL)
              IF(LL.EQ.LNEXT)LRL=LRL+1
            ELSE
              LNEXT=0
            END IF
          ELSE
            LNEXT=LL
          END IF
C**NEXT L
          L=LNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL?
          IF(KK.NE.KNEXT.OR.LL.NE.LNEXT)THEN
C**DUMMY READ IF MISSING MODES KK AND LL
            CALL GETINT(W(LMVB),KK,IK2)
            CALL GETINT(W(LMVB),LL,IL2)
            IF(JREACT.LE.0)
     2      THEN
              IF(IREACT.EQ.0)CALL DUMDD2(IK2,IL2,W(LV2),W(LV2),IXDIP)
            ELSE
C             CALL DUMVV2(KK,LL,IK2,IL2,IK2TAU,W(LV2),W(LV2),W(LC2),
C    1        W(LC2),W(LEJK2),W(LEJK2),J21,W(LMODNT))
            END IF
            GO TO 332
          END IF

C**SKIP IF UNWANTED LL
          IF(LNEXT.EQ.0.OR.LL.NE.LNEXT)GO TO 332
          IF(JREACT.LE.0)THEN
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
            CALL GETBP2(W(LIP2),ISIZE2,NSMODE,K,L,W(LMXBAS),NSIZE2,0)
            KXA2=NSIZE2*(NSIZE2+1)/2
            JCI1=MAXBFN(W(LMXBAS),NMODE,K,1)
            JCI2=MAXBFN(W(LMXBAS),NMODE,L,1)
            KTEMP=JCI2*JCI2
            CALL MEMO(2,LXA2,KXA2,LTEMP,KTEMP,0,0,0,0,0,0)
C**ZEROISE MATRIX
            CALL DIAGZ(NSIZE2,NSIZE2,W(LXA2),NSIZE2,W(LXA2),ICI)
            CALL GETINT(W(LMVB),L,IL2)
            CALL GETINT(W(LNVF),L,IL3)
C**TEMPORARY
C     IF(IDIP.EQ.2)THEN
C       WRITE(IOUT,*)'KK,LL,KNEXT,LNEXT,K,L'
C       WRITE(IOUT,*)KK,LL,KNEXT,LNEXT,K,L
C       WRITE(IOUT,*)'K2,K3,L2,L3'
C       WRITE(IOUT,*)K2,K3,L2,L3
C     END IF 
C**TEMPORARY
C**GET BASIC INTEGRAL BASIS FOR SINGLE MODE
            CALL GETBP1(W(LIP1),ISIZE1,NSMODE,L,W(LMXBAS),NSIZE1,0)
            CALL V0DP2(NAMODE,1,2,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),
     1      W(LH+L2),W(LXQ+L3),IK3,IK2,IL3,IL2,W(LXA2),NSIZE2,W(LIP2),
     2      ISIZE2,W(LTEMP),JCI1,JCI2,W(LV2),W(LV2),W(LIP1),ISIZE1,
     3      NSIZE1,IXDIP,K,L,W(LMODNT))
            CALL MATOUT(W(LXA2),W(LXA2),NSIZE2,10*IXDIP+12)
            CALL MEMO(-2,LXA2,KXA2,LTEMP,KTEMP,0,0,0,0,0,0)
          ELSE
C*****************************   LIKE V0DP3 (K+L+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR THREE MODES
            CALL GETBP3(W(LIP3),ISIZE3,NSMODE,K,L,NSMODE,W(LMXBAS),
     1      NSIZE3,0)
            KXA3=NSIZE3*(NSIZE3+1)/2
            CALL GETINT(W(LMBF),L,IL2)
            CALL GETINT(W(LNVF),L,IL3)
            JCI1=MAXBFN(W(LMXBAS),NSMODE,K,1)
            JCI2=MAXBFN(W(LMXBAS),NSMODE,L,1)
            JCIM=MAXBFN(W(LMXBAS),NSMODE,NSMODE,1)
            KTEMP=JCI1*JCI2*JCI1*JCI2
            KTEMP2=JCI2*JCI2
            KXK0=JCI1*JCI1*IK2
            KXL0=JCI2*JCI2*IL2
            KXN0=JCIM*JCIM*IK2TAU
            CALL MEMO(3,LXA2,KXA3,LTEMP,KTEMP,LTEMP2,KTEMP2,0,0,0,0)
            CALL MEMO(3,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,0,0,0,0)
C**ZEROISE MATRIX
            CALL DIAGZ(NSIZE3,NSIZE3,W(LXA2),NSIZE3,W(LXA2),ICI)
            CALL V0DV2(NAMODE,1,2,3,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),
     1      W(LH+L2),W(LXQ+L3),W(LH+K2TAU),W(LXQ+K3TAU),W(LXA2),NSIZE3,
     2      IK3,IK2,IL3,IL2,IK3TAU,IK2TAU,W(LIP3),ISIZE3,W(LTEMP),
     3      W(LTEMP2),JCI1,JCI2,JCIM,W(LXK0),W(LXL0),W(LXN0),
     4      W(LV2),W(LV2),KROTL,KROTR,IXDIP,NMODE,NATOM,W(LQQ),
     5      W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),W(LJPOT),
     6      W(LCPOT),K,L,W(LMODNT))
            CALL MATOUT(W(LXA2),W(LXA2),NSIZE3,10*IXDIP+12)
            CALL MEMO(-3,LXA2,KXA3,LTEMP,KTEMP,LTEMP2,KTEMP2,0,0,0,0)
            CALL MEMO(-3,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,0,0,0,0)
C**
C*****************************   LIKE V0DP3 (K+L+NMODE)
          END IF
332   CONTINUE
          IF(ICOUPL.EQ.2)GO TO 3302
C**INTEGRATE OVER THREE NORMAL COORDINATES
          N=0
          N2=0
          N3=0
          NRN=1
          DO NN=1,LL-1
            IF(NN.EQ.1.AND.LL.EQ.2.AND.KK.EQ.3.AND.ITIM.EQ.0)ITIM3A=0
            IF(LLCNT.GT.1)THEN
              IF(NRN.LE.NAMODE)THEN
                NNEXT=JCONT(LCONT,NRN)
                IF(NN.EQ.NNEXT)NRN=NRN+1
              ELSE
                NNEXT=0
              END IF
            ELSE
              NNEXT=NN
            END IF
C**NEXT N
            N=NNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL AND THIS NN?
            IF(KK.NE.KNEXT.OR.LL.NE.LNEXT.OR.NN.NE.NNEXT)THEN
C**DUMMY READ IF MISSING MODES KK AND LL AND NN
              CALL GETINT(W(LMVB),KK,IK2)
              CALL GETINT(W(LMVB),LL,IL2)
              CALL GETINT(W(LMVB),NN,IN2)
              IF(JREACT.LE.0)
     2        THEN
                IF(IREACT.EQ.0)CALL DUMDD3(IK2,IL2,IN2,W(LV3),
     1          W(LV3),IXDIP)
              ELSE
C               CALL DUMVV3(KK,LL,NN,IK2,IL2,IN2,IK2TAU,W(LV3),W(LV3),
C    1          W(LC3),W(LC3),W(LEJK3),W(LEJK3),J21,W(LMODNT))
              END IF
              GO TO 333
            END IF

C**SKIP IF UNWANTED NN
            IF(NNEXT.EQ.0.OR.NN.NE.NNEXT)GO TO 333
            IF(JREACT.LE.0)THEN
C**GET BASIC INTEGRAL BASIS FOR THREE MODES
              CALL GETBP3(W(LIP3),ISIZE3,NSMODE,K,L,N,W(LMXBAS),NSIZE3,
     1        0)
              KXA3=NSIZE3*(NSIZE3+1)/2
              JCI1=MAXBFN(W(LMXBAS),NMODE,K,1)
              JCI2=MAXBFN(W(LMXBAS),NMODE,L,1)
              JCI3=MAXBFN(W(LMXBAS),NMODE,N,1)
              KTEMP=JCI2*JCI3*JCI2*JCI3
              CALL MEMO(2,LXA3,KXA3,LTEMP,KTEMP,0,0,0,0,0,0)
C**ZEROISE MATRIX
              CALL DIAGZ(NSIZE3,NSIZE3,W(LXA3),NSIZE3,W(LXA3),ICI)
              CALL GETINT(W(LMVB),N,IN2)
              CALL GETINT(W(LNVF),N,IN3)
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
              CALL GETBP2(W(LIP2),ISIZE2,NSMODE,L,N,W(LMXBAS),NSIZE2,0)
              CALL V0DP3(NAMODE,1,2,3,MAXCON,MAXPTS,W(LH+K2),W(LXQ+K3),
     1        W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),IK3,IK2,IL3,IL2,
     2        IN3,IN2,W(LXA3),NSIZE3,W(LIP3),ISIZE3,W(LTEMP),JCI1,JCI2,
     3        JCI3,W(LV3),W(LV3),W(LIP2),ISIZE2,NSIZE2,IXDIP,K,L,N,
     4        W(LMODNT))
              CALL MATOUT(W(LXA3),W(LXA3),NSIZE3,10*IXDIP+13)
              CALL MEMO(-2,LXA3,KXA3,LTEMP,KTEMP,0,0,0,0,0,0)
            ELSE
C*****************************   LIKE V0DP4 (K+L+N+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR FOUR MODES
              CALL GETBP4(W(LIP4),ISIZE4,NSMODE,K,L,N,NSMODE,W(LMXBAS),
     1        NSIZE4,0)

!              KXA4=NSIZE4*(NSIZE4+1)/2
              if (mod(nsize4,2) .eq. 0) then
                 kxa4 = nsize4 / 2
                 kxa4 = kxa4 * (nsize4 + 1)
              else
                 kxa4 = (nsize4 + 1) / 2
                 kxa4 = kxa4 * nsize4
              end if

              CALL GETINT(W(LMBF),N,IN2)
              CALL GETINT(W(LNVF),N,IN3)
              JCI1=MAXBFN(W(LMXBAS),NSMODE,K,1)
              JCI2=MAXBFN(W(LMXBAS),NSMODE,L,1)
              JCI3=MAXBFN(W(LMXBAS),NSMODE,N,1)
              JCIM=MAXBFN(W(LMXBAS),NSMODE,NSMODE,1)
              KTEMP1=JCI3*JCI3
              KXK0=JCI1*JCI1*IK2
              KXL0=JCI2*JCI2*IL2
              KXN0=JCI3*JCI3*IN2
              KXM0=JCIM*JCIM*IK2TAU
              CALL MEMO(3,LXA3,KXA4,LTEMP1,KTEMP1,LTEMP5,NSIZE4,0,0,0,0)
              CALL MEMO(4,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,LXM0,KXM0,0,0)
C**ZEROISE MATRIX
              CALL DIAGZ(NSIZE4,NSIZE4,W(LXA3),NSIZE4,W(LXA3),ICI)
C**GET ICOUNT2
              CALL V0DV3(NAMODE,1,2,3,4,MAXCON,MAXPTS,W(LH+K2),
     1        W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2        W(LH+K2TAU),W(LXQ+K3TAU),W(LXA3),NSIZE4,IK3,IK2,IL3,IL2,
     3        IN3,IN2,IK3TAU,IK2TAU,W(LIP4),ISIZE4,W(LTEMP1),W(LTEMP2),
     4        W(LTEMP3),JCI1,JCI2,JCI3,JCIM,W(LXK0),W(LXL0),W(LXN0),
     5        W(LXM0),W(LV3),W(LV3),KROTL,KROTR,IXDIP,NMODE,
     6        NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),
     7        NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,W(LMODNT),
     8        ICOUNT2,W(LTEMP),ICOUNT3,W(LTEMP4),W(LTEMP5),-1)
              KTEMP=ICOUNT2*2
              KTEMP2=ICOUNT2*ICOUNT2
              CALL MEMO(2,LTEMP,KTEMP,LTEMP2,KTEMP2,0,0,0,0,0,0)
C**GET ICOUNT3
              CALL V0DV3(NAMODE,1,2,3,4,MAXCON,MAXPTS,W(LH+K2),
     1        W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2        W(LH+K2TAU),W(LXQ+K3TAU),W(LXA3),NSIZE4,IK3,IK2,IL3,IL2,
     3        IN3,IN2,IK3TAU,IK2TAU,W(LIP4),ISIZE4,W(LTEMP1),W(LTEMP2),
     4        W(LTEMP3),JCI1,JCI2,JCI3,JCIM,W(LXK0),W(LXL0),W(LXN0),
     5        W(LXM0),W(LV3),W(LV3),KROTL,KROTR,IXDIP,NMODE,
     6        NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),
     7        NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,W(LMODNT),
     8        ICOUNT2,W(LTEMP),ICOUNT3,W(LTEMP4),W(LTEMP5),1)
              KTEMP4=ICOUNT3*2
              KTEMP3=ICOUNT3*ICOUNT3
              CALL MEMO(2,LTEMP3,KTEMP3,LTEMP4,KTEMP4,0,0,0,0,0,0)
C**GET XA3
              CALL V0DV3(NAMODE,1,2,3,4,MAXCON,MAXPTS,W(LH+K2),
     1        W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2        W(LH+K2TAU),W(LXQ+K3TAU),W(LXA3),NSIZE4,IK3,IK2,IL3,IL2,
     3        IN3,IN2,IK3TAU,IK2TAU,W(LIP4),ISIZE4,W(LTEMP1),W(LTEMP2),
     4        W(LTEMP3),JCI1,JCI2,JCI3,JCIM,W(LXK0),W(LXL0),W(LXN0),
     5        W(LXM0),W(LV3),W(LV3),KROTL,KROTR,IXDIP,NMODE,
     6        NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),
     7        NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,W(LMODNT),
     8        ICOUNT2,W(LTEMP),ICOUNT3,W(LTEMP4),W(LTEMP5),0)
              CALL MATOUT(W(LXA3),W(LXA3),NSIZE4,10*IXDIP+13)
              CALL MEMO(-2,LXA3,KXA4,LTEMP3,KTEMP3,0,0,0,0,0,0)
              CALL MEMO(-2,LTEMP1,KTEMP1,LTEMP2,KTEMP2,0,0,0,0,0,0)
              CALL MEMO(-3,LTEMP,KTEMP,LTEMP4,KTEMP4,LTEMP5,NSIZE4,
     1        0,0,0,0)
              CALL MEMO(-4,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,LXM0,KXM0,0,0)
C**
C*****************************   LIKE V0DP4 (K+L+N+NMODE)
            END IF
333   CONTINUE
            IF(ICOUPL.EQ.3)GO TO 3303
C**INTEGRATE OVER FOUR NORMAL COORDINATES
            M=0
            M2=0
            M3=0
            MRM=1
            DO MM=1,NN-1
              IF(MM.EQ.1.AND.NN.EQ.2.AND.LL.EQ.3.AND.KK.EQ.4.AND.
     1        ITIM.EQ.0)ITIM4A=0
              IF(LLCNT.GT.1)THEN
                IF(MRM.LE.NAMODE)THEN
                  MNEXT=JCONT(LCONT,MRM)
                  IF(MM.EQ.MNEXT)MRM=MRM+1
                ELSE
                  MNEXT=0
                END IF
              ELSE
                MNEXT=MM
              END IF
C**NEXT M
              M=MNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL AND THIS NN AND THIS MM?
              IF(KK.NE.KNEXT.OR.LL.NE.LNEXT.OR.NN.NE.NNEXT.OR.
     1        MM.NE.MNEXT)THEN
C**DUMMY READ IF MISSING MODES KK AND LL AND NN AND MM
                CALL GETINT(W(LMVB),KK,IK2)
                CALL GETINT(W(LMVB),LL,IL2)
                CALL GETINT(W(LMVB),NN,IN2)
                CALL GETINT(W(LMVB),MM,IM2)
                IF(JREACT.LE.0)
     2          THEN
                  IF(IREACT.EQ.0)CALL DUMDD4(IK2,IL2,IN2,
     1            IM2,W(LV4),W(LV4),IXDIP)
                ELSE
C                 CALL DUMVV4(KK,LL,NN,MM,IK2,IL2,IN2,IM2,IK2TAU,
C    1            W(LV4),W(LV4),W(LC4),W(LC4),W(LEJK4),W(LEJK4),J21,
C    2            W(LMODNT))
                END IF
                GO TO 334
              END IF

C**SKIP IF UNWANTED MM
              IF(MNEXT.EQ.0.OR.MM.NE.MNEXT)GO TO 334
              IF(JREACT.LE.0)THEN
C**GET BASIC INTEGRAL BASIS FOR FOUR MODES
                CALL GETBP4(W(LIP4),ISIZE4,NSMODE,K,L,N,M,W(LMXBAS),
     2          NSIZE4,0)

!                KXA4=NSIZE4*(NSIZE4+1)/2
                if (mod(nsize4,2) .eq. 0) then
                   kxa4 = nsize4 / 2
                   kxa4 = kxa4 * (nsize4 + 1)
                else
                   kxa4 = (nsize4 + 1) / 2
                   kxa4 = kxa4 * nsize4
                end if

                JCI1=MAXBFN(W(LMXBAS),NMODE,K,1)
                JCI2=MAXBFN(W(LMXBAS),NMODE,L,1)
                JCI3=MAXBFN(W(LMXBAS),NMODE,N,1)
                JCI4=MAXBFN(W(LMXBAS),NMODE,M,1)
                KTEMP=JCI2*JCI3*JCI4*JCI2*JCI3*JCI4
                CALL MEMO(2,LXA4,KXA4,LTEMP,KTEMP,0,0,0,0,0,0)
C**ZEROISE MATRIX
                CALL DIAGZ(NSIZE4,NSIZE4,W(LXA4),NSIZE4,W(LXA4),ICI)
                CALL GETINT(W(LMVB),M,IM2)
                CALL GETINT(W(LNVF),M,IM3)
C**GET BASIC INTEGRAL BASIS FOR THREE MODES
                CALL GETBP3(W(LIP3),ISIZE3,NSMODE,L,N,M,W(LMXBAS),
     1          NSIZE3,0)
                CALL V0DP4(NAMODE,1,2,3,4,MAXCON,MAXPTS,W(LH+K2),
     1          W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2          W(LH+M2),W(LXQ+M3),IK3,IK2,IL3,IL2,IN3,IN2,IM3,IM2,
     3          W(LXA4),NSIZE4,W(LIP4),ISIZE4,W(LTEMP),JCI1,JCI2,JCI3,
     4          JCI4,W(LV4),W(LV4),W(LIP3),ISIZE3,NSIZE3,IXDIP,K,L,N,M,
     5          W(LMODNT))
                CALL MATOUT(W(LXA4),W(LXA4),NSIZE4,10*IXDIP+14)
                CALL MEMO(-2,LXA4,KXA4,LTEMP,KTEMP,0,0,0,0,0,0)
              ELSE
C*****************************   LIKE V0DP5 (K+L+N+M+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR FIVE MODES
                CALL GETBP5(W(LIP5),ISIZE5,NSMODE,K,L,N,M,NSMODE,
     1          W(LMXBAS),NSIZE5,0)
                KXA5=NSIZE5*(NSIZE5+1)/2
                CALL GETINT(W(LMBF),M,IM2)
                CALL GETINT(W(LNVF),M,IM3)
                JCI1=MAXBFN(W(LMXBAS),NSMODE,K,1)
                JCI2=MAXBFN(W(LMXBAS),NSMODE,L,1)
                JCI3=MAXBFN(W(LMXBAS),NSMODE,N,1)
                JCI4=MAXBFN(W(LMXBAS),NSMODE,M,1)
                JCIM=MAXBFN(W(LMXBAS),NSMODE,NSMODE,1)
                KTEMP1=JCI4*JCI4
                KXK0=JCI1*JCI1*IK2
                KXL0=JCI2*JCI2*IL2
                KXN0=JCI3*JCI3*IN2
                KXP0=JCI4*JCI4*IM2
                KXM0=JCIM*JCIM*IK2TAU
                CALL MEMO(3,LXA4,KXA5,LTEMP1,KTEMP1,LTEMP7,NSIZE5,
     1          0,0,0,0)
                CALL MEMO(5,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,LXM0,KXM0,
     1          LXP0,KXP0)
C**ZEROISE MATRIX
                CALL DIAGZ(NSIZE5,NSIZE5,W(LXA4),NSIZE5,W(LXA4),ICI)
C**GET ICOUNT2
                CALL V0DV4(NAMODE,1,2,3,4,5,MAXCON,MAXPTS,W(LH+K2),
     1          W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2          W(LH+M2),W(LXQ+M3),W(LH+K2TAU),W(LXQ+K3TAU),W(LXA4),
     3          NSIZE5,IK3,IK2,IL3,IL2,IN3,IN2,IM3,IM2,IK3TAU,IK2TAU,
     4          W(LIP5),ISIZE5,W(LTEMP1),W(LTEMP2),W(LTEMP3),W(LTEMP4),
     5          JCI1,JCI2,JCI3,JCI4,JCIM,W(LXK0),W(LXL0),W(LXN0),
     6          W(LXM0),W(LXP0),W(LV4),W(LV4),KROTL,KROTR,IXDIP,NMODE,
     7          NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),
     8          W(LJPOT),W(LCPOT),K,L,N,M,W(LMODNT),ICOUNT2,W(LTEMP),
     9          ICOUNT3,W(LTEMP5),ICOUNT4,W(LTEMP6),W(LTEMP7),-2)
                KTEMP=ICOUNT2*2
                KTEMP2=ICOUNT2*ICOUNT2
                CALL MEMO(2,LTEMP,KTEMP,LTEMP2,KTEMP2,0,0,0,0,0,0)
C**GET ICOUNT3
                CALL V0DV4(NAMODE,1,2,3,4,5,MAXCON,MAXPTS,W(LH+K2),
     1          W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2          W(LH+M2),W(LXQ+M3),W(LH+K2TAU),W(LXQ+K3TAU),W(LXA4),
     3          NSIZE5,IK3,IK2,IL3,IL2,IN3,IN2,IM3,IM2,IK3TAU,IK2TAU,
     4          W(LIP5),ISIZE5,W(LTEMP1),W(LTEMP2),W(LTEMP3),W(LTEMP4),
     5          JCI1,JCI2,JCI3,JCI4,JCIM,W(LXK0),W(LXL0),W(LXN0),
     6          W(LXM0),W(LXP0),W(LV4),W(LV4),KROTL,KROTR,IXDIP,NMODE,
     7          NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),
     8          W(LJPOT),W(LCPOT),K,L,N,M,W(LMODNT),ICOUNT2,W(LTEMP),
     9          ICOUNT3,W(LTEMP5),ICOUNT4,W(LTEMP6),W(LTEMP7),-1)
                KTEMP5=ICOUNT3*2
                KTEMP3=ICOUNT3*ICOUNT3
                CALL MEMO(2,LTEMP3,KTEMP3,LTEMP5,KTEMP5,0,0,0,0,0,0)
C**GET ICOUNT4
                CALL V0DV4(NAMODE,1,2,3,4,5,MAXCON,MAXPTS,W(LH+K2),
     1          W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2          W(LH+M2),W(LXQ+M3),W(LH+K2TAU),W(LXQ+K3TAU),W(LXA4),
     3          NSIZE5,IK3,IK2,IL3,IL2,IN3,IN2,IM3,IM2,IK3TAU,IK2TAU,
     4          W(LIP5),ISIZE5,W(LTEMP1),W(LTEMP2),W(LTEMP3),W(LTEMP4),
     5          JCI1,JCI2,JCI3,JCI4,JCIM,W(LXK0),W(LXL0),W(LXN0),
     6          W(LXM0),W(LXP0),W(LV4),W(LV4),KROTL,KROTR,IXDIP,NMODE,
     7          NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),
     8          W(LJPOT),W(LCPOT),K,L,N,M,W(LMODNT),ICOUNT2,W(LTEMP),
     9          ICOUNT3,W(LTEMP5),ICOUNT4,W(LTEMP6),W(LTEMP7),1)
                KTEMP6=ICOUNT4*2
                KTEMP4=ICOUNT4*ICOUNT4
                CALL MEMO(2,LTEMP4,KTEMP4,LTEMP6,KTEMP6,0,0,0,0,0,0)
C**GET XA4
                CALL V0DV4(NAMODE,1,2,3,4,5,MAXCON,MAXPTS,W(LH+K2),
     1          W(LXQ+K3),W(LH+L2),W(LXQ+L3),W(LH+N2),W(LXQ+N3),
     2          W(LH+M2),W(LXQ+M3),W(LH+K2TAU),W(LXQ+K3TAU),W(LXA4),
     3          NSIZE5,IK3,IK2,IL3,IL2,IN3,IN2,IM3,IM2,IK3TAU,IK2TAU,
     4          W(LIP5),ISIZE5,W(LTEMP1),W(LTEMP2),W(LTEMP3),W(LTEMP4),
     5          JCI1,JCI2,JCI3,JCI4,JCIM,W(LXK0),W(LXL0),W(LXN0),
     6          W(LXM0),W(LXP0),W(LV4),W(LV4),KROTL,KROTR,IXDIP,NMODE,
     7          NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),NPOT,W(LIPOT),
     8          W(LJPOT),W(LCPOT),K,L,N,M,W(LMODNT),ICOUNT2,W(LTEMP),
     9          ICOUNT3,W(LTEMP5),ICOUNT4,W(LTEMP6),W(LTEMP7),0)
                CALL MATOUT(W(LXA4),W(LXA4),NSIZE5,10*IXDIP+14)
                CALL MEMO(-3,LXA4,KXA5,LTEMP1,KTEMP1,LTEMP7,NSIZE5,
     1          0,0,0,0)
                CALL MEMO(-2,LTEMP,KTEMP,LTEMP2,KTEMP2,0,0,0,0,0,0)
                CALL MEMO(-2,LTEMP3,KTEMP3,LTEMP5,KTEMP5,0,0,0,0,0,0)
                CALL MEMO(-2,LTEMP4,KTEMP4,LTEMP6,KTEMP6,0,0,0,0,0,0)
                CALL MEMO(-5,LXK0,KXK0,LXL0,KXL0,LXN0,KXN0,LXM0,KXM0,
     1          LXP0,KXP0)
C**
C*****************************   LIKE V0DP5 (K+L+N+M+NMODE)
              END IF
334   CONTINUE
              IF(ICOUPL.EQ.4)GO TO 3304
C**5-MODE COUPLING HERE IF NEEDED
C**RPH ODD K
3304  CONTINUE
              M2=M2+3*MAXCON*MAXPTS*ILLPP
              M3=M3+MAXPTS
            END DO
3303  CONTINUE
            N2=N2+3*MAXCON*MAXPTS*ILLPP
            N3=N3+MAXPTS
          END DO
3302  CONTINUE
          L2=L2+3*MAXCON*MAXPTS*ILLPP
          L3=L3+MAXPTS
        END DO
3301  CONTINUE
        K2=K2+3*MAXCON*MAXPTS*ILLPP
        K3=K3+MAXPTS
      END DO
3300  CONTINUE
C**RPH ODD K
      IF(MOD(IDIP,3).EQ.0.AND.LDUMP.NE.8)ISUBTR=ISUBTR+3
33000 CONTINUE
      ITIM=-1
C**********************************************************************
C**********************************************************************
C**                                                SET UP DIPOLE MATRIX
C**********************************************************************
C**********************************************************************
      ISIZMX=MAXCI
C****************************
C**LOOP OVER SYMMETRIES (RHS)
C****************************
      IF(LDUMP.EQ.6)REWIND 58
      IF(LDUMP.EQ.7.OR.LDUMP.EQ.8)THEN
C**TEMPORARY STORAGE 151(x), 152(y), 153(z) - LDUMP=7
C**TEMPORARY STORAGE 151(20), 152(21+), 153(21-) - LDUMP=8
        REWIND 151
        REWIND 152
        REWIND 153
      END IF
      IF(LDUMP.EQ.8)THEN
C**TEMPORARY STORAGE 154(22+), 155(22-)
        REWIND 154
        REWIND 155
      END IF
      ISZMAX=0
      DO 4400 MSR=1,NVSYM
      ITIM=ITIM+1
      ISIZER=NFTOT(MSR,1)
C**MSR IS STORED SYMMETRY
      IF(ISIZER.GT.ISZMAX)ISZMAX=ISIZER
      IF(ISIZER.EQ.0)GO TO 4401
      IF(LDUMP.EQ.6)CALL RDVCI(W(LVCI),MAXCI,MAXDMP,MAXSYM,W(LNDUMP),
     1MSR,ISIZER,1)
C****************************
C**LOOP OVER SYMMETRIES (LHS)
C****************************
      IF2=1
      IF(LDUMP.EQ.6)THEN
        IF2=2
        REWIND 59
      END IF
      MMSR=MSR
      IF(ISET.NE.0)MMSR=NVSYM
      IF(LDUMP.EQ.7.OR.LDUMP.EQ.8)MMSR=NVSYM
      DO 4402 MSL=1,MMSR
      ISIZEL=NFTOT(MSL,IF2)
C**MSL IS STORED SYMMETRY
      IF(ISIZEL.EQ.0.OR.(LDUMP.EQ.1.AND.JJDUMP(MSL).EQ.0))GO TO 4403
      IF(LDUMP.EQ.6)CALL RDVCI(W(LVCI),MAXCI,MAXDMP,MAXSYM,
     1W(LNDUMP+NVSYM),MSL,ISIZEL,2)
      IF(MSL.NE.MSR.AND.(LDUMP.EQ.2.OR.LDUMP.EQ.3.OR.LDUMP.EQ.5.OR.
     1LDUMP.EQ.6))GO TO 4403
      KXA=ISIZER
      KTEMP=ISIZEL*MAXDMP
      CALL MEMO(2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
      IF(IREACT.GT.0)THEN
        REWIND 20
        REWIND 30
        REWIND 40
        IF(LDUMP.EQ.8)THEN
          REWIND 50
          REWIND 60
        END IF
      END IF
      IF(ICOUPL.GE.0)THEN
        REWIND 21
        REWIND 31
        REWIND 41
        IF(LDUMP.EQ.8)THEN
          REWIND 51
          REWIND 61
        END IF
      END IF
      IF(ICOUPL.GT.1)THEN
        REWIND 22
        REWIND 32
        REWIND 42
        IF(LDUMP.EQ.8)THEN
          REWIND 52
          REWIND 62
        END IF
      END IF
      IF(ICOUPL.GT.2)THEN
        REWIND 23
        REWIND 33
        REWIND 43
        IF(LDUMP.EQ.8)THEN
          REWIND 53
          REWIND 63
        END IF
      END IF
      IF(ICOUPL.GT.3)THEN
        REWIND 24
        REWIND 34
        REWIND 44
        IF(LDUMP.EQ.8)THEN
          REWIND 54
          REWIND 64
        END IF
      END IF
C**RPH ODD K
      KLOOP=1
      IF(JREACT.GT.0.AND.(LDUMP.EQ.7.OR.LDUMP.EQ.8))KLOOP=IFLAUD
C**KLOOP=1 - COS,SIN(M.TAU)
C**KLOOP=2 - SIN,COS(M.TAU/2)
      DO 9000 KROTR=1,KLOOP
      KAR=KROTR/2
      MSRR=MSR
      IF(MOD(KAR,2).NE.0)MSRR=ISYMP(MSR,ISYMT)
C**MSRR IS ACTUAL SYMMETRY
      DO 9000 KROTL=1,KLOOP
      KAL=KROTL/2
      MSLL=MSL
      IF(MOD(KAL,2).NE.0)MSLL=ISYMP(MSL,ISYMT)
C**MSLL IS ACTUAL SYMMETRY
C**RPH ODD K
      ISUBTR=0
C****************************
C**X,Y,Z COMPONENTS OF DIPOLE
C****************************
C**TRIATOMICS ALWAYS ONLY HAVE Y,Z COMPONENTS
      NUMST=1
      IF(TRIAT)NUMST=2
      DO 9000 JDIP=NUMST,NUMDIP
C**RELATE TO SYMMETRY AXES
      IDIP=MXDIP(JDIP)
      IXDIP=JDIP-ISUBTR
C*****************************************************************
C*****************************************************************
C**NEEDS SELECTION CRITERION HERE FOR SYMMETRY-ALLOWED DIPOLES
C*****************************************************************
C*****************************************************************
      ISKIP=0
      IF(LDUMP.EQ.1.OR.LDUMP.EQ.7.OR.LDUMP.EQ.8)THEN
        IF(.NOT.TRIAT)THEN
CCCC      ICROSS=ISYMP(MSL,MSR)
          ICROSS=ISYMP(MSLL,MSRR)
C         IF(ISYMP(ICROSS,IDIP).NE.1)GO TO 9001
          IF(ISYMP(ICROSS,IDIP).NE.1)ISKIP=1
        ELSE
C***************************
C**REDUNDANT CODE
C***************************
C
C**TEST IF C2V
          IF(NVSYM.EQ.4.OR.(NVSYM.EQ.2.AND.TRIAT))THEN
C**A1 COMPONENT
            IF(IDIP.EQ.1)THEN
              IF(MSL.NE.MSR)GO TO 9001
            END IF
C**B2 COMPONENT
            IF(IDIP.EQ.2)THEN
              IF(MSR.EQ.3.AND.MSL.EQ.2)GO TO 9001
              IF(MSR.EQ.2.AND.MSL.EQ.3)GO TO 9001
              IF(MSL.NE.MSR-1.AND.MSR.NE.MSL-1)GO TO 9001
            END IF
C**B1 COMPONENT
            IF(IDIP.EQ.3)THEN
              IF(MSL.NE.MSR-2.AND.MSR.NE.MSL-2)GO TO 9001
            END IF
          END IF
C**TEST IF CS (OR C2)
          IF((NVSYM.EQ.2.AND..NOT.TRIAT).OR.
     1       (NVSYM.EQ.1.AND.TRIAT))THEN
C**A' COMPONENTS
            IF(IDIP.EQ.1.OR.IDIP.EQ.2)THEN
              IF(MSL.NE.MSR)GO TO 9001
            END IF
C**A" COMPONENTS
            IF(IDIP.EQ.3)THEN
              IF(MSL.EQ.MSR)GO TO 9001
            END IF
          END IF
        END IF
C
      END IF
C**ZEROISE MATRIX
      REWIND 96
      REWIND 97
      INDW=96
      INDR=97
      IF(ISKIP.EQ.0)
     1CALL DIAGF(ISIZER,1,W(LXA),ILOOP)
C**GET TORSION-ONLY INTEGRALS IF RPH
      IF(JREACT.GT.0)THEN
C****************************************  LIKE VDP1 (NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR SINGLE MODE
        CALL GETBP1(W(LIP1),ISIZE1,NSMODE,NSMODE,W(LMXBAS),NSIZE1,0)
        KXA1=NSIZE1*(NSIZE1+1)/2
        CALL MEMO(1,LXA0,KXA1,0,0,0,0,0,0,0,0)
C**READ INTO MATRIX
        CALL MATIN(W(LXA0),W(LXA0),NSIZE1,10*IXDIP+10)
C       IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1  CALL VDV0(NNMODE,W(LXA),W(LXA0),NSIZE1,W(LIP),ISIZMX,ISIZEL,
        IF(ISKIP.EQ.0)
     1  CALL VDV0(NNMODE,W(LXA),W(LXA0),NSIZE1,W(LIP),ISIZMX,ISIZEL,
     2  ISIZER,MSL,MSR,W(LIP1),ISIZE1)
        CALL MEMO(-1,LXA0,KXA1,0,0,0,0,0,0,0,0)
C**
C****************************************  LIKE VDP1 (NMODE)
      END IF
C     IF(JREACT.LE.0.AND.ISYMP(ICROSS,IDIP).EQ.1)
      IF(JREACT.LE.0.AND.ISKIP.EQ.0)
     1CALL VDP0(NNMODE,W(LXA),ISIZEL,ISIZER,JDIP,MSL,MSR,LDUMP)
      IF(ICOUPL.EQ.0)GO TO 700
C**INTEGRATE OVER SINGLE NORMAL COORDINATE
      K=0
      K2=0
      K3=0
      KRK=1
      DO KK=1,NAMODS
        IF(KK.EQ.1.AND.ITIM.EQ.0)ITIM1A=0
        IF(LLCNT.GT.1)THEN
          IF(KRK.LE.NAMODE)THEN
            KNEXT=JCONT(LCONT,KRK)
            IF(KK.EQ.KNEXT)KRK=KRK+1
            KTHIS=KRK-1
          ELSE
            KNEXT=0
          END IF
        ELSE
          KNEXT=KK
          KTHIS=KK
        END IF
C**NEXT K
        K=KNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK?
        IF(KK.NE.KNEXT)THEN
          GO TO 71
        END IF

C**SKIP IF UNWANTED KK
        IF(KNEXT.EQ.0.OR.KK.NE.KNEXT)GO TO 71
        IF(JREACT.LE.0)THEN
          IF(LDUMP.EQ.6)THEN
            CALL GETBP1(W(LIP1),ISIZE1,NSMODE,K,MAXBAS,NSIZER,0)
            CALL GETBP1(W(LIP1+ISIZE1),ISIZE1,NSMODE,K,
     1      MAXBAS(1,1,2),NSIZEL,0)
C**READ INTO MATRIX
            KXA1=NSIZEL*NSIZER
            CALL MEMO(1,LXA1,KXA1,0,0,0,0,0,0,0,0)
            CALL FATIN(W(LXA1),W(LXA1),NSIZEL,NSIZER,10*IXDIP+11)
            CALL VFP1(NNMODE,K,NAMODE,W(LXA),W(LXA1),NSIZEL,NSIZER,
     1      W(LIP),ISIZMX,NVSYM,ISIZEL,ISIZER,MSL,MSR,W(LIP1),ISIZE1)
            CALL MEMO(-1,LXA1,KXA1,0,0,0,0,0,0,0,0)
          ELSE
            CALL GETINT(W(LMVB),K,IK2)
            CALL GETINT(W(LNVF),K,IK3)
            CALL GETBP1(W(LIP1),ISIZE1,NSMODE,K,W(LMXBAS),NSIZE1,0)
C**READ INTO MATRIX
            KXA1=NSIZE1*(NSIZE1+1)/2
            CALL MEMO(1,LXA1,KXA1,0,0,0,0,0,0,0,0)
            CALL MATIN(W(LXA1),W(LXA1),NSIZE1,10*IXDIP+11)
C           IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1      CALL VDP1(NNMODE,KTHIS,NAMODE,W(LXA),W(LXA1),NSIZE1,IK3,
            IF(ISKIP.EQ.0)
     1      CALL VDP1(NNMODE,KTHIS,NAMODE,W(LXA),W(LXA1),NSIZE1,IK3,
     2      IK2,W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP1),ISIZE1)
            CALL MEMO(-1,LXA1,KXA1,0,0,0,0,0,0,0,0)
          END IF
        ELSE
C****************************************  LIKE VDP2 (K+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
          CALL GETBP2(W(LIP2),ISIZE2,NSMODE,K,NSMODE,W(LMXBAS),NSIZE2,
     1    0)
C**READ INTO MATRIX
          KXA2=NSIZE2*(NSIZE2+1)/2
          CALL MEMO(1,LXA1,KXA2,0,0,0,0,0,0,0,0)
          CALL MATIN(W(LXA1),W(LXA1),NSIZE2,10*IXDIP+11)
C         IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1    CALL VDV1(NNMODE,K,NAMODE,W(LXA),W(LXA1),NSIZE2,W(LIP),ISIZMX,
          IF(ISKIP.EQ.0)
     1    CALL VDV1(NNMODE,K,NAMODE,W(LXA),W(LXA1),NSIZE2,W(LIP),ISIZMX,
     2    ISIZEL,ISIZER,MSL,MSR,W(LIP2),ISIZE2)
          CALL MEMO(-1,LXA1,KXA2,0,0,0,0,0,0,0,0)
C**
C****************************************  LIKE VDP2 (K+NMODE)
        END IF
71    CONTINUE
        IF(ICOUPL.EQ.1)GO TO 701
C**INTEGRATE OVER TWO NORMAL COORDINATES
        L=0
        L2=0
        L3=0
        LRL=1
        DO LL=1,KK-1
          IF(LL.EQ.1.AND.KK.EQ.2.AND.ITIM.EQ.0)ITIM2A=0
          IF(LLCNT.GT.1)THEN
            IF(LRL.LE.NAMODE)THEN
              LNEXT=JCONT(LCONT,LRL)
              IF(LL.EQ.LNEXT)LRL=LRL+1
              LTHIS=LRL-1
            ELSE
              LNEXT=0
            END IF
          ELSE
            LNEXT=LL
            LTHIS=LL
          END IF
C**NEXT L
          L=LNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL?
          IF(KK.NE.KNEXT.OR.LL.NE.LNEXT)THEN
            GO TO 72
          END IF

C**SKIP IF UNWANTED LL
          IF(LNEXT.EQ.0.OR.LL.NE.LNEXT)GO TO 72
          IF(JREACT.LE.0)THEN
            CALL GETINT(W(LMVB),L,IL2)
            CALL GETINT(W(LNVF),L,IL3)
            CALL GETBP2(W(LIP2),ISIZE2,NSMODE,K,L,W(LMXBAS),NSIZE2,0)
C**READ INTO MATRIX
            KXA2=NSIZE2*(NSIZE2+1)/2
            CALL MEMO(1,LXA2,KXA2,0,0,0,0,0,0,0,0)
            CALL MATIN(W(LXA2),W(LXA2),NSIZE2,10*IXDIP+12)
C**TEMPORARY
C           IF(ISYMP(ICROSS,IDIP).EQ.1)
CC   1      CALL VDP2(NNMODE,KTHIS,LTHIS,NAMODE,W(LXA),W(LXA2),
CC   2      NSIZE2,W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP2),ISIZE2)
C    1      CALL VDP2(NNMODE,KTHIS,LTHIS,NAMODE,W(LXA),W(LXA2),IDIP,
            IF(ISKIP.EQ.0)
     1      CALL VDP2(NNMODE,KTHIS,LTHIS,NAMODE,W(LXA),W(LXA2),IDIP,
     2      JDIP,NSIZE2,W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP2),
     3      ISIZE2)
C**TEMPORARY
            CALL MEMO(-1,LXA2,KXA2,0,0,0,0,0,0,0,0)
          ELSE
C****************************************  LIKE VDP3 (K+L+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
            CALL GETBP3(W(LIP3),ISIZE3,NSMODE,K,L,NSMODE,W(LMXBAS),
     1      NSIZE3,0)
C**READ INTO MATRIX
            KXA3=NSIZE3*(NSIZE3+1)/2
            CALL MEMO(1,LXA2,KXA3,0,0,0,0,0,0,0,0)
            CALL MATIN(W(LXA2),W(LXA2),NSIZE3,10*IXDIP+12)
C           IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1      CALL VDV2(NNMODE,K,L,NAMODE,W(LXA),W(LXA2),NSIZE3,W(LIP),
            IF(ISKIP.EQ.0)
     1      CALL VDV2(NNMODE,K,L,NAMODE,W(LXA),W(LXA2),NSIZE3,W(LIP),
     2      ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP3),ISIZE3)
            CALL MEMO(-1,LXA2,KXA3,0,0,0,0,0,0,0,0)
C**
C****************************************  LIKE VDP3 (K+L+NMODE)
          END IF
72    CONTINUE
          IF(ICOUPL.EQ.2)GO TO 702
C**INTEGRATE OVER THREE NORMAL COORDINATES
          N=0
          N2=0
          N3=0
          NRN=1
          DO NN=1,LL-1
            IF(NN.EQ.1.AND.LL.EQ.2.AND.KK.EQ.3.AND.ITIM.EQ.0)ITIM3A=0
            IF(LLCNT.GT.1)THEN
              IF(NRN.LE.NAMODE)THEN
                NNEXT=JCONT(LCONT,NRN)
                IF(NN.EQ.NNEXT)NRN=NRN+1
                NTHIS=NRN-1
              ELSE
                NNEXT=0
              END IF
            ELSE
              NNEXT=NN
              NTHIS=NN
            END IF
C**NEXT N
            N=NNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL AND THIS NN?
            IF(KK.NE.KNEXT.OR.LL.NE.LNEXT.OR.NN.NE.NNEXT)THEN
              GO TO 73
            END IF

C**SKIP IF UNWANTED NN
            IF(NNEXT.EQ.0.OR.NN.NE.NNEXT)GO TO 73
            IF(JREACT.LE.0)THEN
              CALL GETINT(W(LMVB),N,IN2)
              CALL GETINT(W(LNVF),N,IN3)
              CALL GETBP3(W(LIP3),ISIZE3,NSMODE,K,L,N,W(LMXBAS),NSIZE3,
     1        0)
C**READ INTO MATRIX
              KXA3=NSIZE3*(NSIZE3+1)/2
              CALL MEMO(1,LXA3,KXA3,0,0,0,0,0,0,0,0)
              CALL MATIN(W(LXA3),W(LXA3),NSIZE3,10*IXDIP+13)
C             IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1        CALL VDP3(NNMODE,KTHIS,LTHIS,NTHIS,NAMODE,W(LXA),
              IF(ISKIP.EQ.0)
     1        CALL VDP3(NNMODE,KTHIS,LTHIS,NTHIS,NAMODE,W(LXA),
     2        W(LXA3),NSIZE3,W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,
     3        W(LIP3),ISIZE3)
              CALL MEMO(-1,LXA3,KXA3,0,0,0,0,0,0,0,0)
            ELSE
C****************************************  LIKE VDP4 (K+L+N+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
              CALL GETBP4(W(LIP4),ISIZE4,NSMODE,K,L,N,NSMODE,W(LMXBAS),
     1        NSIZE4,0)
C**READ INTO MATRIX

!              KXA4=NSIZE4*(NSIZE4+1)/2
              if (mod(nsize4,2) .eq. 0) then
                 kxa4 = nsize4 / 2
                 kxa4 = kxa4 * (nsize4 + 1)
              else
                 kxa4 = (nsize4 + 1) / 2
                 kxa4 = kxa4 * nsize4
              end if

              CALL MEMO(1,LXA3,KXA4,0,0,0,0,0,0,0,0)
              CALL MATIN(W(LXA3),W(LXA3),NSIZE4,10*IXDIP+13)
C             IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1        CALL VDV3(NNMODE,K,L,N,NAMODE,W(LXA),W(LXA3),NSIZE4,
              IF(ISKIP.EQ.0)
     1        CALL VDV3(NNMODE,K,L,N,NAMODE,W(LXA),W(LXA3),NSIZE4,
     2        W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP4),ISIZE4)
              CALL MEMO(-1,LXA3,KXA4,0,0,0,0,0,0,0,0)
C**
C****************************************  LIKE VDP4 (K+L+N+NMODE)
            END IF
73    CONTINUE
            IF(ICOUPL.EQ.3)GO TO 703
C**INTEGRATE OVER FOUR NORMAL COORDINATES
            M=0
            M2=0
            M3=0
            MRM=1
            DO MM=1,NN-1
              IF(MM.EQ.1.AND.NN.EQ.2.AND.LL.EQ.3.AND.KK.EQ.4.AND.
     1        ITIM.EQ.0)ITIM4A=0
              IF(LLCNT.GT.1)THEN
                IF(MRM.LE.NAMODE)THEN
                  MNEXT=JCONT(LCONT,MRM)
                  IF(MM.EQ.MNEXT)MRM=MRM+1
                  MTHIS=MRM-1
                ELSE
                  MNEXT=0
                END IF
              ELSE
                MNEXT=MM
                MTHIS=MM
              END IF
C**NEXT M
              M=MNEXT

C**INTRINSIC ?

C**DO WE WANT THIS KK AND THIS LL AND THIS NN AND THIS MM?
              IF(KK.NE.KNEXT.OR.LL.NE.LNEXT.OR.NN.NE.NNEXT.OR.
     1        MM.NE.MNEXT)THEN
                GO TO 74
              END IF

C**SKIP IF UNWANTED MM
              IF(MNEXT.EQ.0.OR.MM.NE.MNEXT)GO TO 74
              IF(JREACT.LE.0)THEN
                CALL GETINT(W(LMVB),M,IM2)
                CALL GETINT(W(LNVF),M,IM3)
                CALL GETBP4(W(LIP4),ISIZE4,NSMODE,K,L,N,M,W(LMXBAS),
     2          NSIZE4,0)
C**READ INTO MATRIX

!                KXA4=NSIZE4*(NSIZE4+1)/2
                if (mod(nsize4,2) .eq. 0) then
                   kxa4 = nsize4 / 2
                   kxa4 = kxa4 * (nsize4 + 1)
                else
                   kxa4 = (nsize4 + 1) / 2
                   kxa4 = kxa4 * nsize4
                end if

                CALL MEMO(1,LXA4,KXA4,0,0,0,0,0,0,0,0)
                CALL MATIN(W(LXA4),W(LXA4),NSIZE4,10*IXDIP+14)
C               IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1          CALL VDP4(NNMODE,KTHIS,LTHIS,NTHIS,MTHIS,
                IF(ISKIP.EQ.0)
     1          CALL VDP4(NNMODE,KTHIS,LTHIS,NTHIS,MTHIS,
     2          NAMODE,W(LXA),W(LXA4),NSIZE4,W(LIP),ISIZMX,ISIZEL,
     3          ISIZER,MSL,MSR,W(LIP4),ISIZE4)
                CALL MEMO(-1,LXA4,KXA4,0,0,0,0,0,0,0,0)
              ELSE
C****************************************  LIKE VDP5 (K+L+N+M+NMODE)
C**
C**GET BASIC INTEGRAL BASIS FOR TWO MODES
              CALL GETBP5(W(LIP5),ISIZE5,NSMODE,K,L,N,M,NSMODE,
     1        W(LMXBAS),NSIZE5,0)
C**READ INTO MATRIX
              KXA5=NSIZE5*(NSIZE5+1)/2
              CALL MEMO(1,LXA4,KXA5,0,0,0,0,0,0,0,0)
              CALL MATIN(W(LXA4),W(LXA4),NSIZE5,10*IXDIP+14)
C             IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1        CALL VDV4(NNMODE,K,L,N,M,NAMODE,W(LXA),W(LXA4),NSIZE5,
              IF(ISKIP.EQ.0)
     1        CALL VDV4(NNMODE,K,L,N,M,NAMODE,W(LXA),W(LXA4),NSIZE5,
     2        W(LIP),ISIZMX,ISIZEL,ISIZER,MSL,MSR,W(LIP5),ISIZE5)
              CALL MEMO(-1,LXA4,KXA5,0,0,0,0,0,0,0,0)
C**
C****************************************  LIKE VDP5 (K+L+N+M+NMODE)

              END IF
74    CONTINUE
              IF(ICOUPL.EQ.4)GO TO 704
C**5-MODE COUPLING HERE IF NEEDED
704   CONTINUE
              M2=M2+3*MAXCON*MAXPTS
              M3=M3+MAXPTS
            END DO
703   CONTINUE
            N2=N2+3*MAXCON*MAXPTS
            N3=N3+MAXPTS
          END DO
702   CONTINUE
          L2=L2+3*MAXCON*MAXPTS
          L3=L3+MAXPTS
        END DO
701   CONTINUE
        K2=K2+3*MAXCON*MAXPTS
        K3=K3+MAXPTS
      END DO
700   CONTINUE
C**********************************************************************
C**                                                     MATRIX COMPLETE
C**********************************************************************
      IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)THEN
        IF(.NOT.TRIAT)THEN
CCCC      ICROSS=ISYMP(MSL,MSR)
C         ICROSS=ISYMP(MSLL,MSRR)
C         IF(ISYMP(ICROSS,IDIP).NE.1)GO TO 9001
          IF(ISKIP.NE.0)GO TO 9001
        END IF
      END IF
      REWIND 96
      WRITE(IOUT,*)
      IDIML=ISIZER
      IDIMR=1
      IF(LDUMP.NE.7.AND.LDUMP.NE.8)THEN
        CALL DIPTOT(W(LNDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,W(LVCI),MAXCI,
     1  W(LXA),IDIML,IDIMR,ISIZEL,ISIZER,MSL,MSR,W(LTEMP),W(LEVAL),
     2  IDIP,JDIP,LDUMP,ILOOP,96)
      ELSE
C**TRANSFER 96 TO 151(x), 152(y), 153(z) - LDUMP=7
C**TRANSFER 96 TO 151(20), 152(21+), 153(21-), 154(22+), 155(22-) - LDUMP=8
        CALL OUTDIP(W(LXA),ISIZER,ISIZEL,JDIP,150,96,LDUMP)
C       IF(ISYMP(ICROSS,IDIP).EQ.1)
C    1  CALL OUTDIP(W(LXA),ISIZER,ISIZEL,JDIP,150,96,LDUMP)
      END IF
9001  CONTINUE
      IF(MOD(JDIP,3).EQ.0.AND.LDUMP.NE.8)ISUBTR=ISUBTR+3
9000  CONTINUE
      CALL MEMO(-2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
4403  CONTINUE
4402  CONTINUE
4401  CONTINUE
4400  CONTINUE
4444  CONTINUE
      IF(LDUMP.GE.7)THEN
        KXA=ISZMAX
        KTEMP=ISZMAX*MAXDMP
C**GET FACTORIALS (BASE IT ON MAXIMUM 2*J)
        J2MAX=2*JMAX
        CALL MEMO(1,LWRK,J2MAX+3,0,0,0,0,0,0,0,0)
        CALL FACDIP(W(LWRK),J2MAX+3)
C**J -> J
        WRITE(IOUT,*)
        WRITE(IOUT,*)' VIBRATIONAL DIPOLE SECTION FOR J -> J'
        WRITE(IOUT,*)' J = ',JCURR,' -> J = ',JCURR
        WRITE(IOUT,*)
        REWIND 151
        REWIND 152
        REWIND 153
        REWIND 154
        REWIND 155
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        IF(LDUMP.LT.9)THEN
        CALL MEMO(2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        CALL MEMO(1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL TRANVB(W(LNDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,W(LVCI),
     1  MAXCI,W(LXA),ISZMAX,1,W(LTEMP),W(LTEMP1),W(LEVAL),ILOOP,
     2  JSTORE,J21MAX,JCURR,2,JCURR,2,150,50)
        CALL MEMO(-1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL MEMO(-2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        END IF
        WRITE(IOUT,*)
        WRITE(IOUT,*)' ROTATIONAL SECTION FOR J -> J'
        WRITE(IOUT,*)' J = ',JCURR,' -> J = ',JCURR
        WRITE(IOUT,*)
C**GET STORAGE FOR 3-J SYMBOLS
        KSSR=2*JCURR+1
        KSSL=2*JCURR+1
        KSSX=MAX0(KSSL,KSSR)
        CALL MEMO(1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
C**3-J SYMBOLS WILL BE IN THE SAME ORDERING AS SPIN-ROTATION FUNCTIONS
        CALL S3JDIP(W(LDDPM),KSSL,KSSR,JCURR,JCURR,VAL,W(LWRK),
     1  J2MAX+3,KSSX)
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        CALL TRANRT(W,W(LNDUMP),W(LIDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,
     1  W(LRCI),NRSYM,MAXRT,W(LXA),ISZMAX,ISZMAX,W(LTEMP),W(LRVAL),
     2  ILOOP,JSTORE,J21MAX,JCURR,2,JCURR,2,W(LWRK),W(LDDPM),KSSX,50,
     3  NMODE)
        CALL MEMO(-1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
C**J-1 -> J
        WRITE(IOUT,*)
        WRITE(IOUT,*)' VIBRATIONAL DIPOLE SECTION FOR J-1 -> J'
        WRITE(IOUT,*)' J = ',JPREV,' -> J = ',JCURR
        WRITE(IOUT,*)
        REWIND 151
        REWIND 152
        REWIND 153
        REWIND 154
        REWIND 155
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        IF(LDUMP.LT.9)THEN
        CALL MEMO(2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        CALL MEMO(1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL TRANVB(W(LNDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,W(LVCI),
     1  MAXCI,W(LXA),ISZMAX,1,W(LTEMP),W(LTEMP1),W(LEVAL),ILOOP,
     2  JSTORE,J21MAX,JPREV,1,JCURR,2,150,50)
        CALL MEMO(-1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL MEMO(-2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        END IF
        WRITE(IOUT,*)
        WRITE(IOUT,*)' ROTATIONAL SECTION FOR J-1 -> J'
        WRITE(IOUT,*)' J = ',JPREV,' -> J = ',JCURR
        WRITE(IOUT,*)
        DO I=1,10
          NSINDL(I)=0
          NSINDR(I)=0
        END DO
C**GET STORAGE FOR 3-J SYMBOLS
        KSSR=2*JCURR+1
        KSSL=2*JPREV+1
        KSSX=MAX0(KSSL,KSSR)
        CALL MEMO(1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
C**3-J SYMBOLS WILL BE IN THE SAME ORDERING AS SPIN-ROTATION FUNCTIONS
        CALL S3JDIP(W(LDDPM),KSSL,KSSR,JPREV,JCURR,VAL,W(LWRK),
     1  J2MAX+3,KSSX)
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        CALL TRANRT(W,W(LNDUMP),W(LIDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,
     1  W(LRCI),NRSYM,MAXRT,W(LXA),ISZMAX,ISZMAX,W(LTEMP),W(LRVAL),
     2  ILOOP,JSTORE,J21MAX,JPREV,1,JCURR,2,W(LWRK),W(LDDPM),KSSX,50,
     3  NMODE)
        CALL MEMO(-1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
C***************************************RAMAN
        IF(LDUMP.EQ.8.AND.JCURR.GT.1)THEN
C**J-2 -> J
        WRITE(IOUT,*)
        WRITE(IOUT,*)' VIBRATIONAL DIPOLE SECTION FOR J-2 -> J'
        WRITE(IOUT,*)' J = ',JPREV-1,' -> J = ',JCURR
        WRITE(IOUT,*)
        REWIND 151
        REWIND 152
        REWIND 153
        REWIND 154
        REWIND 155
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        CALL MEMO(2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        CALL MEMO(1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL TRANVB(W(LNDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,W(LVCI),
     1  MAXCI,W(LXA),ISZMAX,1,W(LTEMP),W(LTEMP1),W(LEVAL),ILOOP,
     2  JSTORE,J21MAX,JPREV-1,3,JCURR,2,150,50)
        CALL MEMO(-1,LTEMP1,MAXCI,0,0,0,0,0,0,0,0)
        CALL MEMO(-2,LXA,KXA,LTEMP,KTEMP,0,0,0,0,0,0)
        WRITE(IOUT,*)
        WRITE(IOUT,*)' ROTATIONAL SECTION FOR J-2 -> J'
        WRITE(IOUT,*)' J = ',JPREV-1,' -> J = ',JCURR
        WRITE(IOUT,*)
C**GET STORAGE FOR 3-J SYMBOLS
        KSSR=2*JCURR+1
        KSSL=2*JPREV-1
        KSSX=MAX0(KSSL,KSSR)
        CALL MEMO(1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
C**3-J SYMBOLS WILL BE IN THE SAME ORDERING AS SPIN-ROTATION FUNCTIONS
        CALL S3JDIP(W(LDDPM),KSSL,KSSR,JPREV-1,JCURR,VAL,W(LWRK),
     1  J2MAX+3,KSSX)
        REWIND 51
        REWIND 52
        REWIND 53
        REWIND 54
        REWIND 55
        CALL TRANRT(W,W(LNDUMP),W(LIDUMP),NVSYM,MAXSYM,W(LXK),MAXDMP,
     1  W(LRCI),NRSYM,MAXRT,W(LXA),ISZMAX,ISZMAX,W(LTEMP),W(LRVAL),
     2  ILOOP,JSTORE,J21MAX,JPREV-1,3,JCURR,2,W(LWRK),W(LDDPM),KSSX,50,
     3  NMODE)
        CALL MEMO(-1,LDDPM,5*KSSX*KSSX,0,0,0,0,0,0,0,0)
        END IF
        IF(LDUMP.EQ.8)THEN
C**TRANSFER JPREV -> JPREV-1 (STORAGE 1 -> 3)
          CALL SWAP(W(LNDUMP),W(LIDUMP),W(LVCI),W(LEVAL),W(LRCI),
     1    W(LRVAL),NRSYM,MAXRT,MAXSYM,MAXCI,MAXDMP,ILOOP,JSTORE,J21MAX)
        END IF
C***************************************RAMAN
        CALL MEMO(-1,LWRK,J2MAX+3,0,0,0,0,0,0,0,0)
        IF(LDUMP.GE.7)
     1  CALL MEMO(-3,LRCI,MAXRT*MAXDMP*NRSYM*ILOOP*JSTORE,
     2  LRVAL,MAXDMP*NRSYM*ILOOP*JSTORE,LRASS,MAXDMP*(2+NMODE)*NRSYM*
     3  JSTORE,0,0,0,0)
      END IF
      IF(JPREV.GT.0)GO TO 9996
      IF(LDUMP.GT.8)GO TO 9996
      IF(ICOUPL.GT.0.OR.(NNMAX.LT.0.AND.ICI.LT.0))THEN
        CALL MEMO(-1,LIP1,KIP1*ILOOP,0,0,0,0,0,0,0,0)
      END IF
      IF((ICOUPL.GT.1.OR.(NNMAX.LT.0.AND.ICI.LT.-1)).OR.
     1  (ICOUPL.EQ.1.AND.IREACT.NE.0))THEN
        CALL MEMO(-1,LIP2,KIP2*ILOOP,0,0,0,0,0,0,0,0)
      END IF
      IF((ICOUPL.GT.2.OR.(NNMAX.LT.0.AND.ICI.LT.-2)).OR.
     1  (ICOUPL.EQ.2.AND.IREACT.NE.0))THEN
        CALL MEMO(-1,LIP3,KIP3,0,0,0,0,0,0,0,0)
      END IF
      IF((ICOUPL.GT.3.OR.(NNMAX.LT.0.AND.ICI.LT.-3)).OR.
     1  (ICOUPL.EQ.3.AND.IREACT.NE.0))THEN
        CALL MEMO(-1,LIP4,KIP4,0,0,0,0,0,0,0,0)
      END IF
      IF((ICOUPL.GT.4.OR.(NNMAX.LT.0.AND.ICI.LT.-4)).OR.
     1  (ICOUPL.EQ.4.AND.IREACT.NE.0))THEN
        CALL MEMO(-1,LIP5,KIP5,0,0,0,0,0,0,0,0)
      END IF
9996  CONTINUE
      CALL MEMO(-5,LCONTR,MAXPRM*MAXCON*NMODE*ILOOP,LXQ,MAXPTS*NMODE,
     2LSCF,MAXCON*MAXCON*NMODE*ILOOP,LH,MAXCON*MAXPTS*3*NMODE*ILLPP,
     3LSX,MAXCON*MAXCON*NMODE*ILOOP)
      CALL MEMO(-3,LISIZE,NVSYM*ILOOP,LIDUMP,NVSYM*ILOOP*JSTORE*J21MAX,
     1LNDUMP,NVSYM*ILOOP*JSTORE*J21MAX,0,0,0,0)
      CALL MEMO(-1,LNFC,NMODE*2,0,0,0,0,0,0,0,0)
      CALL MEMO(-5,LIP,MAXCI*NMODE*NVSYM*ILOOP,LVCI,MAXCI*MAXDMP*MAXSYM*
C    1ILOOP*JSTORE*J21MAX,LKDUMP,MAXDMP*NVSYM*ILOOP*JSTORE*J21MAX,LXK,
     1ILOOP*JSTORE,LKDUMP,MAXDMP*NVSYM*ILOOP*JSTORE*J21MAX,LXK,
     2MAXDMP*MAXDMP*NVSYM*NVSYM,LEVAL,MAXDMP*MAXSYM*ILOOP*JSTORE*
     3J21MAX)
9998  CONTINUE
9999  CONTINUE

C**************************************************************
      IF(LDUMP.GE.7)THEN
C**GET SPECTRUM
C       READ(INP,*)
C**OUTPUT/INPUT BRANCH FILE [.PQR]
C       READ(INP,'(A)')FILEB
C       WRITE(IOUT,579)FILEB
C       OPEN(UNIT=INP7,FILE=FILEB,STATUS='UNKNOWN')
C       READ(INP,*)
C**OUTPUT/INPUT SPECTRUM FILE [.SPE]
C       READ(INP,'(A)')FILES
C       WRITE(IOUT,581)FILES
C       OPEN(UNIT=INP8,FILE=FILES,FORM='UNFORMATTED',
C    1  STATUS='UNKNOWN')
C       READ(INP,*)
C**OUTPUT GAUSS FILE [.GAU]
C       READ(INP,'(A)')FILEG
C       WRITE(IOUT,580)FILEG
C       OPEN(UNIT=INP9,FILE=FILEG,STATUS='UNKNOWN')
C       READ(INP,*)
C**COMPLETE OR SPECIAL [0/1]
C       READ(INP,*)IWHICH
C       READ(INP,*)
C**PARTITION SUM
C       READ(INP,*)QR
C       READ(INP,*)
C**NO. PARENT SYMMETRIES FOR CURRENT RO-VIB SYMMETRY
C       READ(INP,*)(NSPSYM(I),I=1,NRSYM)
C       READ(INP,*)
C**NUCLEAR SPIN STATISTICS
C       READ(INP,*)((NSPIN(J,I),J=1,NSPSYM(I)),I=1,NRSYM)
C       READ(INP,*)
C**GAUSS HALF-WIDTH
C       READ(INP,*)WDT
C       READ(INP,*)
C**MINIMUM-MAXIMUM TRANSITION ENERGIES
C       READ(INP,*)EMIN,EMAX
C       IF(IWHICH.NE.0)THEN
C         READ(INP,*)
C**INITIAL VIBRATIONAL LEVEL [v1,v2,v3...]
C         READ(INP,*)(IV1(I),I=1,NMODE)
C         READ(INP,*)
C**FINAL VIBRATIONAL LEVEL [v1,v2,v3...]
C         READ(INP,*)(IV2(I),I=1,NMODE)
C         READ(INP,*)
C**ROTATIONAL BRANCH [P,Q,R,A{all}]
C         READ(INP,'(A)')IROT
C       END IF
        IWHICH=KWHICH
        CALL TRANSP(FILEB,FILEG,NMODE,TEMP,QR,FREQ0,WDT,IV1,
     1  IV2,IROT)
      END IF
C**************************************************************

      RETURN
10000 STOP 'JMAX TOO BIG'
      END
C****************************************************************
C****************************************************************
      SUBROUTINE SWAP(NDUMP,IDUMP,VCI,EVAL,RCI,RVAL,NRSYM,MAXRT,MAXSYM,
     1MAXCI,MAXDMP,ILOOP,JSTORE,J21MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NDUMP(MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION IDUMP(MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,ILOOP,JSTORE)
      DIMENSION EVAL(MAXDMP,MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION RCI(MAXRT,MAXDMP,NRSYM,ILOOP,JSTORE)
      DIMENSION RVAL(MAXDMP,NRSYM,ILOOP,JSTORE)
      DO I=1,J21MAX
        DO L=1,ILOOP
          DO M=1,MAXSYM
            NDUMP(M,L,3,I)=NDUMP(M,L,1,I)
            IDUMP(M,L,3,I)=IDUMP(M,L,1,I)
          END DO
        END DO
      END DO
      DO L=1,ILOOP
        DO M=1,MAXSYM
          DO N=1,MAXDMP
            DO K=1,MAXCI
              VCI(K,N,M,L,3)=VCI(K,N,M,L,1)
            END DO
          END DO
        END DO
      END DO
      DO I=1,J21MAX
        DO L=1,ILOOP
          DO M=1,MAXSYM
            DO N=1,MAXDMP
              EVAL(N,M,L,3,I)=EVAL(N,M,L,1,I)
            END DO
          END DO
        END DO
      END DO
      DO L=1,ILOOP
        DO M=1,MAXSYM
          DO N=1,MAXDMP
            DO K=1,MAXRT
              RCI(K,N,M,L,3)=RCI(K,N,M,L,1)
            END DO
          END DO
        END DO
      END DO
      DO L=1,ILOOP
        DO M=1,MAXSYM
          DO N=1,MAXDMP
            RVAL(N,M,L,3)=RVAL(N,M,L,1)
          END DO
        END DO
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE COMPGS(OMEGA,MVB,YLAM,MBB,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION OMEGA(1),MVB(1)
100   FORMAT(1X,'DIFFERENT OMEGAS FOR MODE ',I3)
101   FORMAT(1X,'DIFFERENT NUMBER POINTS FOR MODE ',I3)
      COMMON/FILASS/IOUT
      OM=1/(YLAM*YLAM)
      IF(DABS(OM-OMEGA(MODE)).GT.1.D-8)THEN
        WRITE(IOUT,100)MODE
        WRITE(IOUT,*)OM,OMEGA(MODE)
        STOP 'WRONG OMEGA'
      END IF
      IF(MBB.NE.MVB(MODE))THEN
        WRITE(IOUT,101)MODE
        WRITE(IOUT,*)MBB,MVB(MODE)
        STOP 'WRONG NO. POINTS'
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DIAGF(ISIZEL,ISIZER,XK,ICI)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XK(ISIZEL,1)
      IF(ICI.GT.1)THEN
        DO IX=1,ISIZER
          DO IY=1,ISIZEL
            XK(IY,IX)=1
          END DO
        END DO
      ELSE
        DO IX=1,ISIZER
          DO IY=1,ISIZEL
            XK(IY,IX)=0
          END DO
        END DO
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE FATIN(XA,XAR,NL,NR,INP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 XA(NL,NR)
      REAL*4 XAR(NL,NR)
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      IF(JCOUPL.GE.0)THEN
        READ(INP)XA
      ELSE
        READ(INP)XAR
        DO I=1,NR
          L=NR+1-I
          DO J=1,NL
            K=NL+1-J
            XA(K,L)=XAR(K,L)
          END DO
        END DO
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE FATOUT(XK,XKR,NL,NR,INP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 XK(NL,NR)
      REAL*4 XKR(NL,NR)
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      IF(JCOUPL.GE.0)THEN
        WRITE(INP)XK
      ELSE
        DO I=1,NR
          DO J=1,NL
            XKR(J,I)=XK(J,I)
          END DO
        END DO
        WRITE(INP)XKR
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN60(NB,W,IJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(NB)
      READ(IJ)W
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE INP60R(MB,W,IJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(MB)
      READ(IJ)(W(M),M=1,MB)
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE INP60A(MB,IB,JB,IW,I,J,K,IJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IW(2+MB,IB,JB,1)
      READ(IJ)(IW(M,I,J,K),M=1,MB),IW(1+MB,I,J,K),IW(2+MB,I,J,K)
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE INP60I(MB,IW,IJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IW(MB)
      READ(IJ)(IW(M),M=1,MB)
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN2R(XQ,MAXPTS,MODE,W,MBB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XQ(MAXPTS,1),W(1)
      DO M=1,MBB
        XQ(M,MODE)=W(M)
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN2D(EVAL,MAXDMP,NVSYM,J,ISYM,ENERGY,ISWEEP,ILOOP,
     1JSTORE,JPUT,KROT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION EVAL(MAXDMP,NVSYM,ILOOP,JSTORE,1)
      EVAL(J,ISYM,ISWEEP,JPUT,KROT)=ENERGY
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN2I(KDUMP,MAXDMP,NVSYM,J,ISYM,K,ISWEEP,ILOOP,
     1JSTORE,JPUT,KROT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION KDUMP(MAXDMP,NVSYM,ILOOP,JSTORE,1)
      KDUMP(J,ISYM,ISWEEP,JPUT,KROT)=K
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN3R(SCF,MAXCN1,MAXCN2,NVSYM,I,MODE,W,NVV,ISWEEP,
     1ILOOP,JSTORE,LDUMP,JPUT,KROT,IOFF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION SCF(MAXCN1,MAXCN2,NVSYM,ILOOP,JSTORE),W(1)
      COMMON/FILASS/IOUT
      IF(LDUMP.NE.6)THEN
        IF(KROT.EQ.0.OR.LDUMP.EQ.1.OR.LDUMP.EQ.4)THEN
          DO IY=1,NVV
C           SCF(IY+IOFF,I,MODE,ISWEEP,JPUT,KROT)=W(IY)
            SCF(IY+IOFF,I,MODE,ISWEEP,JPUT)=W(IY)
          END DO
        ELSE
          WRITE(KROT)(W(IY),IY=1,NVV)
        END IF
      ELSE
        WRITE(57+ISWEEP)(W(IY),IY=1,NVV)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE RDVCI(VCI,MAXCI,MAXDMP,MAXSYM,NDUMP,IVSYM,JSIZE,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,1),NDUMP(1)
      JDUMP=NDUMP(IVSYM)
      DO I=1,JDUMP
        READ(57+IND)(VCI(IY,I,MAXSYM,IND),IY=1,JSIZE)
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN3I(IP,MAXCI,NMODE,NVSYM,I,ISYM,IW,ISWEEP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(MAXCI,NMODE,NVSYM,1),IW(1)
      DO J=1,NMODE
        IP(I,J,ISYM,ISWEEP)=IW(J)
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE IN4(H,MAXCON,MAXPTS,NMODE,M,K,MODE,W,NVV,ILOOP,ISWEEP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(MAXCON,MAXPTS,3,ILOOP,NMODE),W(1)
      COMMON/FILASS/IOUT
      DO IY=1,NVV
        H(IY,M,K,ISWEEP,MODE)=W(IY)
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE PUTINT(NV,MODE,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NV(1)
      NV(MODE)=I
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETINT(NV,MODE,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NV(1)
      I=NV(MODE)
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE PUTNT1(NV,IDIM1,IDIM2,IDIM3,IDIM4,MODE1,MODE2,MODE3,
     1MODE4,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NV(IDIM1,IDIM2,IDIM3,IDIM4)
      NV(MODE1,MODE2,MODE3,MODE4)=I
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETNT1(NV,IDIM1,IDIM2,IDIM3,IDIM4,MODE1,MODE2,MODE3,
     1MODE4,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NV(IDIM1,IDIM2,IDIM3,IDIM4)
      I=NV(MODE1,MODE2,MODE3,MODE4)
      RETURN
      END
C****************************************************************
C****************************************************************
C**TEMPORARY TEST OVERLAPS
      SUBROUTINE PROV(NFC,MVB,NMODE,SX,MAXCON,H,MAXPTS,ILOOP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION NFC(NMODE*ILOOP),MVB(NMODE),SX(MAXCON,MAXCON,NMODE)
      DIMENSION H(MAXCON,MAXPTS,3,ILOOP,NMODE)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/FILASS/IOUT,INP
C**SCF OVERLAP MATRICES
      DO MODE=1,NMODE
        CALL GETINT(NFC(1),MODE,NVR)
        CALL GETINT(NFC(1+NMODE*(ILOOP-1)),MODE,NVL)
        DO IX=1,NVR
          DO IY=1,NVL
            SX(IY,IX,MODE)=0
          END DO
        END DO
        MBB=MVB(MODE)
        ITAU=INIT-INCTAU
        DO M=1,MBB
          ITAU=ITAU+INCTAU
          IF(ITAU.GT.722)ITAU=ITAU-720
          FACTOR=1
          IF(IREACT.GT.0.AND.MODE.EQ.NMODE)FACTOR=DSTAU(ITAU)
          DO IX=1,NVR
            DO IY=1,NVL
              OVER=H(IY,M,1,ILOOP,MODE)*H(IX,M,1,1,MODE)*FACTOR
              SX(IY,IX,MODE)=SX(IY,IX,MODE)+OVER
            END DO
          END DO
        END DO
        WRITE(IOUT,*)'MODE,NVL,NVR ',MODE,NVL,NVR
        DO IY=1,NVL
          WRITE(IOUT,*)(SX(IY,IX,MODE),IX=1,NVR)
          WRITE(IOUT,*)
          CALL FLUSH(IOUT)
        END DO
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE CIOV(IDUMP,NDUMP,NVSYM,ILOOP,JSTORE,ISIZE,
     1XK,KDUMP,VCI,MAXCI,MAXDMP,MAXSYM,IP,NMODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IDUMP(NVSYM,ILOOP,JSTORE),
     1NDUMP(NVSYM,ILOOP,JSTORE),ISIZE(NVSYM)
      DIMENSION XK(MAXDMP,MAXDMP),KDUMP(MAXDMP,MAXSYM,ILOOP,JSTORE)
      DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,ILOOP,JSTORE)
      DIMENSION IP(MAXCI,NMODE,NVSYM)
      COMMON/FILASS/IOUT,INP
C**TEST CI OVERLAP MATRIX
      DO ISYM=1,NVSYM
        WRITE(IOUT,*)'SYMM ',ISYM
        JDUMP=IDUMP(ISYM,1,1)
        MAT=NDUMP(ISYM,1,1)
        JSIZE=ISIZE(ISYM)
        DO IX=1,MAT
          DO IY=1,MAT
            XK(IY,IX)=0
          END DO
        END DO
C**RHS
        IRHS=0
        DO IRDUMP=1,JDUMP
          KR=KDUMP(IRDUMP,ISYM,1,1)
          IF(KR.EQ.0)GO TO 9999
          IRHS=IRHS+1
          DO JRSIZE=1,JSIZE
            COEFFR=VCI(JRSIZE,IRDUMP,ISYM,1,1)
C**LHS
            ILHS=0
            DO ILDUMP=1,JDUMP
              KL=KDUMP(ILDUMP,ISYM,1,1)
              IF(KL.EQ.0)GO TO 8888
              ILHS=ILHS+1
              DO JLSIZE=1,JSIZE
                COEFFL=VCI(JLSIZE,ILDUMP,ISYM,1,1)
                IOVER=1
                DO MODE=1,NMODE
                  IF(IOVER.EQ.0)GO TO 7777
                  IF(IP(JLSIZE,MODE,ISYM).NE.IP(JRSIZE,MODE,ISYM))
     1            IOVER=0
                END DO
7777  CONTINUE
                XK(ILHS,IRHS)=XK(ILHS,IRHS)+IOVER*COEFFL*COEFFR
              END DO
8888  CONTINUE
            END DO
          END DO
9999  CONTINUE
        END DO
        DO IRHS=1,MAT
          WRITE(IOUT,*)(XK(ILHS,IRHS),ILHS=1,MAT)
        END DO
      END DO
      RETURN
      END
C**TEMPORARY TEST OVERLAPS
C****************************************************************
C****************************************************************
      SUBROUTINE GRIDS(W,XQ,MAXPTS,MVB,NMODE,NATOM,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(1)
      DIMENSION XQ(MAXPTS,NMODE),MVB(NMODE)
C**************************************************ASSIGN TOTAL STORAGE
      COMMON/CMEMO/NADD,NSEG,KFREE,LFREE,KINF,MADD
C**CURRENT SETTINGS
      COMMON/CADDR/
     &LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LOLDH,LXK,LOLDXQ,LXW,LNBF,
     1LMBF,LSCF,LSX,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
     2LAB,LB,LAA,LBB,LQQ,LMVB,LH,LXQ,LTEMP,LCONTR,
     3LDUM2A(2),LV1,LV2,LV3,LV4,LDUM2B(4),
     4LDUM3A(3),LXK0,LXL0,LXN0,LXM0,LDUM3B(3),
     5LISIZE,LW21,LSS,LSSX,LX21,LE21,LIDUMP,LNDUMP,LIP,LVCI,
     6LDUM6(10),
     7LDUM7(10),
     8LXA,LXA1,LXA2,LXA3,LXA4,LEVAL,LIP1,LIP2,LIP3,LIP4,
     9LPD1,LPD2,LPD3,LPD4,LPD5,LPD6,LPD7,LMXBAS,LKDUMP,LNVF,
     1LMODNT,LJP1,LJP2,LJP3,LJP4,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,
     2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
     3LDUM8(10),
     4LDUM9(10),
     5LDUM10(10),
     6LDUM11(10),
     7LDUM12(4),LXP,LJP6,LXPLOT,LYPLOT,LFPLOT
C**CURRENT SETTINGS
      COMMON/FILASS/IOUT,INP
      COMMON/TRANSF/LTRAN
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/NCPOT/NPOT
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/CSAVES/NNMODS,NAMODS,NVMODS,ICOUPS,JREACS,NREACS
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT
      COMMON/DISC/IDISC
      COMMON/DISCSZ/KLC0,KEJK0,KLV1,KLC1,KEJK1,KLV2,KLC2,KEJK2,
     1KLV3,KLC3,KEJK3,KLV4,KLC4,KEJK4
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
C**************************************************ASSIGN TOTAL STORAGE
C**********************************************************************
C**********************************************************************
C**                            DUMP DIPOLE DATA TO DISC
C**********************************************************************
C**********************************************************************
C******************************
      ITIM=0
      IF(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7.OR.LDUMP.EQ.8)THEN
        IF(JREACT.LE.0)
     1  CALL DUMDP0(NMODE,NATOM,W(LQQ),W(LRR),W(LX0),NPOT,W(LIPOT),
     2  W(LJPOT),W(LCPOT),LDUMP)
        IF(JREACT.GT.0.AND.IDISC.EQ.0)THEN
          REWIND 71
          REWIND 81
          REWIND 91
          IF(LDUMP.EQ.8)THEN
            REWIND 101
            REWIND 111
          END IF
          IF(IFLAUD.NE.1)
     1    CALL DUMDV0(NMODE,NATOM,W(LQQ),W(LRR),W(LXX),W(LXM),
     2    XQ(1,NSMODE),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),W(LMODNT),
     3    LDUMP)
        END IF
      END IF
      IF(ICOUPL.EQ.0)GO TO 3000
C******************************
      ITIM1A=0
      MBFMX1=MAXPTS 
      IF(JCOUPL.GT.0)THEN
        KLV1=MBFMX1
      ELSE
        KLV1=(1+MBFMX1)/2
      END IF
      IF(LDUMP.EQ.8)KLV1=5*KLV1
      CALL MEMO(1,LV1,KLV1,0,0,0,0,0,0,0,0)
      IF(IDISC.EQ.0.AND.(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7.OR.
     1LDUMP.EQ.8))THEN
        REWIND 72
        REWIND 82
        REWIND 92
        IF(LDUMP.EQ.8)THEN
          REWIND 102
          REWIND 112
        END IF
        DO K=1,NAMODS
          IK2=MVB(K)
C**WRITE DIPOLE GRIDS TO DISC
          IF(JREACT.LE.0)
     1    CALL DUMDP1(XQ(1,K),IK2,NMODE,NATOM,W(LQQ),W(LRR),W(LXX),
     2    W(LX0),W(LXL),W(LXM),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,
     3    W(LV1),W(LV1),W(LV1),W(LV1),W(LMODNT),LDUMP)
          IF(JREACT.GT.0.AND.IFLAUD.NE.1)
     1    CALL DUMDV1(XQ(1,K),IK2,NMODE,NATOM,W(LQQ),W(LRR),W(LXX),
     2    W(LXL),W(LXM),XQ(1,NSMODE),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,
     3    W(LV1),W(LV1),W(LMODNT),LDUMP)
        END DO
      END IF
      IF(ICOUPL.EQ.1)GO TO 3000
C******************************
      ITIM2A=0
      MBFMX2=MBFMX1*MAXPTS
      IF(JCOUPL.GT.0)THEN
        KLV2=MBFMX2
      ELSE
        KLV2=(1+MBFMX2)/2
      END IF
      IF(LDUMP.EQ.8)KLV2=5*KLV2
      CALL MEMO(1,LV2,KLV2,0,0,0,0,0,0,0,0)
      IF(IDISC.EQ.0.AND.(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7.OR.
     1LDUMP.EQ.8))THEN
        REWIND 73
        REWIND 83
        REWIND 93
        IF(LDUMP.EQ.8)THEN
          REWIND 103
          REWIND 113
        END IF
        DO K=1,NAMODS
          IK2=MVB(K)
          DO L=1,K-1
            IL2=MVB(L)
C**WRITE DIPOLE GRIDS TO DISC
            IF(JREACT.LE.0)
     1      CALL DUMDP2(XQ(1,K),XQ(1,L),IK2,IL2,NMODE,NATOM,
     2      W(LQQ),W(LRR),W(LXX),W(LX0),W(LXL),W(LXM),NPOT,W(LIPOT),
     3      W(LJPOT),W(LCPOT),K,L,W(LV2),W(LV2),W(LV2),W(LV2),
     4      W(LMODNT),LDUMP)
            IF(JREACT.GT.0.AND.IFLAUD.NE.1)
     1      CALL DUMDV2(XQ(1,K),XQ(1,L),IK2,IL2,NMODE,NATOM,W(LQQ),
     2      W(LRR),W(LXX),W(LXL),W(LXM),XQ(1,NSMODE),NPOT,W(LIPOT),
     3      W(LJPOT),W(LCPOT),K,L,W(LV2),W(LV2),W(LMODNT),LDUMP)
          END DO
        END DO
      END IF
      IF(ICOUPL.EQ.2)GO TO 3000
C******************************
      ITIM3A=0
      MBFMX3=MBFMX2*MAXPTS
      IF(JCOUPL.GT.0)THEN
        KLV3=MBFMX3
      ELSE
        KLV3=(1+MBFMX3)/2
      END IF
      IF(LDUMP.EQ.8)KLV3=5*KLV3
      CALL MEMO(1,LV3,KLV3,0,0,0,0,0,0,0,0)
      IF(IDISC.EQ.0.AND.(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7.OR.
     1LDUMP.EQ.8))THEN
        REWIND 74
        REWIND 84
        REWIND 94
        IF(LDUMP.EQ.8)THEN
          REWIND 104
          REWIND 114
        END IF
        DO K=1,NAMODS
          IK2=MVB(K)
          DO L=1,K-1
            IL2=MVB(L)
            DO N=1,L-1
              IN2=MVB(N)
C**WRITE DIPOLE GRIDS TO DISC
              IF(JREACT.LE.0)
     1        CALL DUMDP3(XQ(1,K),XQ(1,L),XQ(1,N),IK2,IL2,IN2,
     2        NMODE,NATOM,W(LQQ),W(LRR),W(LXX),W(LX0),W(LXL),W(LXM),
     3        NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,W(LV3),W(LV3),
     4        W(LV3),W(LV3),W(LMODNT),LDUMP)
              IF(JREACT.GT.0.AND.IFLAUD.NE.1)
     1        CALL DUMDV3(XQ(1,K),XQ(1,L),XQ(1,N),IK2,IL2,IN2,NMODE,
     2        NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),XQ(1,NSMODE),
     3        NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,W(LV3),W(LV3),
     4        W(LMODNT),LDUMP)
            END DO
          END DO
        END DO
      END IF
      IF(ICOUPL.EQ.3)GO TO 3000
C******************************
      ITIM4A=0
      MBFMX4=MBFMX3*MAXPTS
      IF(JCOUPL.GT.0)THEN
        KLV4=MBFMX4
      ELSE
        KLV4=(1+MBFMX4)/2
      END IF
      IF(LDUMP.EQ.8)KLV4=5*KLV4
      CALL MEMO(1,LV4,KLV4,0,0,0,0,0,0,0,0)
      IF(IDISC.EQ.0.AND.(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7.OR.
     1LDUMP.EQ.8))THEN
        REWIND 75
        REWIND 85
        REWIND 95
        IF(LDUMP.EQ.8)THEN
          REWIND 105
          REWIND 115
        END IF
        DO K=1,NAMODS
          IK2=MVB(K)
          DO L=1,K-1
            IL2=MVB(L)
            DO N=1,L-1
              IN2=MVB(N)
              DO M=1,N-1
                IM2=MVB(M)
C**WRITE DIPOLE GRIDS TO DISC
                IF(JREACT.LE.0)
     1          CALL DUMDP4(XQ(1,K),XQ(1,L),XQ(1,N),XQ(1,M),
     2          IK2,IL2,IN2,IM2,NMODE,NATOM,W(LQQ),W(LRR),W(LXX),
     3          W(LX0),W(LXL),W(LXM),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),
     4          K,L,N,M,W(LV4),W(LV4),W(LV4),W(LV4),W(LMODNT),LDUMP)
                IF(JREACT.GT.0.AND.IFLAUD.NE.1)
     1          CALL DUMDV4(XQ(1,K),XQ(1,L),XQ(1,N),XQ(1,M),IK2,IL2,
     2          IN2,IM2,NMODE,NATOM,W(LQQ),W(LRR),W(LXX),W(LXL),W(LXM),
     3          XQ(1,NSMODE),NPOT,W(LIPOT),W(LJPOT),W(LCPOT),K,L,N,M,
     4          W(LV4),W(LV4),W(LMODNT),LDUMP)
              END DO
            END DO
          END DO
        END DO
      END IF
C******************************
      IF(ICOUPL.EQ.4)GO TO 3000
C**5-MODE AND HIGHER
3000  CONTINUE
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDP0(NMODE,NATOM,QQ,RR,X0,NPOT,IPOT,JPOT,CPOT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(10)
      REAL*4 VR(10)
      LOGICAL TRIAT
      DIMENSION QQ(NMODE),X0(NATOM,3),RR(NATOM,NATOM),VC(5)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPREF/V,VR
      COMMON/FILASS/IOUT
      DO K=1,NMODE
        QQ(K)=0
      END DO
      NUMST=1
      IF(TRIAT)NUMST=2
      IF(LDUMP.EQ.8)GO TO 100
      DO IDIP=NUMST,NUMDIP
        IF(IWHICH.GT.0)THEN
          IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)CALL GETDIP(VDP,NATOM,X0,RR,IDIP)
          IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,X0,RR,QQ,NMODE,IDIP,0.0)
        ELSE
          IF(IWHICH.EQ.0)THEN
            CALL GETDP0(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
          ELSE
            CALL GETQDT(VDP,NMODE,QQ,IDIP)
          END IF
        END IF
        IF(JCOUPL.GE.0.OR.LDUMP.EQ.8)THEN
          V(IDIP)=VDP
        ELSE
          VR(IDIP)=VDP
        END IF
      END DO
      RETURN
100   CONTINUE
      IF(IWHICH.GT.0)CALL GETPOL(VC,NATOM,X0,RR)
      DO I=1,5
        IF(JCOUPL.GE.0.OR.LDUMP.EQ.8)THEN
          V(I)=VC(I)
        ELSE
          VR(I)=VC(I)
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDV0(NMODE,NATOM,QQ,RR,XX,XM,XQTAU,NPOT,IPOT,
     1JPOT,CPOT,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V
      REAL*4 VR
      LOGICAL TRIAT
      DIMENSION MODINT(NMODE),XQTAU(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE),XM(NATOM)
CCCC  DIMENSION XX(NATOM,3,362)
      DIMENSION XX(NATOM,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/FILASS/IOUT,INP
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
C**ASSUME STARTING VALUE TAU: INIT
C**ASSUME NEXT VALUE TAU: INIT+INCTAU
C**ITAU=2 EQUIVALENT TO ITAU=722
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDV0'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

C
      MDT=MODINT(NSMODE)

C**TEMPORARY
C     MDT=1
C**TEMPORARY

      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
C
C**LOOP ROUND TAU
        ITAU=INIT-INCTAU
        DO MTAU=1,MMTAU/MDT
          ITAU=ITAU+INCTAU
          IF(ITAU.GT.722)ITAU=ITAU-720
          DO K=1,NMODE
            QQ(K)=0
          END DO
          IF(IWHICH.NE.0)THEN
            DO I=1,NATOM
              DO J=1,3
                XX(I,J,1)=XX(I,J,ITAU)/SQRT(XM(I))
              END DO
            END DO
            IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1      CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
            IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1      IDIP,XQTAU(MTAU))
          ELSE
            CALL GETDV0(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
          END IF
          IF(JCOUPL.GE.0)THEN
            V=VDP
          ELSE
            VR=VDP
          END IF
          IF(JCOUPL.GE.0)THEN
            WRITE(10*IXDIP+61)V
          ELSE
            WRITE(10*IXDIP+61)VR
          END IF
        END DO
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      IF(ITIM.EQ.0)THEN
        ITIM=1
        CALL TIMIT(3)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDP1(XQ,MM,NMODE,NATOM,QQ,RR,XX,X0,XL,XM,NPOT,IPOT,
     1JPOT,CPOT,MODE,V,VR,VPOL,VPOLR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM),VPOL(5,MM)
      REAL*4 VR(MM),VPOLR(5,MM)
      LOGICAL TRIAT
      DIMENSION MODINT(1)
      DIMENSION XQ(MM),RR(NATOM,NATOM),QQ(NMODE),VC(5)
      DIMENSION XX(NATOM,3),X0(NATOM,3),XL(NATOM,NMODE,3),XM(NATOM)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/FILASS/IOUT,INP
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDP1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      DO K=1,NMODE
        QQ(K)=0
      END DO
      MD=MODINT(MODE)
      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      IF(LDUMP.EQ.8)GO TO 100
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        DO M=1,MM/MD
          QQ(MODE)=XQ(M)
          IF(IWHICH.GT.0)THEN
            DO I=1,NATOM
              DO J=1,3
                XX(I,J)=X0(I,J)+XL(I,MODE,J)*QQ(MODE)/
     1          SQRT(XM(I))
              END DO
            END DO
            IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1      CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
            IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,IDIP,
     1      0.0)
          ELSE
            IF(IWHICH.EQ.0)THEN
              CALL GETDP1(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
            ELSE
              CALL GETQDT(VDP,NMODE,QQ,IDIP)
            END IF
          END IF
          IF(JCOUPL.GT.0)THEN
            V(M)=VDP
          ELSE
            VR(M)=VDP
          END IF
        END DO
        IF(JCOUPL.GT.0)THEN 
          WRITE(10*IXDIP+62)V
        ELSE
          WRITE(10*IXDIP+62)VR
        END IF
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      GO TO 1000
100   CONTINUE
      DO M=1,MM/MD
        QQ(MODE)=XQ(M)
        IF(IWHICH.GT.0)THEN
          DO I=1,NATOM
            DO J=1,3
              XX(I,J)=X0(I,J)+XL(I,MODE,J)*QQ(MODE)/
     1        SQRT(XM(I))
            END DO
          END DO
          CALL GETPOL(VC,NATOM,XX,RR)
        END IF
        DO I=1,5
          IF(JCOUPL.GT.0)THEN
            VPOL(I,M)=VC(I)
          ELSE
            VPOLR(I,M)=VC(I)
          END IF
        END DO
      END DO
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+62)VPOL
        ELSE
          WRITE(10*IXDIP+62)VPOLR
        END IF
      END DO
1000  CONTINUE
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDD1(MM,V,VR,IXDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM)
      REAL*4 VR(MM)
      COMMON/COUPLE/ICOUPL,JCOUPL
      IF(JCOUPL.GT.0)THEN
        READ(10*IXDIP+62)V
      ELSE
        READ(10*IXDIP+62)VR
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDV1(XQ,MM,NMODE,NATOM,QQ,RR,XX,XL,XM,XQTAU,NPOT,
     1IPOT,JPOT,CPOT,MODE,V,VR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM)
      REAL*4 VR(MM)
      LOGICAL TRIAT
      DIMENSION MODINT(NMODE),XQTAU(1)
      DIMENSION XQ(MM),RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
CCCC  DIMENSION XX(NATOM,3,362),XL(NATOM,NMODE,3,362)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/FILASS/IOUT,INP
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
C**ASSUME STARTING VALUE TAU: INIT
C**ASSUME NEXT VALUE TAU: INIT+INCTAU
C**ITAU=2 EQUIVALENT TO ITAU=722
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDV1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      MDT=MODINT(NSMODE)
      MD1=MODINT(MODE)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE.EQ.ISYM(I,J))N1=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
C

C**TEMPORARY
C     MDT=1
C     MD1=1
C**TEMPORARY

      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
C
        ITAU=INIT-INCTAU
C**LOOP ROUND TAU
        DO MTAU=1,MMTAU/MDT
          ITAU=ITAU+INCTAU
          IF(ITAU.GT.722)ITAU=ITAU-720
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M=1,MM/MD1
            QQ(MODE)=XQ(M)
            IF(IWHICH.NE.0)THEN
              DO I=1,NATOM
                DO J=1,3
                  XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MODE,J,ITAU)*QQ(MODE))/
     1            SQRT(XM(I))
                END DO
              END DO
              IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1        CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
              IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1        IDIP,XQTAU(MTAU))
            ELSE
              CALL GETDV1(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
            END IF
            IF(JCOUPL.GT.0)THEN
              V(M)=VDP
            ELSE
              VR(M)=VDP
            END IF
          END DO
          IF(JCOUPL.GT.0)THEN
            WRITE(10*IXDIP+62)V
          ELSE
            WRITE(10*IXDIP+62)VR
          END IF
        END DO
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDP2(XQ1,XQ2,MM1,MM2,NMODE,NATOM,QQ,RR,XX,X0,XL,XM,
     1NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,V,VR,VPOL,VPOLR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM2,MM1),VPOL(5,MM2,MM1)
      REAL*4 VR(MM2,MM1),VPOLR(5,MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(1)
      DIMENSION XQ1(MM1),XQ2(MM2),RR(NATOM,NATOM),QQ(NMODE),VC(5)
      DIMENSION XX(NATOM,3),X0(NATOM,3),XL(NATOM,NMODE,3),XM(NATOM)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/FILASS/IOUT
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDP2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1

      DO K=1,NMODE
        QQ(K)=0
      END DO
      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      IF(LDUMP.EQ.8)GO TO 100
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        DO M1=1,MM1/MD1
          QQ(MODE1)=XQ1(M1)
          DO M2=1,MM2/MD2
            QQ(MODE2)=XQ2(M2)
            IF(IWHICH.GT.0)THEN
              DO I=1,NATOM
                DO J=1,3
                  XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1            SQRT(XM(I))
                  XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1            SQRT(XM(I))
                END DO
              END DO
              IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1        CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
              IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,IDIP,
     1        0.0)
            ELSE
              IF(IWHICH.EQ.0)THEN
                CALL GETDP2(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
              ELSE
                CALL GETQDT(VDP,NMODE,QQ,IDIP)
              END IF
            END IF
            IF(JCOUPL.GT.0)THEN
              V(M2,M1)=VDP
            ELSE
              VR(M2,M1)=VDP
            END IF
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+63)V
        ELSE
          WRITE(10*IXDIP+63)VR
        END IF
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      GO TO 1000
100   CONTINUE
      DO M1=1,MM1/MD1
        QQ(MODE1)=XQ1(M1)
        DO M2=1,MM2/MD2
          QQ(MODE2)=XQ2(M2)
          IF(IWHICH.GT.0)THEN
            DO I=1,NATOM
              DO J=1,3
                XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1          SQRT(XM(I))
                XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1          SQRT(XM(I))
              END DO
            END DO
            CALL GETPOL(VC,NATOM,XX,RR)
          END IF
          DO I=1,5
            IF(JCOUPL.GT.0)THEN
              VPOL(I,M2,M1)=VC(I)
            ELSE
              VPOLR(I,M2,M1)=VC(I)
            END IF
          END DO
        END DO
      END DO
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+63)V
        ELSE
          WRITE(10*IXDIP+63)VR
        END IF
      END DO
1000  CONTINUE
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM2A=1
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDD2(MM1,MM2,V,VR,IXDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM2,MM1)
      REAL*4 VR(MM2,MM1)
      COMMON/COUPLE/ICOUPL,JCOUPL
      IF(JCOUPL.GT.0)THEN
        READ(10*IXDIP+63)V
      ELSE
        READ(10*IXDIP+63)VR
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDV2(XQ1,XQ2,MM1,MM2,NMODE,NATOM,QQ,RR,XX,XL,XM,
     1XQTAU,NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,V,VR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM2,MM1)
      REAL*4 VR(MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(NMODE),XQTAU(1)
      DIMENSION XQ1(MM1),XQ2(MM2),RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
CCCC  DIMENSION XX(NATOM,3,362),XL(NATOM,NMODE,3,362)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/FILASS/IOUT,INP
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
C**ASSUME STARTING VALUE TAU: INIT
C**ASSUME NEXT VALUE TAU: INIT+INCTAU
C**ITAU=2 EQUIVALENT TO ITAU=722
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDV2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      MDT=MODINT(NSMODE)
      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1
C

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C**TEMPORARY

      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
C
        ITAU=INIT-INCTAU
C**LOOP ROUND TAU
        DO MTAU=1,MMTAU/MDT
          ITAU=ITAU+INCTAU
          IF(ITAU.GT.722)ITAU=ITAU-720
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MODE1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MODE2)=XQ2(M2)
              IF(IWHICH.NE.0)THEN
                DO I=1,NATOM
                  DO J=1,3
                    XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MODE1,J,ITAU)*
     1              QQ(MODE1))/SQRT(XM(I))
                    XX(I,J,1)=XX(I,J,1)+XL(I,MODE2,J,ITAU)*QQ(MODE2)/
     1              SQRT(XM(I))
                  END DO
                END DO
                IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1          CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1          IDIP,XQTAU(MTAU))
              ELSE
                CALL GETDV2(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
              END IF
              IF(JCOUPL.GT.0)THEN
                V(M2,M1)=VDP
              ELSE
                VR(M2,M1)=VDP
              END IF
            END DO
          END DO
          IF(JCOUPL.GT.0)THEN
            WRITE(10*IXDIP+63)V
          ELSE
            WRITE(10*IXDIP+63)VR
          END IF
        END DO
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM2A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDP3(XQ1,XQ2,XQ3,MM1,MM2,MM3,NMODE,NATOM,QQ,RR,XX,
     1X0,XL,XM,NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,MODE3,V,VR,VPOL,VPOLR,
     2MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM3,MM2,MM1),VPOL(5,MM3,MM2,MM1)
      REAL*4 VR(MM3,MM2,MM1),VPOLR(5,MM3,MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3),RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XX(NATOM,3),X0(NATOM,3),XL(NATOM,NMODE,3),XM(NATOM)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT),VC(5)
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/FILASS/IOUT
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM3A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDP3'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      MD3=MODINT(MODE3)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
          IF(MODE3.EQ.ISYM(I,J))N3=I
        END DO
      END DO
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N2)MD2=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1

      DO K=1,NMODE
        QQ(K)=0
      END DO
      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      IF(LDUMP.EQ.8)GO TO 100
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        DO M1=1,MM1/MD1
          QQ(MODE1)=XQ1(M1)
          DO M2=1,MM2/MD2
            QQ(MODE2)=XQ2(M2)
            DO M3=1,MM3/MD3
              QQ(MODE3)=XQ3(M3)
              IF(IWHICH.GT.0)THEN
                DO I=1,NATOM
                  DO J=1,3
                    XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1              SQRT(XM(I))
                    XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1              SQRT(XM(I))
                    XX(I,J)=XX(I,J)+XL(I,MODE3,J)*QQ(MODE3)/
     1              SQRT(XM(I))
                  END DO
                END DO
                IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1          CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1          IDIP,0.0)
              ELSE
                IF(IWHICH.EQ.0)THEN
                  CALL GETDP3(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
                ELSE
                  CALL GETQDT(VDP,NMODE,QQ,IDIP)
                END IF
              END IF
              IF(JCOUPL.GT.0)THEN
                V(M3,M2,M1)=VDP
              ELSE
                VR(M3,M2,M1)=VDP
              END IF
            END DO
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+64)V
        ELSE
          WRITE(10*IXDIP+64)VR
        END IF
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      GO TO 1000
100   CONTINUE
      DO M1=1,MM1/MD1
        QQ(MODE1)=XQ1(M1)
        DO M2=1,MM2/MD2
          QQ(MODE2)=XQ2(M2)
          DO M3=1,MM3/MD3
            QQ(MODE3)=XQ3(M3)
            IF(IWHICH.GT.0)THEN
              DO I=1,NATOM
                DO J=1,3
                  XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1            SQRT(XM(I))
                  XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1            SQRT(XM(I))
                  XX(I,J)=XX(I,J)+XL(I,MODE3,J)*QQ(MODE3)/
     1            SQRT(XM(I))
                END DO
              END DO
              CALL GETPOL(VC,NATOM,XX,RR)
            END IF
            DO I=1,5
              IF(JCOUPL.GT.0)THEN
                VPOL(I,M3,M2,M1)=VC(I)
              ELSE
                VPOLR(I,M3,M2,M1)=VC(I)
              END IF
            END DO
          END DO
        END DO
      END DO
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+64)V
        ELSE
          WRITE(10*IXDIP+64)VR
        END IF
      END DO
1000  CONTINUE
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM3A=1
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDD3(MM1,MM2,MM3,V,VR,IXDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM3,MM2,MM1)
      REAL*4 VR(MM3,MM2,MM1)
      COMMON/COUPLE/ICOUPL,JCOUPL
      IF(JCOUPL.GT.0)THEN
        READ(10*IXDIP+64)V
      ELSE
        READ(10*IXDIP+64)VR
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDV3(XQ1,XQ2,XQ3,MM1,MM2,MM3,NMODE,NATOM,QQ,RR,XX,
     1XL,XM,XQTAU,NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,MODE3,V,VR,MODINT,
     2LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM3,MM2,MM1)
      REAL*4 VR(MM3,MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(NMODE),XQTAU(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3),RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
CCCC  DIMENSION XX(NATOM,3,362),XL(NATOM,NMODE,3,362)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/FILASS/IOUT,INP
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
C**ASSUME STARTING VALUE TAU: INIT
C**ASSUME NEXT VALUE TAU: INIT+INCTAU
C**ITAU=2 EQUIVALENT TO ITAU=722
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM3A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDV3'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      MDT=MODINT(NSMODE)
      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      MD3=MODINT(MODE3)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
          IF(MODE3.EQ.ISYM(I,J))N3=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N1.EQ.N3)MD3=1
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      IF(N3.EQ.NT.AND.MDT.NE.1)MD3=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1
      IF(N1T.EQ.N3.AND.MDT.NE.1)MD3=1
      N2T=ISYMP(N2,NT)
      IF(N2T.EQ.N3.AND.MDT.NE.1)MD3=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      N12T=ISYMP(N12,NT)
      IF(N12T.EQ.N3.AND.MDT.NE.1)MD3=1
C

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C     MD3=1
C**TEMPORARY

      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
C
        ITAU=INIT-INCTAU
C**LOOP ROUND TAU
        DO MTAU=1,MMTAU/MDT
            ITAU=ITAU+INCTAU
            IF(ITAU.GT.722)ITAU=ITAU-720
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MODE1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MODE2)=XQ2(M2)
              DO M3=1,MM3/MD3
                QQ(MODE3)=XQ3(M3)
                IF(IWHICH.NE.0)THEN
                  DO I=1,NATOM
                    DO J=1,3
                      XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MODE1,J,ITAU)*
     1                QQ(MODE1))/SQRT(XM(I))
                      XX(I,J,1)=XX(I,J,1)+XL(I,MODE2,J,ITAU)*QQ(MODE2)/
     1                SQRT(XM(I))
                      XX(I,J,1)=XX(I,J,1)+XL(I,MODE3,J,ITAU)*QQ(MODE3)/
     1                SQRT(XM(I))
                    END DO
                  END DO
                  IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1            CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                  IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1            IDIP,XQTAU(MTAU))
                ELSE
                  CALL GETDV3(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
                END IF
                IF(JCOUPL.GT.0)THEN
                  V(M3,M2,M1)=VDP
                ELSE
                  VR(M3,M2,M1)=VDP
                END IF
              END DO
            END DO
          END DO
          IF(JCOUPL.GT.0)THEN
            WRITE(10*IXDIP+64)V
          ELSE
            WRITE(10*IXDIP+64)VR
          END IF
        END DO
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM3A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DUMDP4(XQ1,XQ2,XQ3,XQ4,MM1,MM2,MM3,MM4,NMODE,NATOM,QQ,
     1RR,XX,X0,XL,XM,NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,MODE3,MODE4,V,VR,
     2VPOL,VPOLR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM4,MM3,MM2,MM1),VPOL(5,MM4,MM3,MM2,MM1)
      REAL*4 VR(MM4,MM3,MM2,MM1),VPOLR(5,MM4,MM3,MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3),XQ4(MM4),VC(5)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XX(NATOM,3),X0(NATOM,3),XL(NATOM,NMODE,3),XM(NATOM)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/FILASS/IOUT
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM4A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDP4'
        CALL TIMIT(1)
        CALL FLUSH(IOUT)
      END IF

      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      MD3=MODINT(MODE3)
      MD4=MODINT(MODE4)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
          IF(MODE3.EQ.ISYM(I,J))N3=I
          IF(MODE4.EQ.ISYM(I,J))N4=I
        END DO
      END DO
      IF(N3.EQ.N4)MD4=1
      IF(N2.EQ.N4)MD4=1
      IF(N1.EQ.N4)MD4=1
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N2)MD2=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      IF(N12.EQ.N4)MD4=1
      N13=ISYMP(N1,N3)
      IF(N13.EQ.N4)MD4=1
      N23=ISYMP(N2,N3)
      IF(N23.EQ.N4)MD4=1
      N123=ISYMP(N12,N3)
      IF(N123.EQ.N4)MD4=1

      DO K=1,NMODE
        QQ(K)=0
      END DO
      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      IF(LDUMP.EQ.8)GO TO 100
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        DO M1=1,MM1/MD1
          QQ(MODE1)=XQ1(M1)
          DO M2=1,MM2/MD2
            QQ(MODE2)=XQ2(M2)
            DO M3=1,MM3/MD3
              QQ(MODE3)=XQ3(M3)
              DO M4=1,MM4/MD4
                QQ(MODE4)=XQ4(M4)
                IF(IWHICH.GT.0)THEN
                  DO I=1,NATOM
                    DO J=1,3
                      XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1                SQRT(XM(I))
                      XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1                SQRT(XM(I))
                      XX(I,J)=XX(I,J)+XL(I,MODE3,J)*QQ(MODE3)/
     1                SQRT(XM(I))
                      XX(I,J)=XX(I,J)+XL(I,MODE4,J)*QQ(MODE4)/
     1                SQRT(XM(I))
                    END DO
                  END DO
                  IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1            CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                  IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1            IDIP,0.0)
                ELSE
                  IF(IWHICH.EQ.0)THEN
                    CALL GETDP4(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,
     1              QQ,IDIP)
                  ELSE
                    CALL GETQDT(VDP,NMODE,QQ,IDIP)
                  END IF
                END IF
                IF(JCOUPL.GT.0)THEN
                  V(M4,M3,M2,M1)=VDP
                ELSE
                  VR(M4,M3,M2,M1)=VDP
                END IF
              END DO
            END DO
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+65)V
        ELSE
          WRITE(10*IXDIP+65)VR
        END IF
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      GO TO 1000
100   CONTINUE
      DO M1=1,MM1/MD1
        QQ(MODE1)=XQ1(M1)
        DO M2=1,MM2/MD2
          QQ(MODE2)=XQ2(M2)
          DO M3=1,MM3/MD3
            QQ(MODE3)=XQ3(M3)
            DO M4=1,MM4/MD4
              QQ(MODE4)=XQ4(M4)
              IF(IWHICH.GT.0)THEN
                DO I=1,NATOM
                  DO J=1,3
                    XX(I,J)=X0(I,J)+XL(I,MODE1,J)*QQ(MODE1)/
     1              SQRT(XM(I))
                    XX(I,J)=XX(I,J)+XL(I,MODE2,J)*QQ(MODE2)/
     1              SQRT(XM(I))
                    XX(I,J)=XX(I,J)+XL(I,MODE3,J)*QQ(MODE3)/
     1              SQRT(XM(I))
                    XX(I,J)=XX(I,J)+XL(I,MODE4,J)*QQ(MODE4)/
     1              SQRT(XM(I))
                  END DO
                END DO
                CALL GETPOL(VC,NATOM,XX,RR)
              END IF
              DO I=1,5
                IF(JCOUPL.GT.0)THEN
                  VPOL(I,M4,M3,M2,M1)=VC(I)
                ELSE
                  VPOLR(I,M4,M3,M2,M1)=VC(I)
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
        IF(JCOUPL.GT.0)THEN
          WRITE(10*IXDIP+65)VPOL
        ELSE
          WRITE(10*IXDIP+65)VPOLR
        END IF
      END DO
1000  CONTINUE
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM4A=1
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDD4(MM1,MM2,MM3,MM4,V,VR,IXDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM4,MM3,MM2,MM1)
      REAL*4 VR(MM4,MM3,MM2,MM1)
      COMMON/COUPLE/ICOUPL,JCOUPL
      IF(JCOUPL.GT.0)THEN
        READ(10*IXDIP+65)V
      ELSE
        READ(10*IXDIP+65)VR
      END IF
      RETURN
      END
C****************************************************************
      SUBROUTINE DUMDV4(XQ1,XQ2,XQ3,XQ4,MM1,MM2,MM3,MM4,NMODE,NATOM,QQ,
     1RR,XX,XL,XM,XQTAU,NPOT,IPOT,JPOT,CPOT,MODE1,MODE2,MODE3,MODE4,V,
     2VR,MODINT,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(MM4,MM3,MM2,MM1)
      REAL*4 VR(MM4,MM3,MM2,MM1)
      LOGICAL TRIAT
      DIMENSION MODINT(NMODE),XQTAU(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3),XQ4(MM4)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
CCCC  DIMENSION XX(NATOM,3,362),XL(NATOM,NMODE,3,362)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      COMMON/WHICH/IWHICH
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
C**ASSUME STARTING VALUE TAU: INIT
C**ASSUME NEXT VALUE TAU: INIT+INCTAU
C**ITAU=2 EQUIVALENT TO ITAU=722
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM

      IF(ITIM4A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating DUMDV4'
        CALL TIMIT(1)
        CALL FLUSH(IOUT)
      END IF

      MDT=MODINT(NSMODE)
      MD1=MODINT(MODE1)
      MD2=MODINT(MODE2)
      MD3=MODINT(MODE3)
      MD4=MODINT(MODE4)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MODE1.EQ.ISYM(I,J))N1=I
          IF(MODE2.EQ.ISYM(I,J))N2=I
          IF(MODE3.EQ.ISYM(I,J))N3=I
          IF(MODE4.EQ.ISYM(I,J))N4=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N4)MD4=1
      IF(N2.EQ.N3)MD3=1
      IF(N2.EQ.N4)MD4=1
      IF(N3.EQ.N4)MD4=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      IF(N3.EQ.NT.AND.MDT.NE.1)MD3=1
      IF(N4.EQ.NT.AND.MDT.NE.1)MD4=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1
      IF(N1T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N1T.EQ.N4.AND.MDT.NE.1)MD4=1
      N2T=ISYMP(N2,NT)
      IF(N2T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N2T.EQ.N4.AND.MDT.NE.1)MD4=1
      N3T=ISYMP(N3,NT)
      IF(N3T.EQ.N4.AND.MDT.NE.1)MD4=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      IF(N12.EQ.N4)MD4=1
      N13=ISYMP(N1,N3)
      IF(N13.EQ.N4)MD4=1
      N23=ISYMP(N2,N3)
      IF(N23.EQ.N4)MD4=1
      N12T=ISYMP(N12,NT)
      IF(N12T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N12T.EQ.N4.AND.MDT.NE.1)MD4=1
      N13T=ISYMP(N13,NT)
      IF(N13T.EQ.N4.AND.MDT.NE.1)MD4=1
      N23T=ISYMP(N23,NT)
      IF(N23T.EQ.N4.AND.MDT.NE.1)MD4=1
      N123=ISYMP(N12,N3)
      IF(N123.EQ.N4)MD4=1
      N123T=ISYMP(N123,NT)
      IF(N123T.EQ.N4.AND.MDT.NE.1)MD4=1
C

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C     MD3=1
C     MD4=1
C**TEMPORARY

      ISUBTR=0
      NUMST=1
      IF(TRIAT)NUMST=2
      DO IDIP=NUMST,NUMDIP
        IXDIP=IDIP-ISUBTR
C
        ITAU=INIT-INCTAU
C**LOOP ROUND TAU
        DO MTAU=1,MMTAU/MDT
          ITAU=ITAU+INCTAU
          IF(ITAU.GT.722)ITAU=ITAU-720
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MODE1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MODE2)=XQ2(M2)
              DO M3=1,MM3/MD3
                QQ(MODE3)=XQ3(M3)
                DO M4=1,MM4/MD4
                  QQ(MODE4)=XQ4(M4)
                  IF(IWHICH.NE.0)THEN
                    DO I=1,NATOM
                      DO J=1,3
                        XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MODE1,J,ITAU)*
     1                  QQ(MODE1))/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE2,J,ITAU)*
     1                  QQ(MODE2)/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE3,J,ITAU)*
     1                  QQ(MODE3)/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE4,J,ITAU)*
     1                  QQ(MODE4)/SQRT(XM(I))
                      END DO
                    END DO
                    IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1              CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                    IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,
     1               NMODE,IDIP,XQTAU(MTAU))
                  ELSE
                    CALL GETDV4(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
                  END IF
                  IF(JCOUPL.GT.0)THEN
                    V(M4,M3,M2,M1)=VDP
                  ELSE
                    VR(M4,M3,M2,M1)=VDP
                  END IF
                END DO
              END DO
            END DO
          END DO
          IF(JCOUPL.GT.0)THEN
            WRITE(10*IXDIP+65)V
          ELSE
            WRITE(10*IXDIP+65)VR
          END IF
        END DO
        IF(MOD(IDIP,3).EQ.0)ISUBTR=ISUBTR+3
      END DO
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM4A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DV0(NAMODE,MODE,MAXCON,MAXPTS,HTAU,XQTAU,XA,NSIZE,
     1NNTAU,MMTAU,IP,ISIZE,KROTL,KROTR,IDIP,IXDIP,NMODE,NATOM,QQ,RR,XX,
     2XM,NPOT,IPOT,JPOT,CPOT,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP
      REAL*4 VPR
      DIMENSION IP(ISIZE,1)
      DIMENSION XA(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE),XM(NATOM)
      DIMENSION XX(NATOM,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      DIMENSION HTAU(MAXCON,MAXPTS,3,1),XQTAU(MMTAU),MODINT(1)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT,IFITRP
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/NORMOD/NAMDE,LINBND,NONLIN,MODD
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP

      IF(ITIM.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DV0'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACTL=JNTFAC(NAMODE,ICOUPL,0)
      IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)IFACTL=1

C**RPH ODD K
      KAL=KROTL/2
      INCTL=MOD(IFLAUD,2)*MOD(KAL,2)
      LMAXL=IFLAUD-(IFLAUD-1)*MOD(KAL+1,2)
      KAR=KROTR/2
      INCTR=MOD(IFLAUD,2)*MOD(KAR,2)
      LMAXR=IFLAUD-(IFLAUD-1)*MOD(KAR+1,2)
C**RPH ODD K

      MDT=MODINT(NSMODE)

C**TEMPORARY
      IF(LDUMP.EQ.2)THEN
        MDT=MODINT(NSMODE)
      ELSE
C       MDT=1
      END IF
C**TEMPORARY

C**LOOP ROUND TAU
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU/MDT
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        IF(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7)THEN
          IF(IFLAUD.NE.1)THEN
            IF(JCOUPL.GE.0)THEN
              READ(10*IXDIP+61)VP
            ELSE
              READ(10*IXDIP+61)VPR
            END IF
          ELSE
            DO K=1,NMODE
              QQ(K)=0
            END DO
            IF(IWHICH.NE.0)THEN
              DO I=1,NATOM
                DO J=1,3
                  XX(I,J,1)=XX(I,J,ITAU)/SQRT(XM(I))
                END DO
              END DO
              IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1        CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
              IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1        IDIP,XQTAU(MTAU))
            ELSE
              CALL GETDV0(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
            END IF
            IF(JCOUPL.GE.0)THEN
              VP=VDP
            ELSE
              VPR=VDP
            END IF
          END IF
        END IF
        IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)THEN
          IF(JCOUPL.GT.0)THEN
            IF(IDIP.EQ.NSMODE)THEN
              VP=COS(XQTAU(MTAU))
              IF(LDUMP.EQ.3)VP=COS(XQTAU(MTAU))*COS(XQTAU(MTAU))
            ELSE
              VP=0
            END IF
          ELSE
            IF(IDIP.EQ.NSMODE)THEN
              VPR=COS(XQTAU(MTAU))
              IF(LDUMP.EQ.3)VPR=COS(XQTAU(MTAU))*COS(XQTAU(MTAU))
            ELSE
              VPR=0
            END IF
          END IF
        END IF

C***********************************************************

        IF(JCOUPL.GE.0)THEN
          VV=VP*IFACTL*DSTAU(ITAU)
        ELSE
          VV=VPR*IFACTL*DSTAU(ITAU)
        END IF

C**NSIZE IS NO. UNIQUE INTEGRALS (1-DIM)
C**EVEN TERMS
        DO IRHS=1,NSIZE
          IR=IP(IRHS,MODE)
C**RPH ODD K
          X=VV*HTAU(IR,MTAU,1,LMAXR)*MDT
C**RPH ODD K
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            IL=IP(ILHS,MODE)
            MULTM=1-MOD(IABS(IR-IL),MDT)
C**RPH ODD K
            Y=HTAU(IL,MTAU,1,LMAXL)
C**RPH ODD K
            XA(ILHS+J0)=XA(ILHS+J0)+Y*X*MULTM
          END DO
        END DO
      END DO
      IF(ITIM.EQ.0)THEN
        CALL TIMIT(3)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDP0(NMODE,XA,ISIZEL,ISIZER,JDIP,MSL,MSR,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 V(10)
      REAL*4 VR(10)
      DIMENSION XA(ISIZER)
      COMMON/INDWR/INDW,INDR
      COMMON/WHICH/IWHICH
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/DIPREF/V,VR
      COMMON/FACTOR/FACTOR(6),FACTS(6)
      COMMON/FILASS/IOUT
C     IF(MSL.NE.MSR)RETURN
C**ONE-MODE CONSTANTS
      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.1)IFACT=1
        IF(ICOUPL.EQ.2)IFACT=-(NMODE-2)
        IF(ICOUPL.EQ.3)THEN
          IFACT=(NMODE-3)*(NMODE-1)
          DO I=2,NMODE-2
            IFACT=IFACT-I
          END DO
        END IF
        IF(ICOUPL.EQ.4)THEN
          IFACT=-(NMODE-4)*(NMODE-3)*(NMODE-1)
          DO I=1,NMODE-4
            IFACT=IFACT-I*(NMODE-3-I)
          END DO
          DO I=1,NMODE-4
            IFACT=IFACT+(NMODE-2)*I
          END DO
          DO I=2,NMODE-2
            IFACT=IFACT+(NMODE-4)*I
          END DO
        END IF
      END IF
      FACTS(1)=IFACT
C**TWO-MODE CONSTANTS
      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.2)IFACT=1
        IF(ICOUPL.EQ.3)IFACT=-(NMODE-3)
        IF(ICOUPL.EQ.4)THEN
          IFACT=(NMODE-4)*(NMODE-3)
          DO I=1,NMODE-4
            IFACT=IFACT-I
          END DO
        END IF
      END IF
      FACTS(2)=IFACT
C**THREE-MODE CONSTANTS
      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.3)IFACT=1
        IF(ICOUPL.EQ.4)IFACT=-(NMODE-4)
      END IF
      FACTS(3)=IFACT
C**FOUR-MODE CONSTANTS
      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.4)IFACT=1
      END IF
      FACTS(4)=IFACT
C**(FIVE-MODE CONSTANTS)
      FACT=1
      DO I=1,ICOUPL
        FACT=FACT-FACTOR(I)*FACTS(I)
      END DO
      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        DO IRHS=1,ISIZER
          XA(IRHS)=0
          IF(IRHS.EQ.ILHS.AND.MSR.EQ.MSL)THEN
            IF(LDUMP.NE.0.AND.LDUMP.NE.3)THEN
              IF(JCOUPL.GE.0)XA(IRHS)=XA(IRHS)+V(JDIP)*FACT
              IF(JCOUPL.LT.0)XA(IRHS)=XA(IRHS)+VR(JDIP)*FACT
            END IF
          END IF
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      INDW=IND97
      INDR=IND96
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDV0(NMODE,XA,XK,NSIZE,IP,ISIZMX,ISIZEL,ISIZER,MSL,
     1MSR,IP1,ISIZE1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP1(ISIZE1,1)
      COMMON/INDWR/INDW,INDR
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDV0'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        NLTAU=IP(ILHS,NMODE,MSL)
C**FIND RHS INDEX (TRIVIAL CASE)
        DO IL=1,NSIZE
          IF(NLTAU.EQ.IP1(IL,1))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
          XA(IRHS)=0
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.NMODE.AND.(IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NRTAU=IP(IRHS,NMODE,MSR)
C**FIND LHS INDEX (TRIVIAL CASE)
          DO IR=1,NSIZE
            IF(NRTAU.EQ.IP1(IR,1))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      INDW=IND97
      INDR=IND96
      IF(ITIM.EQ.0)THEN
        CALL TIMIT(3)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DP1(NMODE,MODE,MAXCON,MAXPTS,H,XQ,XA,NSIZE,
     1NN,MM,IP,ISIZE,VP,VPR,IDIP,IXDIP,KMODE,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM)
      REAL*4 VPR(MM)
      DIMENSION MODINT(1)
      DIMENSION H(MAXCON,MAXPTS,3),IP(ISIZE,NMODE)
      DIMENSION XA(1),XQ(MM)
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DP1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.1)IFACT=1
        IF(ICOUPL.EQ.2)IFACT=-(NMODE-2)
        IF(ICOUPL.EQ.3)THEN
          IFACT=(NMODE-3)*(NMODE-1)
          DO I=2,NMODE-2
            IFACT=IFACT-I
          END DO
        END IF
        IF(ICOUPL.EQ.4)THEN
          IFACT=-(NMODE-4)*(NMODE-3)*(NMODE-1)
          DO I=1,NMODE-4
            IFACT=IFACT-I*(NMODE-3-I)
          END DO
          DO I=1,NMODE-4
            IFACT=IFACT+(NMODE-2)*I
          END DO
          DO I=2,NMODE-2
            IFACT=IFACT+(NMODE-4)*I
          END DO
        END IF
      END IF
      MD=1
      IF(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7)THEN
        MD=MODINT(KMODE)
        IF(JCOUPL.GT.0)THEN
          READ(10*IXDIP+62)VP
        ELSE
          READ(10*IXDIP+62)VPR
        END IF
      END IF
      IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)THEN
        DO I=1,NWSYM
          DO J=1,NSYM(I)
            IF(IDIP.EQ.ISYM(I,J))N=I
          END DO
        END DO
        IF(LDUMP.EQ.2.AND.N.NE.1)MD=2
        IF(JCOUPL.GT.0)THEN
          DO M=1,MM/MD
            IF(IDIP.EQ.KMODE)THEN
              VP(M)=XQ(M)
              IF(LDUMP.EQ.3)VP(M)=XQ(M)*XQ(M)
            ELSE
              VP(M)=0
            END IF
          END DO
        ELSE
          DO M=1,MM/MD
            IF(IDIP.EQ.KMODE)THEN
              VPR(M)=XQ(M)
              IF(LDUMP.EQ.3)VPR(M)=XQ(M)*XQ(M)
            ELSE
              VPR(M)=0
            END IF
          END DO
        END IF
      END IF
      DO M=1,MM/MD
        IF(JCOUPL.GT.0)THEN
          VV=VP(M)*IFACT
        ELSE
          VV=VPR(M)*IFACT
        END IF
C**NSIZE IS NO. UNIQUE INTEGRALS (1-DIM)
        DO IRHS=1,NSIZE
          NR=IP(IRHS,MODE)
          X=VV*H(NR,M,1)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL=IP(ILHS,MODE)
            Y=H(NL,M,1)
            XA(ILHS+J0)=XA(ILHS+J0)+Y*X*MD
          END DO
        END DO
      END DO
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM1A=1
        CALL FLUSH(IOUT)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0FP1(MODE,MAXCON,MAXPTS,H,XQ,XA,NSIZEL,NSIZER,
     1MM,IP,ISIZE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(MAXCON,MAXPTS,3,2),IP(ISIZE,1,2,2)
      DIMENSION XA(NSIZEL,NSIZER),XQ(MM)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0FP1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      DO M=1,MM
C**NSIZE IS NO. UNIQUE INTEGRALS (1-DIM)
        DO IRHS=1,NSIZER
          NR=IP(IRHS,MODE,1,1)
          X=H(NR,M,1,1)
          DO ILHS=1,NSIZEL
            NL=IP(ILHS,MODE,1,2)
            Y=H(NL,M,1,2)
            XA(ILHS,IRHS)=XA(ILHS,IRHS)+Y*X
          END DO
        END DO
      END DO
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DV1(NAMODE,MODE1,MODE2,MAXCON,MAXPTS,H,XQ,HTAU,XQTAU,
     1XA,NSIZE,NN,MM,NNTAU,MMTAU,IP,ISIZE,TEMP,JCI,JCIM,X0,T0,VP,VPR,
     2KROTL,KROTR,IDIP,IXDIP,NMODE,NATOM,QQ,RR,XX,XL,XM,NPOT,IPOT,JPOT,
     3CPOT,MOD1,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM)
      REAL*4 VPR(MM)
      DIMENSION MODINT(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      DIMENSION H(MAXCON,MAXPTS,3),IP(ISIZE,1)
      DIMENSION XA(1),XQ(MM)
      DIMENSION TEMP(JCI,JCI)
      DIMENSION X0(JCI,JCI,MM),T0(JCIM,JCIM,MMTAU)
      DIMENSION HTAU(MAXCON,MAXPTS,3,1),XQTAU(MMTAU)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT,IFITRP
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/NORMOD/NAMDE,LINBND,NONLIN,MODD
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP

      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DV1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACTL=JNTFAC(NAMODE,ICOUPL,1)
      IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)IFACTL=1

C**RPH ODD K
      KAL=KROTL/2
      INCTL=MOD(IFLAUD,2)*MOD(KAL,2)
      LMAXL=IFLAUD-(IFLAUD-1)*MOD(KAL+1,2)
      KAR=KROTR/2
      INCTR=MOD(IFLAUD,2)*MOD(KAR,2)
      LMAXR=IFLAUD-(IFLAUD-1)*MOD(KAR+1,2)
C**RPH ODD K

      MDT=MODINT(NSMODE)
      MD1=MODINT(MOD1)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1

C**TEMPORARY
      IF(LDUMP.NE.2)THEN
C       MDT=1
C       MD1=1
      END IF
C**TEMPORARY

      MD=MD1*MDT

C**FORM INDIVIDUAL INTEGRATION TERMS (START)
      DO MTAU=1,MMTAU/MDT
        DO NRR=1,JCIM
          NR=NRR
C**RPH ODD K
          X=HTAU(NR,MTAU,1,LMAXR)*MD
C**RPH ODD K
          DO NLL=1,JCIM
            NL=NLL
C**RPH ODD K
            Y=HTAU(NL,MTAU,1,LMAXL)
C**RPH ODD K
            T0(NLL,NRR,MTAU)=Y*X
          END DO
        END DO
      END DO
      DO M=1,MM/MD1
        DO NR1=1,JCI
          X=H(NR1,M,1)
          DO NL1=1,JCI
            Y=H(NL1,M,1)
            X0(NL1,NR1,M)=Y*X
          END DO
        END DO
      END DO
C**FORM INDIVIDUAL INTEGRATION TERMS (END)
C**LOOP ROUND TAU (START 2-MODE INTEGRATION)
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU/MDT
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        IF(LDUMP.EQ.1.OR.LDUMP.EQ.5.OR.LDUMP.EQ.7)THEN
          IF(IFLAUD.NE.1)THEN
            IF(JCOUPL.GE.0)THEN
              READ(10*IXDIP+62)VP
            ELSE
              READ(10*IXDIP+62)VPR
            END IF
          ELSE
            DO K=1,NMODE
              QQ(K)=0
            END DO
            DO M=1,MM/MD1
              QQ(MOD1)=XQ(M)
              IF(IWHICH.NE.0)THEN
                DO I=1,NATOM
                  DO J=1,3
                    XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MOD1,J,ITAU)*QQ(MOD1))/
     1              SQRT(XM(I))
                  END DO
                END DO
                IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1          CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1          IDIP,XQTAU(MTAU))
              ELSE
                CALL GETDV1(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
              END IF
              IF(JCOUPL.GT.0)THEN
                VP(M)=VDP
              ELSE
                VPR(M)=VDP
              END IF
            END DO
          END IF
        END IF
        IF(LDUMP.EQ.2.OR.LDUMP.EQ.3)THEN
          IF(JCOUPL.GT.0)THEN
            DO M=1,MM/MD1
              IF(IDIP.EQ.MOD1)THEN
                VP(M)=XQ(M)
                IF(LDUMP.EQ.3)VP(M)=XQ(M)*XQ(M)
              ELSE
                VP(M)=0
              END IF
            END DO
          ELSE
            DO M=1,MM/MD1
              IF(IDIP.EQ.MOD1)THEN
                VPR(M)=XQ(M)
                IF(LDUMP.EQ.3)VPR(M)=XQ(M)*XQ(M)
              ELSE
                VPR(M)=0
              END IF
            END DO
          END IF
        END IF

C**********************************************************

        DO IRHS1=1,JCI
          DO ILHS1=1,JCI
            TEMP(ILHS1,IRHS1)=0
          END DO
        END DO
C**START 1-MODE INTEGRATION
        DO M=1,MM/MD1
          IF(JCOUPL.GT.0)THEN
            X=VP(M)*IFACTL
          ELSE
            X=VPR(M)*IFACTL
          END IF
          DO IRHS1=1,JCI
            DO ILHS1=1,JCI
              TEMP(ILHS1,IRHS1)=TEMP(ILHS1,IRHS1)+
     1        X0(ILHS1,IRHS1,M)*X
            END DO
          END DO
        END DO
C**END 1-MODE INTEGRATION

C**NSIZE IS NO. UNIQUE INTEGRALS (2-DIM)
        DO IRHS=1,NSIZE
          NR=IP(IRHS,MODE1)
          IRTAU=IP(IRHS,MODE2)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL=IP(ILHS,MODE1)
            ILTAU=IP(ILHS,MODE2)
            XA(ILHS+J0)=XA(ILHS+J0)+TEMP(NL,NR)*
     1      T0(ILTAU,IRTAU,MTAU)*DSTAU(ITAU)
          END DO
        END DO
      END DO
C**END TAU LOOP (2-MODE INTEGRATION)
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0FV1(NMODE,MODE1,MODE2,MAXCON,MAXPTS,H,XQ,HTAU,XQTAU,
     1XA,NSIZEL,NSIZER,MM,MMTAU,IP,ISIZE,TEMP,JCIL,JCIR,JCIML,JCIMR,X0,
     2T0,KROT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(MAXCON,MAXPTS,3,2),IP(ISIZE,2,2,2)
      DIMENSION XA(NSIZEL,NSIZER),XQ(MM)
      DIMENSION TEMP(JCIL,JCIR)
      DIMENSION X0(JCIL,JCIR,MM),T0(JCIML,JCIMR,MMTAU)
      DIMENSION HTAU(MAXCON,MAXPTS,3,2,2),XQTAU(MMTAU)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/FILASS/IOUT,INP
      IF(ITIM1B.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0FV1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      KA=KROT/2
      INCT=MOD(IFLAUD,2)*MOD(KA,2)
      LMAX=IFLAUD-(IFLAUD-1)*MOD(KA+1,2)
      FACTOR=1.D0/NAMODE

C**FORM INDIVIDUAL INTEGRATION TERMS (START)
      DO MTAU=1,MMTAU
        DO NRR=1,JCIMR
          NR=NRR
          X=HTAU(NR,MTAU,1,LMAX,1)*FACTOR
          DO NLL=1,JCIML
            NL=NLL
            Y=HTAU(NL,MTAU,1,LMAX,2)
            T0(NLL,NRR,MTAU)=Y*X
          END DO
        END DO
      END DO
      DO M=1,MM
        DO NR1=1,JCIR
          X=H(NR1,M,1,1)
          DO NL1=1,JCIL
            Y=H(NL1,M,1,2)
            X0(NL1,NR1,M)=Y*X
          END DO
        END DO
      END DO
C**FORM INDIVIDUAL INTEGRATION TERMS (END)

C**LOOP ROUND TAU (START 2-MODE INTEGRATION)
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        DO IRHS1=1,JCIR
          DO ILHS1=1,JCIR
            TEMP(ILHS1,IRHS1)=0
          END DO
        END DO
C**START 1-MODE INTEGRATION
        DO M=1,MM
          DO IRHS1=1,JCIR
            DO ILHS1=1,JCIL
              TEMP(ILHS1,IRHS1)=TEMP(ILHS1,IRHS1)+
     1        X0(ILHS1,IRHS1,M)
            END DO
          END DO
        END DO
C**END 1-MODE INTEGRATION

C**NSIZE IS NO. UNIQUE INTEGRALS (2-DIM)
        DO IRHS=1,NSIZER
          NR=IP(IRHS,MODE1,1,1)
          IRTAU=IP(IRHS,MODE2,1,1)
          DO ILHS=1,NSIZEL
            NL=IP(ILHS,MODE1,1,2)
            ILTAU=IP(ILHS,MODE2,1,2)
            XA(ILHS,IRHS)=XA(ILHS,IRHS)+TEMP(NL,NR)*
     1      T0(ILTAU,IRTAU,MTAU)*DSTAU(ITAU)
          END DO
        END DO
      END DO
C**END TAU LOOP (2-MODE INTEGRATION)
      IF(ITIM1B.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM1B=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDP1(NMODE,MODE,NAMODE,XA,XK,NSIZE,
     1NN,MM,IP,ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP1,ISIZE1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP1(ISIZE1,1)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDP1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL=IP(ILHS,MODE,MSL)
C**FIND RHS INDEX (TRIVIAL CASE)
        DO IL=1,NSIZE
          IF(NL.EQ.IP1(IL,1))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE.AND.(IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR=IP(IRHS,MODE,MSR)
C**FIND LHS INDEX (TRIVIAL CASE)
          DO IR=1,NSIZE
            IF(NR.EQ.IP1(IR,1))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE.EQ.NAMODE.AND.ICOUPL.EQ.1)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VFP1(NMODE,MODE,NAMODE,XA,XK,NSIZEL,NSIZER,
     1IP,ISIZMX,NVSYM,ISIZEL,ISIZER,MSL,MSR,IP1,ISIZE1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,NVSYM,2)
      DIMENSION XA(ISIZER),XK(NSIZEL,NSIZER),IP1(ISIZE1,1,2,2)
      COMMON/INDWR/INDW,INDR
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VFP1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        IF(MODE.GT.1)READ(INDR)XA
        NL=IP(ILHS,MODE,MSL,2)
C**FIND LHS INDEX (TRIVIAL CASE)
        DO IL=1,NSIZEL
          IF(NL.EQ.IP1(IL,1,1,2))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
          NR=IP(IRHS,MODE,MSR,1)
C**FIND RHS INDEX (TRIVIAL CASE)
          DO IR=1,NSIZER
            IF(NR.EQ.IP1(IR,1,1,1))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          X=XK(IL,IR)
          IF(MODE.EQ.1)THEN
            XA(IRHS)=X
          ELSE
            XA(IRHS)=XA(IRHS)*X
          END IF
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE.EQ.NAMODE)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM1A=1
        CALL FLUSH(IOUT)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDV1(NMODE,MODE,NAMODE,XA,XK,NSIZE,IP,ISIZMX,ISIZEL,
     1ISIZER,MSL,MSR,IP2,ISIZE2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP2(ISIZE2,2)
      COMMON/INDWR/INDW,INDR
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDV1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE,MSL)
        NLTAU=IP(ILHS,NMODE,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP2(IL,1).AND.NLTAU.EQ.IP2(IL,2))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE.AND.K.NE.NMODE.AND.(IP(IRHS,K,MSR).NE.
     1      IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE,MSR)
          NRTAU=IP(IRHS,NMODE,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP2(IR,1).AND.NRTAU.EQ.IP2(IR,2))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE.EQ.NAMODE.AND.ICOUPL.EQ.1)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VFV1(NMODE,MODE,NAMODE,XA,XK,NSIZEL,NSIZER,
     1IP,ISIZMX,NVSYM,ISIZEL,ISIZER,MSL,MSR,IP2,ISIZE2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,NVSYM,2)
      DIMENSION XA(ISIZER),XK(NSIZEL,NSIZER),IP2(ISIZE2,2,2,2)
      COMMON/INDWR/INDW,INDR
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/FILASS/IOUT,INP
      IF(ITIM1A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VFV1'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        NL1=IP(ILHS,MODE,MSL,1)
        NLTAU=IP(ILHS,NMODE,MSL,1)
C**FIND RHS INDEX
        DO IL=1,NSIZE1
          IF(NL1.EQ.IP2(IL,1,1,1).AND.NLTAU.EQ.IP2(IL,2,1,1))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
          NR1=IP(IRHS,MODE,MSR,2)
          NRTAU=IP(IRHS,NMODE,MSR,2)
C**FIND LHS INDEX
          DO IL=1,NSIZE2
            IF(NL1.EQ.IP2(IL,1,1,2).AND.NLTAU.EQ.IP2(IL,2,1,2))
     1      GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          X=XK(IL,IR)
          XA(IRHS)=XA(IRHS)*X
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE.EQ.NAMODE)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM1A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM1A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DP2(NMODE,MODE1,MODE2,MAXCON,MAXPTS,H1,XQ1,H2,XQ2,
     1NN1,MM1,NN2,MM2,XA,NSIZE,IP,ISIZE,TEMP,JCI1,JCI2,VP,VPR,
CC   2IP1,ISIZE1,IDIP)
     2IP1,ISIZE1,NSIZE1,IDIP,MOD1,MOD2,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM2,MM1)
      REAL*4 VPR(MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3),IP(ISIZE,NMODE)
      DIMENSION IP1(ISIZE1,1)
      DIMENSION XA(1)
      DIMENSION XQ1(MM1),XQ2(MM2)
      DIMENSION TEMP(JCI2,JCI2)
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DP2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.2)IFACT=1
        IF(ICOUPL.EQ.3)IFACT=-(NMODE-3)
        IF(ICOUPL.EQ.4)THEN
          IFACT=(NMODE-4)*(NMODE-3)
          DO I=1,NMODE-4
            IFACT=IFACT-I
          END DO
        END IF
      END IF
      IF(JCOUPL.GT.0)THEN
        READ(10*IDIP+63)VP
      ELSE
        READ(10*IDIP+63)VPR
      END IF
C**TEMPORARY
C     IF(IDIP.EQ.2)THEN
C     WRITE(IOUT,*)'V0DP2 INPUT PARAMETERS'
C     WRITE(IOUT,*)'NMODE,MODE1,MODE2,MAXCON,MAXPTS,NN1,MM1,NN2,MM2'
C     WRITE(IOUT,*)NMODE,MODE1,MODE2,MAXCON,MAXPTS,NN1,MM1,NN2,MM2
C     WRITE(IOUT,*)'NSIZE,ISIZE,JCI1,JCI2,ISIZE1,NSIZE1'
C     WRITE(IOUT,*)NSIZE,ISIZE,JCI1,JCI2,ISIZE1,NSIZE1
C     WRITE(IOUT,*)'IDIP = ',IDIP
C     WRITE(IOUT,*)'MOD1,MOD2 = ',MOD1,MOD2
C     WRITE(IOUT,*)'IFACT = ',IFACT
C     WRITE(IOUT,*)'VP'
C     DO I=1,MM1
C       WRITE(IOUT,*)(VP(J,I),J=1,MM2)
C     END DO
C     WRITE(IOUT,*)'IP1'
C     WRITE(IOUT,*)(IP1(I,1),I=1,NSIZE1)
C     WRITE(IOUT,*)'IP'
C     DO I=1,NSIZE
C       WRITE(IOUT,*)IP(I,1),IP(I,2)
C     END DO
C     WRITE(IOUT,*)'H1'
C     DO I=1,MAXCON
C       WRITE(IOUT,*)(H1(I,J,1),J=1,MM1)
C     END DO 
C     WRITE(IOUT,*)'H2'
C     DO I=1,MAXCON
C       WRITE(IOUT,*)(H2(I,J,1),J=1,MM2)
C     END DO
C     WRITE(IOUT,*)'V0DP2 - XA ON ENTRY'
C     J0=0
C     DO I=1,NSIZE
C       WRITE(IOUT,*)(XA(J+J0),J=1,I)
C       J0=J0+I
C     END DO
C     END IF
C**TEMPORARY
C***********************************************************

      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      MD=MD1*MD2

C***********************************************************

      DO M1=1,MM1/MD1
        DO IRHS2=1,JCI2
          DO ILHS2=1,JCI2
            TEMP(ILHS2,IRHS2)=0
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          DO M2=1,MM2/MD2
            DO IX1=1,NSIZE1
              IRHS2=IP1(IX1,1)
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              X1=VP(M2,M1)*Y1
              DO IY1=1,NSIZE1
                ILHS2=IP1(IY1,1)
                Y0=H2(ILHS2,M2,1)
C**TEMPORARY
C     IF(IDIP.EQ.2)THEN
C       WRITE(IOUT,*)'M1,M2,IRHS2,ILHS2 = ',M1,M2,IRHS2,ILHS2
C       WRITE(IOUT,*)'Y1*Y0,VP(M2,M1) = ',Y1*Y0,VP(M2,M1)
C     END IF 
C**TEMPORARY
                TEMP(ILHS2,IRHS2)=TEMP(ILHS2,IRHS2)+Y0*X1
              END DO
            END DO
          END DO
        ELSE
          DO M2=1,MM2/MD2
            DO IX1=1,NSIZE1
              IRHS2=IP1(IX1,1)
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              X1=VPR(M2,M1)*Y1
              DO IY1=1,NSIZE1
                ILHS2=IP1(IY1,1)
                Y0=H2(ILHS2,M2,1)
                TEMP(ILHS2,IRHS2)=TEMP(ILHS2,IRHS2)+Y0*X1
              END DO
            END DO
          END DO
        END IF
C**TEMPORARY
C     IF(IDIP.EQ.2)THEN
C     WRITE(IOUT,*)'TEMP - M1 = ',M1
C     DO I=1,JCI2
C       WRITE(IOUT,*)(TEMP(J,I),J=1,JCI2)
C     END DO
C     END IF
C**TEMPORARY
C**NSIZE IS NO. UNIQUE INTEGRALS (2-DIM)
        DO IRHS=1,NSIZE
          NR1=IP(IRHS,MODE1)
          NR2=IP(IRHS,MODE2)
          X1=H1(NR1,M1,1)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL1=IP(ILHS,MODE1)
            NL2=IP(ILHS,MODE2)
            Y=H1(NL1,M1,1)
            XA(ILHS+J0)=XA(ILHS+J0)+Y*TEMP(NL2,NR2)*X1
          END DO
        END DO
      END DO
C**TEMPORARY
C     IF(IDIP.EQ.2)THEN
C     WRITE(IOUT,*)'V0DP2 - XA ON EXIT'
C     J0=0
C     DO I=1,NSIZE
C       WRITE(IOUT,*)(XA(J+J0),J=1,I)
C       J0=J0+I
C     END DO
C     END IF
C**TEMPORARY
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM2A=1
        CALL FLUSH(IOUT)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DV2(NAMODE,MODE1,MODE2,MODE3,MAXCON,MAXPTS,H1,XQ1,H2,
     1XQ2,HTAU,XQTAU,XA,NSIZE,NN1,MM1,NN2,MM2,NNTAU,MMTAU,IP,ISIZE,
     2TEMP,TEMP2,JCI1,JCI2,JCIM,X0,Y0,T0,VP,VPR,KROTL,KROTR,IDIP,NMODE,
     3NATOM,QQ,RR,XX,XL,XM,NPOT,IPOT,JPOT,CPOT,MOD1,MOD2,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM2,MM1)
      REAL*4 VPR(MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3),IP(ISIZE,1)
      DIMENSION XA(1),XQ1(MM1),XQ2(MM2)
      DIMENSION TEMP(JCI1,JCI2,JCI1,JCI2),TEMP2(JCI2,JCI2)
      DIMENSION X0(JCI1,JCI1,MM1),Y0(JCI2,JCI2,MM2)
      DIMENSION T0(JCIM,JCIM,MMTAU)
      DIMENSION HTAU(MAXCON,MAXPTS,3,1),XQTAU(MMTAU)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT,IFITRP
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP

      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DV2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACTL=JNTFAC(NAMODE,ICOUPL,2)

C**RPH ODD K
      KAL=KROTL/2
      INCTL=MOD(IFLAUD,2)*MOD(KAL,2)
      LMAXL=IFLAUD-(IFLAUD-1)*MOD(KAL+1,2)
      KAR=KROTR/2
      INCTR=MOD(IFLAUD,2)*MOD(KAR,2)
      LMAXR=IFLAUD-(IFLAUD-1)*MOD(KAR+1,2)
C**RPH ODD K

      MDT=MODINT(NSMODE)
      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C**TEMPORARY

      MD=MD1*MD2*MDT

C**FORM INDIVIDUAL INTEGRATION TERMS (START)
      DO MTAU=1,MMTAU/MDT
        DO NRR=1,JCIM
          NR=NRR
C**RPH ODD K
          X=HTAU(NR,MTAU,1,LMAXR)*MD
C**RPH ODD K
          DO NLL=1,JCIM
            NL=NLL
C**RPH ODD K
            Y=HTAU(NL,MTAU,1,LMAXL)
C**RPH ODD K
            T0(NLL,NRR,MTAU)=Y*X
          END DO
        END DO
      END DO
      DO M1=1,MM1/MD1
        DO NR1=1,JCI1
          X=H1(NR1,M1,1)
          DO NL1=1,JCI1
            Y=H1(NL1,M1,1)
            X0(NL1,NR1,M1)=Y*X
          END DO
        END DO
      END DO
      DO M2=1,MM2/MD2
        DO NR2=1,JCI2
          X=H2(NR2,M2,1)
          DO NL2=1,JCI2
            Y=H2(NL2,M2,1)
            Y0(NL2,NR2,M2)=Y*X
          END DO
        END DO
      END DO
C**FORM INDIVIDUAL INTEGRATION TERMS (END)
C**LOOP ROUND TAU (START 3-MODE INTEGRATION)
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU/MDT
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        IF(IFLAUD.NE.1)THEN
          IF(JCOUPL.GT.0)THEN
            READ(10*IDIP+63)VP
          ELSE
            READ(10*IDIP+63)VPR
          END IF
        ELSE
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MOD1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MOD2)=XQ2(M2)
              IF(IWHICH.NE.0)THEN
                DO I=1,NATOM
                  DO J=1,3
                    XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MOD1,J,ITAU)*
     1              QQ(MOD1))/SQRT(XM(I))
                    XX(I,J,1)=XX(I,J,1)+XL(I,MOD2,J,ITAU)*QQ(MOD2)/
     1              SQRT(XM(I))
                  END DO
                END DO
                IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1          CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1          IDIP,XQTAU(MTAU))
              ELSE
                CALL GETDV2(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
              END IF
              IF(JCOUPL.GT.0)THEN
                VP(M2,M1)=VDP
              ELSE
                VPR(M2,M1)=VDP
              END IF
            END DO
          END DO
        END IF

C***********************************************************

        DO IRHS2=1,JCI2
          DO IRHS1=1,JCI1
            DO ILHS2=1,JCI2
              DO ILHS1=1,JCI1
                TEMP(ILHS1,ILHS2,IRHS1,IRHS2)=0
              END DO
            END DO
          END DO
        END DO
C**START 2-MODE INTEGRATION
        DO M1=1,MM1/MD1
          DO IRHS2=1,JCI2
            DO ILHS2=1,JCI2
              TEMP2(ILHS2,IRHS2)=0
            END DO
          END DO
C**START 1-MODE INTEGRATION
          DO M2=1,MM2/MD2
            IF(JCOUPL.GT.0)THEN
              X=VP(M2,M1)*IFACTL
            ELSE
              X=VPR(M2,M1)*IFACTL
            END IF
            DO IRHS2=1,JCI2
              DO ILHS2=1,JCI2
                TEMP2(ILHS2,IRHS2)=TEMP2(ILHS2,IRHS2)+
     1          Y0(ILHS2,IRHS2,M2)*X
              END DO
            END DO
          END DO
C**END 1-MODE INTEGRATION
          DO IRHS2=1,JCI2
            DO IRHS1=1,JCI1
              DO ILHS2=1,JCI2
                DO ILHS1=1,JCI1
                  TEMP(ILHS1,ILHS2,IRHS1,IRHS2)=
     1            TEMP(ILHS1,ILHS2,IRHS1,IRHS2)+
     2            X0(ILHS1,IRHS1,M1)*TEMP2(ILHS2,IRHS2)
                END DO
              END DO
            END DO
          END DO
        END DO
C**END 2-MODE INTEGRATION

C**NSIZE IS NO. UNIQUE INTEGRALS (3-DIM)
        DO IRHS=1,NSIZE
          NR1=IP(IRHS,MODE1)
          NR2=IP(IRHS,MODE2)
          IRTAU=IP(IRHS,MODE3)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL1=IP(ILHS,MODE1)
            NL2=IP(ILHS,MODE2)
            ILTAU=IP(ILHS,MODE3)
            XA(ILHS+J0)=XA(ILHS+J0)+TEMP(NL1,NL2,NR1,NR2)*
     1      T0(ILTAU,IRTAU,MTAU)*DSTAU(ITAU)
          END DO
        END DO
      END DO
C**END TAU LOOP (3-MODE INTEGRATION)
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM2A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDP2(NMODE,MODE1,MODE2,NAMODE,XA,XK,IDIP,JDIP,NSIZE,IP,
     1ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP2,ISIZE2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP2(ISIZE2,2)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDP2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
C**TEMPORARY
C     IF(JDIP.EQ.2)THEN
C     WRITE(IOUT,*)'VDP2 INPUT PARAMETERS'
C     WRITE(IOUT,*)'NMODE,MODE1,MODE2,NAMODE,NSIZE,ISIZMX,ISIZE2'
C     WRITE(IOUT,*)NMODE,MODE1,MODE2,NAMODE,NSIZE,ISIZMX,ISIZE2
C     WRITE(IOUT,*)'MSL,MSR = ',MSL,MSR
C     WRITE(IOUT,*)'IDIP,JDIP = ',IDIP,JDIP
C     WRITE(IOUT,*)'ISIZEL,ISIZER = ',ISIZEL,ISIZER
C     WRITE(IOUT,*)'INDW,INDR = ',INDW,INDR
C     WRITE(IOUT,*)'XK'
C     J0=0
C     DO I=1,NSIZE
C       WRITE(IOUT,*)(XK(J+J0),J=1,I)
C       J0=J0+I
C     END DO
C     END IF
C**TEMPORARY
      DO ILHS=1,ISIZEL
        READ(INDR)XA
C**TEMPORARY
C     IF(JDIP.EQ.2)THEN
C       IF(ILHS.EQ.1)WRITE(IOUT,*)'FIRST COLUMN XA ON ENTRY'
C       IF(ILHS.EQ.ISIZEL)WRITE(IOUT,*)'LAST COLUMN XA ON ENTRY'
C       IF(ILHS.EQ.1.OR.ILHS.EQ.ISIZEL)WRITE(IOUT,*)(XA(I),I=1,ISIZER)
C     END IF
C**TEMPORARY
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP2(IL,1).AND.NL2.EQ.IP2(IL,2))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.(IP(IRHS,K,MSR).NE.
     1      IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP2(IR,1).AND.NR2.EQ.IP2(IR,2))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
C**TEMPORARY
C     IF(JDIP.EQ.2)THEN
C       IF(ILHS.EQ.1)WRITE(IOUT,*)'FIRST COLUMN XA ON EXIT'
C       IF(ILHS.EQ.ISIZEL)WRITE(IOUT,*)'LAST COLUMN XA ON EXIT'
C       IF(ILHS.EQ.1.OR.ILHS.EQ.ISIZEL)WRITE(IOUT,*)(XA(I),I=1,ISIZER)
C     END IF
C**TEMPORARY
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.ICOUPL.EQ.2)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM2A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDV2(NMODE,MODE1,MODE2,NAMODE,XA,XK,NSIZE,IP,ISIZMX,
     1ISIZEL,ISIZER,MSL,MSR,IP3,ISIZE3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP3(ISIZE3,3)
      COMMON/INDWR/INDW,INDR
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM2A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDV2'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
        NLTAU=IP(ILHS,NMODE,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP3(IL,1).AND.NL2.EQ.IP3(IL,2).AND.NLTAU.EQ.
     1    IP3(IL,3))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.K.NE.NMODE.AND.(
     1      IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
          NRTAU=IP(IRHS,NMODE,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP3(IR,1).AND.NR2.EQ.IP3(IR,2).AND.NRTAU.EQ.
     1      IP3(IR,3))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.ICOUPL.EQ.2)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM2A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM2A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DP3(NMODE,MODE1,MODE2,MODE3,MAXCON,MAXPTS,H1,XQ1,H2,
     1XQ2,H3,XQ3,NN1,MM1,NN2,MM2,NN3,MM3,XA,NSIZE,IP,ISIZE,TEMP,JCI1,
     2JCI2,JCI3,VP,VPR,IP2,ISIZE2,NSIZE2,IDIP,MOD1,MOD2,MOD3,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM3,MM2,MM1)
      REAL*4 VPR(MM3,MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3)
      DIMENSION H3(MAXCON,MAXPTS,3)
      DIMENSION IP(ISIZE,NMODE),IP2(ISIZE2,2)
      DIMENSION TEMP(JCI2,JCI3,JCI2,JCI3)
      DIMENSION XA(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3)
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM3A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DP3'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.3)IFACT=1
        IF(ICOUPL.EQ.4)IFACT=-(NMODE-4)
      END IF
      IF(JCOUPL.GT.0)THEN
        READ(10*IDIP+64)VP
      ELSE
        READ(10*IDIP+64)VPR
      END IF
C***********************************************************

      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      MD3=MODINT(MOD3)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
          IF(MOD3.EQ.ISYM(I,J))N3=I
        END DO
      END DO
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N2)MD2=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      MD=MD1*MD2*MD3

C***********************************************************

      DO M1=1,MM1/MD1
        DO IRHS3=1,JCI3
          DO IRHS2=1,JCI2
            DO ILHS3=1,JCI3
              DO ILHS2=1,JCI2
                TEMP(ILHS2,ILHS3,IRHS2,IRHS3)=0
              END DO
            END DO
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          DO IX2=1,NSIZE2
            IRHS2=IP2(IX2,1)
            IRHS3=IP2(IX2,2)
            DO M2=1,MM2/MD2
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              DO M3=1,MM3/MD3
                Z1=H3(IRHS3,M3,1)
                X1=Z1*VP(M3,M2,M1)*Y1
                DO IY2=1,NSIZE2
                  ILHS2=IP2(IY2,1)
                  ILHS3=IP2(IY2,2)
                  Y0=H2(ILHS2,M2,1)
                  Z0=H3(ILHS3,M3,1)
                  TEMP(ILHS2,ILHS3,IRHS2,IRHS3)=
     1            TEMP(ILHS2,ILHS3,IRHS2,IRHS3)+Y0*Z0*X1
                END DO
              END DO
            END DO
          END DO
        ELSE
          DO IX2=1,NSIZE2
            IRHS2=IP2(IX2,1)
            IRHS3=IP2(IX2,2)
            DO M2=1,MM2/MD2
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              DO M3=1,MM3/MD3
                Z1=H3(IRHS3,M3,1)
                X1=Z1*VPR(M3,M2,M1)*Y1
                DO IY2=1,NSIZE2
                  ILHS2=IP2(IY2,1)
                  ILHS3=IP2(IY2,2)
                  Y0=H2(ILHS2,M2,1)
                  Z0=H3(ILHS3,M3,1)
                  TEMP(ILHS2,ILHS3,IRHS2,IRHS3)=
     1            TEMP(ILHS2,ILHS3,IRHS2,IRHS3)+Y0*Z0*X1
                END DO
              END DO
            END DO
          END DO
        END IF
C**NSIZE IS NO. UNIQUE INTEGRALS (3-DIM)
        DO IRHS=1,NSIZE
          NR1=IP(IRHS,MODE1)
          NR2=IP(IRHS,MODE2)
          NR3=IP(IRHS,MODE3)
          X1=H1(NR1,M1,1)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL1=IP(ILHS,MODE1)
            NL2=IP(ILHS,MODE2)
            NL3=IP(ILHS,MODE3)
            Y=H1(NL1,M1,1)
            XA(ILHS+J0)=XA(ILHS+J0)+Y*TEMP(NL2,NL3,NR2,NR3)*X1
          END DO
        END DO
      END DO
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM3A=1
        CALL FLUSH(IOUT)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DV3(NAMODE,MODE1,MODE2,MODE3,MODE4,MAXCON,MAXPTS,H1,
     1XQ1,H2,XQ2,H3,XQ3,HTAU,XQTAU,XA,NSIZE,NN1,MM1,NN2,MM2,NN3,MM3,
     2NNTAU,MMTAU,IP,ISIZE,TEMP1,TEMP2,TEMP3,JCI1,JCI2,JCI3,JCIM,X0,Y0,
     3Z0,T0,VP,VPR,KROTL,KROTR,IDIP,NMODE,NATOM,QQ,RR,XX,XL,XM,NPOT,
     4IPOT,JPOT,CPOT,MOD1,MOD2,MOD3,MODINT,ICOUNT2,IRL2,
     5ICOUNT3,IRL3,IP3,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM3,MM2,MM1)
      REAL*4 VPR(MM3,MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3)
      DIMENSION H3(MAXCON,MAXPTS,3)
      DIMENSION IP(ISIZE,1)
      DIMENSION XA(1),XQ1(MM1),XQ2(MM2),XQ3(MM3)
      DIMENSION TEMP1(JCI3,JCI3),TEMP2(ICOUNT2,ICOUNT2)
      DIMENSION TEMP3(ICOUNT3,ICOUNT3)
      DIMENSION IRL2(ICOUNT2,2),IRL3(ICOUNT3,2),IP3(NSIZE)
      DIMENSION X0(JCI1,JCI1,MM1),Y0(JCI2,JCI2,MM2)
      DIMENSION Z0(JCI3,JCI3,MM3),T0(JCIM,JCIM,MMTAU)
      DIMENSION HTAU(MAXCON,MAXPTS,3,1),XQTAU(MMTAU)
      COMMON/BASIS/NBAS(6,2),MAXSUM(6,2)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT,IFITRP
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/TYPE/LINEAR
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP

      IF(ITIM3A.EQ.0.AND.IND.LT.0)THEN
        WRITE(IOUT,*)'Calculating V0DV3'
        CALL TIMIT(1)
        CALL FLUSH(IOUT)
      END IF

      IF(IND.EQ.0)GO TO 500
      NMAX1=MAX0(MAXSUM(1,1),MAXSUM(2,1))
      NMAX2=MAX0(MAXSUM(1,2),MAXSUM(2,2))
      NMAX=MAX0(NMAX1,NMAX2)
      ICOUNT2=0
      DO I3=0,JCI3-1
        DO I2=0,JCI2-1
          IF(I2+I3.LE.NMAX)THEN
            ICOUNT2=ICOUNT2+1
            IF(IND.GT.0)THEN
              IRL2(ICOUNT2,1)=I2+1
              IRL2(ICOUNT2,2)=I3+1
            END IF
          END IF
        END DO
      END DO
C**RETURN WITH ICOUNT2
      IF(IND.LT.0)RETURN
500   CONTINUE
      NMAX1=MAX0(MAXSUM(1,1),MAXSUM(2,1),MAXSUM(3,1))
      NMAX2=MAX0(MAXSUM(1,2),MAXSUM(2,2),MAXSUM(3,2))
      NMAX=MAX0(NMAX1,NMAX2)
      ICOUNT3=0
      DO I=1,ICOUNT2
        I2=IRL2(I,1)-1
        I3=IRL2(I,2)-1
        DO I1=0,JCI1-1
          IF(I1+I2+I3.LE.NMAX)THEN
            ICOUNT3=ICOUNT3+1
            IF(IND.EQ.0)THEN
              IRL3(ICOUNT3,1)=I1+1
              IRL3(ICOUNT3,2)=I
            END IF
          END IF
        END DO
      END DO
C**RETURN WITH ICOUNT3
      IF(IND.GT.0)RETURN
      DO I=1,NSIZE
        IP3(I)=0
        NR1=IP(I,MODE1)
        NR2=IP(I,MODE2)
        NR3=IP(I,MODE3)
        DO J=1,ICOUNT3
          IF(IRL3(J,1).NE.NR1)GO TO 1000
          K=IRL3(J,2)
          IF(IRL2(K,1).NE.NR2)GO TO 1000
          IF(IRL2(K,2).NE.NR3)GO TO 1000
          IP3(I)=J
1000      CONTINUE
        END DO
        IF(IP3(I).EQ.0)THEN
          WRITE(IOUT,*)'IP3 SET-UP ERROR FOR ELEMENT ',I

       WRITE(IOUT,*)'V0CV3'
       WRITE(IOUT,*)'NAMODE,MODE1,MODE2,MODE3,MODE4'
       WRITE(IOUT,*)NAMODE,MODE1,MODE2,MODE3,MODE4
       WRITE(IOUT,*)'MOD1,MOD2,MOD3,I25'
       WRITE(IOUT,*)MOD1,MOD2,MOD3,I25
       WRITE(IOUT,*)'JCI1,JCI2,JCI3,JCIM'
       WRITE(IOUT,*)JCI1,JCI2,JCI3,JCIM
       WRITE(IOUT,*)'ICOUNT2,ICOUNT3,ISIZE,NSIZE'
       WRITE(IOUT,*)ICOUNT2,ICOUNT3,ISIZE,NSIZE
       WRITE(IOUT,*)'IRL2 - ICOUNT2 = ',ICOUNT2
       DO J=1,ICOUNT2
         WRITE(IOUT,*)J,':',IRL2(J,1),IRL2(J,2)
       END DO
       WRITE(IOUT,*)'IRL3 - ICOUNT3 = ',ICOUNT3
       DO J=1,ICOUNT3
         WRITE(IOUT,*)J,':',IRL3(J,1),IRL3(J,2)
       END DO
       WRITE(IOUT,*)'IP3 - NSIZE = ',NSIZE
       DO J=1,NSIZE
         WRITE(IOUT,*)J,':',IP3(J)
       END DO
       WRITE(IOUT,*)'IP - ISIZE,NSIZE = ',ISIZE,NSIZE
       DO J=1,NSIZE
         WRITE(IOUT,*)J,':',(IP(J,K),K=1,4)
       END DO

          STOP 'IP3 ERROR'
        END IF
      END DO
C**IRL2 & IRL3 CONTAIN POINTERS FOR FIRST 3 INDICES OF IP(NSIZE,4)

      IFACTL=JNTFAC(NAMODE,ICOUPL,3)

C**RPH ODD K
      KAL=KROTL/2
      INCTL=MOD(IFLAUD,2)*MOD(KAL,2)
      LMAXL=IFLAUD-(IFLAUD-1)*MOD(KAL+1,2)
      KAR=KROTR/2
      INCTR=MOD(IFLAUD,2)*MOD(KAR,2)
      LMAXR=IFLAUD-(IFLAUD-1)*MOD(KAR+1,2)
C**RPH ODD K

      MDT=MODINT(NSMODE)
      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      MD3=MODINT(MOD3)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
          IF(MOD3.EQ.ISYM(I,J))N3=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N1.EQ.N3)MD3=1
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      IF(N3.EQ.NT.AND.MDT.NE.1)MD3=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1
      IF(N1T.EQ.N3.AND.MDT.NE.1)MD3=1
      N2T=ISYMP(N2,NT)
      IF(N2T.EQ.N3.AND.MDT.NE.1)MD3=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      N12T=ISYMP(N12,NT)
      IF(N12T.EQ.N3.AND.MDT.NE.1)MD3=1

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C     MD3=1
C**TEMPORARY

      MD=MD1*MD2*MD3*MDT

C**FORM INDIVIDUAL INTEGRATION TERMS (START)
      DO MTAU=1,MMTAU/MDT
        DO NRR=1,JCIM
          NR=NRR
C**RPH ODD K
          X=HTAU(NR,MTAU,1,LMAXR)*MD
C**RPH ODD K
          DO NLL=1,JCIM
            NL=NLL
C**RPH ODD K
            Y=HTAU(NL,MTAU,1,LMAXL)
C**RPH ODD K
            T0(NLL,NRR,MTAU)=Y*X
          END DO
        END DO
      END DO
      DO M1=1,MM1/MD1
        DO NR1=1,JCI1
          X=H1(NR1,M1,1)
          DO NL1=1,JCI1
            Y=H1(NL1,M1,1)
            X0(NL1,NR1,M1)=Y*X
          END DO
        END DO
      END DO
      DO M2=1,MM2/MD2
        DO NR2=1,JCI2
          X=H2(NR2,M2,1)
          DO NL2=1,JCI2
            Y=H2(NL2,M2,1)
            Y0(NL2,NR2,M2)=Y*X
          END DO
        END DO
      END DO
      DO M3=1,MM3/MD3
        DO NR3=1,JCI3
          X=H3(NR3,M3,1)
          DO NL3=1,JCI3
            Y=H3(NL3,M3,1)
            Z0(NL3,NR3,M3)=Y*X
          END DO
        END DO
      END DO
C**FORM INDIVIDUAL INTEGRATION TERMS (END)
C**LOOP ROUND TAU (START 4-MODE INTEGRATION)
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU/MDT
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        IF(IFLAUD.NE.1)THEN
          IF(JCOUPL.GT.0)THEN
            READ(10*IDIP+64)VP
          ELSE
            READ(10*IDIP+64)VPR
          END IF
        ELSE
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MOD1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MOD2)=XQ2(M2)
              DO M3=1,MM3/MD3
                QQ(MOD3)=XQ3(M3)
                IF(IWHICH.NE.0)THEN
                  DO I=1,NATOM
                    DO J=1,3
                      XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MOD1,J,ITAU)*
     1                QQ(MOD1))/SQRT(XM(I))
                      XX(I,J,1)=XX(I,J,1)+XL(I,MOD2,J,ITAU)*QQ(MOD2)/
     1                SQRT(XM(I))
                      XX(I,J,1)=XX(I,J,1)+XL(I,MOD3,J,ITAU)*QQ(MOD3)/
     1                SQRT(XM(I))
                    END DO
                  END DO
                  IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1            CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                  IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,NMODE,
     1            IDIP,XQTAU(MTAU))
                ELSE
                  CALL GETDV3(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
                END IF
                IF(JCOUPL.GT.0)THEN
                  VP(M3,M2,M1)=VDP
                ELSE
                  VPR(M3,M2,M1)=VDP
                END IF
              END DO
            END DO
          END DO
        END IF

C***********************************************************

        DO IRH=1,ICOUNT3
          DO ILH=1,ICOUNT3
            TEMP3(ILH,IRH)=0
          END DO
        END DO
C**START 3-MODE INTEGRATION
        DO M1=1,MM1/MD1
          DO IRH=1,ICOUNT2
            DO ILH=1,ICOUNT2
              TEMP2(ILH,IRH)=0
            END DO
          END DO
C**START 2-MODE INTEGRATION
          DO M2=1,MM2/MD2
            DO IRHS3=1,JCI3
              DO ILHS3=1,JCI3
                TEMP1(ILHS3,IRHS3)=0
              END DO
            END DO
C**START 1-MODE INTEGRATION
            DO M3=1,MM3/MD3
              IF(JCOUPL.GT.0)THEN
                X=VP(M3,M2,M1)*IFACTL
              ELSE
                X=VPR(M3,M2,M1)*IFACTL
              END IF
              DO IRHS3=1,JCI3
                DO ILHS3=1,JCI3
                  TEMP1(ILHS3,IRHS3)=TEMP1(ILHS3,IRHS3)+
     1            Z0(ILHS3,IRHS3,M3)*X
                END DO
              END DO
            END DO
C**END 1-MODE INTEGRATION
            DO IRH=1,ICOUNT2
              IRHS2=IRL2(IRH,1)
              IRHS3=IRL2(IRH,2)
              DO ILH=1,ICOUNT2
                ILHS2=IRL2(ILH,1)
                ILHS3=IRL2(ILH,2)
                TEMP2(ILH,IRH)=
     1          TEMP2(ILH,IRH)+
     2          Y0(ILHS2,IRHS2,M2)*TEMP1(ILHS3,IRHS3)
              END DO
            END DO
          END DO
C**END 2-MODE INTEGRATION
          DO IRH=1,ICOUNT3
            IRHS1=IRL3(IRH,1)
            IR=IRL3(IRH,2)
C           IRHS2=IRL2(IR,1)
C           IRHS3=IRL2(IR,2)
            DO ILH=1,ICOUNT3
              ILHS1=IRL3(ILH,1)
              IL=IRL3(ILH,2)
C             ILHS2=IRL2(IL,1)
C             ILHS3=IRL2(IL,2)
              TEMP3(ILH,IRH)=
     1        TEMP3(ILH,IRH)+
     2        X0(ILHS1,IRHS1,M1)*TEMP2(IL,IR)
            END DO
          END DO
        END DO
C**END 3-MODE INTEGRATION

C**NSIZE IS NO. UNIQUE INTEGRALS (4-DIM)
        DO IRHS=1,NSIZE
          IR=IP3(IRHS)
          IRTAU=IP(IRHS,MODE4)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            IL=IP3(ILHS)
            ILTAU=IP(ILHS,MODE4)
            XA(ILHS+J0)=XA(ILHS+J0)+
     1      TEMP3(IL,IR)*
     2      T0(ILTAU,IRTAU,MTAU)*DSTAU(ITAU)
          END DO
        END DO
      END DO
C**END TAU LOOP (4-MODE INTEGRATION)
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM3A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDP3(NMODE,MODE1,MODE2,MODE3,NAMODE,XA,XK,
     1NSIZE,IP,ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP3,ISIZE3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP3(ISIZE3,3)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM3A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDP3'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
        NL3=IP(ILHS,MODE3,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP3(IL,1).AND.NL2.EQ.IP3(IL,2).AND.
     1       NL3.EQ.IP3(IL,3))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.K.NE.MODE3.AND.(
     1      IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
          NR3=IP(IRHS,MODE3,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP3(IR,1).AND.NR2.EQ.IP3(IR,2).AND.
     1         NR3.EQ.IP3(IR,3))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.MODE3.EQ.NAMODE-2.
     1AND.ICOUPL.EQ.3)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM3A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDV3(NMODE,MODE1,MODE2,MODE3,NAMODE,XA,XK,NSIZE,IP,
     1ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP4,ISIZE4)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP4(ISIZE4,4)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM3A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDV3'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
        NL3=IP(ILHS,MODE3,MSL)
        NLTAU=IP(ILHS,NMODE,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP4(IL,1).AND.NL2.EQ.IP4(IL,2).AND.
     1    NL3.EQ.IP4(IL,3).AND.NLTAU.EQ.IP4(IL,4))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.K.NE.MODE3.AND.K.NE.
     1      NMODE.AND.(IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
          NR3=IP(IRHS,MODE3,MSR)
          NRTAU=IP(IRHS,NMODE,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP4(IR,1).AND.NR2.EQ.IP4(IR,2).AND.
     1      NR3.EQ.IP4(IR,3).AND.NRTAU.EQ.IP4(IR,4))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.MODE3.EQ.NAMODE-2.
     1AND.ICOUPL.EQ.3)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM3A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM3A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DP4(NMODE,MODE1,MODE2,MODE3,MODE4,MAXCON,MAXPTS,H1,
     1XQ1,H2,XQ2,H3,XQ3,H4,XQ4,NN1,MM1,NN2,MM2,NN3,MM3,NN4,MM4,XA,
     3NSIZE,IP,ISIZE,TEMP,JCI1,JCI2,JCI3,JCI4,VP,VPR,IP3,ISIZE3,
     4NSIZE3,IDIP,MOD1,MOD2,MOD3,MOD4,MODINT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM4,MM3,MM2,MM1)
      REAL*4 VPR(MM4,MM3,MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3)
      DIMENSION H3(MAXCON,MAXPTS,3),H4(MAXCON,MAXPTS,3)
      DIMENSION IP(ISIZE,NMODE),IP3(ISIZE3,3)
      DIMENSION TEMP(JCI2,JCI3,JCI4,JCI2,JCI3,JCI4)
      DIMENSION XA(1)
      DIMENSION XQ1(MM1),XQ2(MM2),XQ3(MM3),XQ4(MM4)
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM4A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating V0DP4'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF
      IFACT=1
      IF(IWHICH.NE.0)THEN
        IF(ICOUPL.EQ.4)IFACT=1
      END IF
      IF(JCOUPL.GT.0)THEN
        READ(10*IDIP+65)VP
      ELSE
        READ(10*IDIP+65)VPR
      END IF

C***********************************************************

      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      MD3=MODINT(MOD3)
      MD4=MODINT(MOD4)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
          IF(MOD3.EQ.ISYM(I,J))N3=I
          IF(MOD4.EQ.ISYM(I,J))N4=I
        END DO
      END DO
      IF(N3.EQ.N4)MD4=1
      IF(N2.EQ.N4)MD4=1
      IF(N1.EQ.N4)MD4=1
      IF(N2.EQ.N3)MD3=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N2)MD2=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      IF(N12.EQ.N4)MD4=1
      N13=ISYMP(N1,N3)
      IF(N13.EQ.N4)MD4=1
      N23=ISYMP(N2,N3)
      IF(N23.EQ.N4)MD4=1
      N123=ISYMP(N12,N3)
      IF(N123.EQ.N4)MD4=1
      MD=MD1*MD2*MD3*MD4

C***********************************************************

      DO M1=1,MM1/MD1
        DO IRHS4=1,JCI4
          DO IRHS3=1,JCI3
            DO IRHS2=1,JCI2
              DO ILHS4=1,JCI4
                DO ILHS3=1,JCI3
                  DO ILHS2=1,JCI2
                    TEMP(ILHS2,ILHS3,ILHS4,IRHS2,IRHS3,IRHS4)=0
                  END DO
                END DO
              END DO
            END DO
          END DO
        END DO
        IF(JCOUPL.GT.0)THEN
          DO IX3=1,NSIZE3
            IRHS2=IP3(IX3,1)
            IRHS3=IP3(IX3,2)
            IRHS4=IP3(IX3,3)
            DO M2=1,MM2/MD2
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              DO M3=1,MM3/MD3
                Z1=H3(IRHS3,M3,1)
                DO M4=1,MM4/MD4
                  W1=H4(IRHS4,M4,1)
                  X1=VP(M4,M3,M2,M1)*Y1*Z1*W1
                  DO IY3=1,NSIZE3
                    ILHS2=IP3(IY3,1)
                    ILHS3=IP3(IY3,2)
                    ILHS4=IP3(IY3,3)
                    Y0=H2(ILHS2,M2,1)
                    Z0=H3(ILHS3,M3,1)
                    W0=H4(ILHS4,M4,1)
                    TEMP(ILHS2,ILHS3,ILHS4,IRHS2,IRHS3,IRHS4)=
     1              TEMP(ILHS2,ILHS3,ILHS4,IRHS2,IRHS3,IRHS4)+
     2              Y0*Z0*W0*X1
                  END DO
                END DO
              END DO
            END DO
          END DO
        ELSE
          DO IX3=1,NSIZE3
            IRHS2=IP3(IX3,1)
            IRHS3=IP3(IX3,2)
            IRHS4=IP3(IX3,3)
            DO M2=1,MM2/MD2
              Y1=H2(IRHS2,M2,1)*IFACT*MD
              DO M3=1,MM3/MD3
                Z1=H3(IRHS3,M3,1)
                DO M4=1,MM4/MD4
                  W1=H4(IRHS4,M4,1)
                  X1=VPR(M4,M3,M2,M1)*Y1*Z1*W1
                  DO IY3=1,NSIZE3
                    ILHS2=IP3(IY3,1)
                    ILHS3=IP3(IY3,2)
                    ILHS4=IP3(IY3,3)
                    Y0=H2(ILHS2,M2,1)
                    Z0=H3(ILHS3,M3,1)
                    W0=H4(ILHS4,M4,1)
                    TEMP(ILHS2,ILHS3,ILHS4,IRHS2,IRHS3,IRHS4)=
     1              TEMP(ILHS2,ILHS3,ILHS4,IRHS2,IRHS3,IRHS4)+
     2              Y0*Z0*W0*X1
                  END DO
                END DO
              END DO
            END DO
          END DO
        END IF
C**NSIZE IS NO. UNIQUE INTEGRALS (4-DIM)
        DO IRHS=1,NSIZE
          NR1=IP(IRHS,MODE1)
          NR2=IP(IRHS,MODE2)
          NR3=IP(IRHS,MODE3)
          NR4=IP(IRHS,MODE4)
          X1=H1(NR1,M1,1)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            NL1=IP(ILHS,MODE1)
            NL2=IP(ILHS,MODE2)
            NL3=IP(ILHS,MODE3)
            NL4=IP(ILHS,MODE4)
            Y=H1(NL1,M1,1)
            XA(ILHS+J0)=XA(ILHS+J0)+Y*TEMP(NL2,NL3,NL4,NR2,NR3,NR4)*X1
          END DO
        END DO
      END DO
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM4A=1
        CALL FLUSH(IOUT)
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE V0DV4(NAMODE,MODE1,MODE2,MODE3,MODE4,MODE5,MAXCON,
     1MAXPTS,H1,XQ1,H2,XQ2,H3,XQ3,H4,XQ4,HTAU,XQTAU,XA,NSIZE,NN1,
     2MM1,NN2,MM2,NN3,MM3,NN4,MM4,NNTAU,MMTAU,IP,ISIZE,TEMP1,TEMP2,
     3TEMP3,TEMP4,JCI1,JCI2,JCI3,JCI4,JCIM,X0,Y0,Z0,W0,T0,VP,VPR,KROTL,
     4KROTR,IDIP,NMODE,NATOM,QQ,RR,XX,XL,XM,NPOT,IPOT,JPOT,CPOT,MOD1,
     5MOD2,MOD3,MOD4,MODINT,ICOUNT2,IRL2,ICOUNT3,IRL3,ICOUNT4,IRL4,
     6IP4,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      REAL*8 VP(MM4,MM3,MM2,MM1)
      REAL*4 VPR(MM4,MM3,MM2,MM1)
      DIMENSION MODINT(1)
      DIMENSION RR(NATOM,NATOM),QQ(NMODE)
      DIMENSION XM(NATOM)
      DIMENSION XX(NATOM,3,722),XL(NATOM,NMODE,3,722)
      DIMENSION IPOT(NPOT,6),JPOT(NPOT,6),CPOT(NPOT)
      DIMENSION H1(MAXCON,MAXPTS,3),H2(MAXCON,MAXPTS,3)
      DIMENSION H3(MAXCON,MAXPTS,3),H4(MAXCON,MAXPTS,3)
      DIMENSION IP(ISIZE,1)
      DIMENSION XA(1),XQ1(MM1),XQ2(MM2),XQ3(MM3),XQ4(MM4)
      DIMENSION TEMP1(JCI4,JCI4),TEMP2(ICOUNT2,ICOUNT2),
     1TEMP3(ICOUNT3,ICOUNT3),TEMP4(ICOUNT4,ICOUNT4)
      DIMENSION IRL2(ICOUNT2,2),IRL3(ICOUNT3,2),IRL4(ICOUNT4,2)
      DIMENSION IP4(NSIZE)
      DIMENSION X0(JCI1,JCI1,MM1),Y0(JCI2,JCI2,MM2)
      DIMENSION Z0(JCI3,JCI3,MM3),W0(JCI4,JCI4,MM4)
      DIMENSION T0(JCIM,JCIM,MMTAU)
      DIMENSION HTAU(MAXCON,MAXPTS,3,1),XQTAU(MMTAU)
      COMMON/BASIS/NBAS(6,2),MAXSUM(6,2)
      COMMON/REACTN/IREACT,MDUM,INIT,INCTAU,IFLAUD
CCCC  COMMON/SCOORD/DSTAU(362)
      COMMON/SCOORD/DSTAU(722)
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/TYPE/LINEAR
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP

      IF(ITIM4A.EQ.0.AND.IND.EQ.-2)THEN
        WRITE(IOUT,*)'Calculating V0DV4'
        CALL TIMIT(1)
        CALL FLUSH(IOUT)
      END IF

      IF(IND.GE.0)GO TO 500
      NMAX1=MAX0(MAXSUM(1,1),MAXSUM(2,1))
      NMAX2=MAX0(MAXSUM(1,2),MAXSUM(2,2))
      NMAX=MAX0(NMAX1,NMAX2)
      ICOUNT2=0
      DO I4=0,JCI4-1
        DO I3=0,JCI3-1
          IF(I3+I4.LE.NMAX)THEN
            ICOUNT2=ICOUNT2+1
            IF(IABS(IND).EQ.1)THEN
              IRL2(ICOUNT2,1)=I3+1
              IRL2(ICOUNT2,2)=I4+1
            END IF
          END IF
        END DO
      END DO
C**RETURN WITH ICOUNT2
      IF(IABS(IND).GT.1)RETURN
500   CONTINUE
      IF(IND.EQ.0)GO TO 600
      NMAX1=MAX0(MAXSUM(1,1),MAXSUM(2,1),MAXSUM(3,1))
      NMAX2=MAX0(MAXSUM(1,2),MAXSUM(2,2),MAXSUM(3,2))
      NMAX=MAX0(NMAX1,NMAX2)
      ICOUNT3=0
      DO I=1,ICOUNT2
        I3=IRL2(I,1)-1
        I4=IRL2(I,2)-1
        DO I2=0,JCI2-1
          IF(I2+I3+I4.LE.NMAX)THEN
            ICOUNT3=ICOUNT3+1
            IF(IND.GT.0)THEN
              IRL3(ICOUNT3,1)=I2+1
              IRL3(ICOUNT3,2)=I
            END IF
          END IF
        END DO
      END DO
C**RETURN WITH ICOUNT3
      IF(IND.LT.0)RETURN
600   CONTINUE
      NMAX1=MAX0(MAXSUM(1,1),MAXSUM(2,1),MAXSUM(3,1),MAXSUM(4,1))
      NMAX2=MAX0(MAXSUM(1,2),MAXSUM(2,2),MAXSUM(3,2),MAXSUM(4,2))
      NMAX=MAX0(NMAX1,NMAX2)
      ICOUNT4=0
      DO I=1,ICOUNT3
        I2=IRL3(I,1)-1
        K=IRL3(I,2)
        I3=IRL2(K,1)-1
        I4=IRL2(K,2)-1
        DO I1=0,JCI1-1
          IF(I1+I2+I3+I4.LE.NMAX)THEN
            ICOUNT4=ICOUNT4+1
            IF(IND.EQ.0)THEN
              IRL4(ICOUNT4,1)=I1+1
              IRL4(ICOUNT4,2)=I
            END IF
          END IF
        END DO
      END DO
C**RETURN WITH ICOUNT4
      IF(IND.GT.0)RETURN
      DO I=1,NSIZE
        IP4(I)=0
        NR1=IP(I,MODE1)
        NR2=IP(I,MODE2)
        NR3=IP(I,MODE3)
        NR4=IP(I,MODE4)
        DO J=1,ICOUNT4
          IF(IRL4(J,1).NE.NR1)GO TO 1000
          K=IRL4(J,2)
          IF(IRL3(K,1).NE.NR2)GO TO 1000
          L=IRL3(K,2)
          IF(IRL2(L,1).NE.NR3)GO TO 1000
          IF(IRL2(L,2).NE.NR4)GO TO 1000
          IP4(I)=J
1000      CONTINUE
        END DO
        IF(IP4(I).EQ.0)THEN
          WRITE(IOUT,*)'IP4 SET-UP ERROR FOR ELEMENT ',I
          STOP 'IP4 ERROR'
        END IF
      END DO
C**IRL2, IRL3 & IRL4 CONTAIN POINTERS FOR FIRST 4 INDICES OF IP(NSIZE,5)

      IFACTL=JNTFAC(NAMODE,ICOUPL,4)

C**RPH ODD K
      KAL=KROTL/2
      INCTL=MOD(IFLAUD,2)*MOD(KAL,2)
      LMAXL=IFLAUD-(IFLAUD-1)*MOD(KAL+1,2)
      KAR=KROTR/2
      INCTR=MOD(IFLAUD,2)*MOD(KAR,2)
      LMAXR=IFLAUD-(IFLAUD-1)*MOD(KAR+1,2)
C**RPH ODD K

      MDT=MODINT(NSMODE)
      MD1=MODINT(MOD1)
      MD2=MODINT(MOD2)
      MD3=MODINT(MOD3)
      MD4=MODINT(MOD4)
      DO I=1,NWSYM
        DO J=1,NSYM(I)
          IF(MOD1.EQ.ISYM(I,J))N1=I
          IF(MOD2.EQ.ISYM(I,J))N2=I
          IF(MOD3.EQ.ISYM(I,J))N3=I
          IF(MOD4.EQ.ISYM(I,J))N4=I
          IF(NSMODE.EQ.ISYM(I,J))NT=I
        END DO
      END DO
      IF(N1.EQ.N2)MD2=1
      IF(N1.EQ.N3)MD3=1
      IF(N1.EQ.N4)MD4=1
      IF(N2.EQ.N3)MD3=1
      IF(N2.EQ.N4)MD4=1
      IF(N3.EQ.N4)MD4=1
      IF(N1.EQ.NT.AND.MDT.NE.1)MD1=1
      IF(N2.EQ.NT.AND.MDT.NE.1)MD2=1
      IF(N3.EQ.NT.AND.MDT.NE.1)MD3=1
      IF(N4.EQ.NT.AND.MDT.NE.1)MD4=1
      N1T=ISYMP(N1,NT)
      IF(N1T.EQ.N2.AND.MDT.NE.1)MD2=1
      IF(N1T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N1T.EQ.N4.AND.MDT.NE.1)MD4=1
      N2T=ISYMP(N2,NT)
      IF(N2T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N2T.EQ.N4.AND.MDT.NE.1)MD4=1
      N3T=ISYMP(N3,NT)
      IF(N3T.EQ.N4.AND.MDT.NE.1)MD4=1
      N12=ISYMP(N1,N2)
      IF(N12.EQ.N3)MD3=1
      IF(N12.EQ.N4)MD4=1
      N13=ISYMP(N1,N3)
      IF(N13.EQ.N4)MD4=1
      N23=ISYMP(N2,N3)
      IF(N23.EQ.N4)MD4=1
      N12T=ISYMP(N12,NT)
      IF(N12T.EQ.N3.AND.MDT.NE.1)MD3=1
      IF(N12T.EQ.N4.AND.MDT.NE.1)MD4=1
      N13T=ISYMP(N13,NT)
      IF(N13T.EQ.N4.AND.MDT.NE.1)MD4=1
      N23T=ISYMP(N23,NT)
      IF(N23T.EQ.N4.AND.MDT.NE.1)MD4=1
      N123=ISYMP(N12,N3)
      IF(N123.EQ.N4)MD4=1
      N123T=ISYMP(N123,NT)
      IF(N123T.EQ.N4.AND.MDT.NE.1)MD4=1

C**TEMPORARY
C     MDT=1
C     MD1=1
C     MD2=1
C     MD3=1
C     MD4=1
C**TEMPORARY

      MD=MD1*MD2*MD3*MD4*MDT

C**FORM INDIVIDUAL INTEGRATION TERMS (START)
      DO MTAU=1,MMTAU/MDT
        DO NRR=1,JCIM
          NR=NRR
C**RPH ODD K
          X=HTAU(NR,MTAU,1,LMAXR)*MD
C**RPH ODD K
          DO NLL=1,JCIM
            NL=NLL
C**RPH ODD K
            Y=HTAU(NL,MTAU,1,LMAXL)
C**RPH ODD K
            T0(NLL,NRR,MTAU)=Y*X
          END DO
        END DO
      END DO
      DO M1=1,MM1/MD1
        DO NR1=1,JCI1
          X=H1(NR1,M1,1)
          DO NL1=1,JCI1
            Y=H1(NL1,M1,1)
            X0(NL1,NR1,M1)=Y*X
          END DO
        END DO
      END DO
      DO M2=1,MM2/MD2
        DO NR2=1,JCI2
          X=H2(NR2,M2,1)
          DO NL2=1,JCI2
            Y=H2(NL2,M2,1)
            Y0(NL2,NR2,M2)=Y*X
          END DO
        END DO
      END DO
      DO M3=1,MM3/MD3
        DO NR3=1,JCI3
          X=H3(NR3,M3,1)
          DO NL3=1,JCI3
            Y=H3(NL3,M3,1)
            Z0(NL3,NR3,M3)=Y*X
          END DO
        END DO
      END DO
      DO M4=1,MM4/MD4
        DO NR4=1,JCI4
          X=H4(NR4,M4,1)
          DO NL4=1,JCI4
            Y=H4(NL4,M4,1)
            W0(NL4,NR4,M4)=Y*X
          END DO
        END DO
      END DO
C**FORM INDIVIDUAL INTEGRATION TERMS (END)

C**LOOP ROUND TAU (START 5-MODE INTEGRATION)
      ITAU=INIT-INCTAU
      DO MTAU=1,MMTAU/MDT
        ITAU=ITAU+INCTAU
        IF(ITAU.GT.722)ITAU=ITAU-720

C***********************************************************

        IF(IFLAUD.NE.1)THEN
          IF(JCOUPL.GT.0)THEN
            READ(10*IDIP+65)VP
          ELSE
            READ(10*IDIP+65)VPR
          END IF
        ELSE
          DO K=1,NMODE
            QQ(K)=0
          END DO
          DO M1=1,MM1/MD1
            QQ(MODE1)=XQ1(M1)
            DO M2=1,MM2/MD2
              QQ(MODE2)=XQ2(M2)
              DO M3=1,MM3/MD3
                QQ(MODE3)=XQ3(M3)
                DO M4=1,MM4/MD4
                  QQ(MODE4)=XQ4(M4)
                  IF(IWHICH.NE.0)THEN
                    DO I=1,NATOM
                      DO J=1,3
                        XX(I,J,1)=(XX(I,J,ITAU)+XL(I,MODE1,J,ITAU)*
     1                  QQ(MODE1))/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE2,J,ITAU)*
     1                  QQ(MODE2)/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE3,J,ITAU)*
     1                  QQ(MODE3)/SQRT(XM(I))
                        XX(I,J,1)=XX(I,J,1)+XL(I,MODE4,J,ITAU)*
     1                  QQ(MODE4)/SQRT(XM(I))
                      END DO
                    END DO
                    IF(LDUMP.EQ.1.OR.LDUMP.EQ.7)
     1              CALL GETDIP(VDP,NATOM,XX,RR,IDIP)
                    IF(LDUMP.EQ.5)CALL GETPRP(VDP,NATOM,XX,RR,QQ,
     1               NMODE,IDIP,XQTAU(MTAU))
                  ELSE
                    CALL GETDV4(VDP,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
                  END IF
                  IF(JCOUPL.GT.0)THEN
                    VP(M4,M3,M2,M1)=VDP
                  ELSE
                    VPR(M4,M3,M2,M1)=VDP
                  END IF
                END DO
              END DO
            END DO
          END DO
        END IF

C***********************************************************

        DO IRH=1,ICOUNT4
          DO ILH=1,ICOUNT4
            TEMP4(ILH,IRH)=0
          END DO
        END DO
C**START 4-MODE INTEGRATION
        DO M1=1,MM1/MD1
          DO IRH=1,ICOUNT3
            DO ILH=1,ICOUNT3
              TEMP3(ILH,IRH)=0
            END DO
          END DO
C**START 3-MODE INTEGRATION
          DO M2=1,MM2/MD2
            DO IRH=1,ICOUNT2
              DO ILH=1,ICOUNT2
                TEMP2(ILH,IRH)=0
              END DO
            END DO
C**START 2-MODE INTEGRATION
            DO M3=1,MM3/MD3
              DO IRHS4=1,JCI4
                DO ILHS4=1,JCI4
                  TEMP1(ILHS4,IRHS4)=0
                END DO
              END DO
C**START 1-MODE INTEGRATION
              DO M4=1,MM4/MD4
                IF(JCOUPL.GT.0)THEN
                  X=VP(M4,M3,M2,M1)*IFACTL
                ELSE
                  X=VPR(M4,M3,M2,M1)*IFACTL
                END IF
                DO IRHS4=1,JCI4
                  DO ILHS4=1,JCI4
                    TEMP1(ILHS4,IRHS4)=TEMP1(ILHS4,IRHS4)+
     1              W0(ILHS4,IRHS4,M4)*X
                  END DO
                END DO
              END DO
C**END 1-MODE INTEGRATION
              DO IRH=1,ICOUNT2
                IRHS3=IRL2(IRH,1)
                IRHS4=IRL2(IRH,2)
                DO ILH=1,ICOUNT2
                  ILHS3=IRL2(ILH,1)
                  ILHS4=IRL2(ILH,2)
                  TEMP2(ILH,IRH)=
     1            TEMP2(ILH,IRH)+
     2            Z0(ILHS3,IRHS3,M3)*TEMP1(ILHS4,IRHS4)
                END DO
              END DO
            END DO
C**END 2-MODE INTEGRATION
            DO IRH=1,ICOUNT3
              IRHS2=IRL3(IRH,1)
              IR=IRL3(IRH,2)
C             IRHS3=IRL2(IR,1)
C             IRHS4=IRL2(IR,2)
              DO ILH=1,ICOUNT3
                ILHS2=IRL3(ILH,1)
                IL=IRL3(ILH,2)
C               ILHS3=IRL2(IL,1)
C               ILHS4=IRL2(IL,2)
                TEMP3(ILH,IRH)=
     1          TEMP3(ILH,IRH)+
     2          Y0(ILHS2,IRHS2,M2)*TEMP2(IL,IR)
              END DO
            END DO
          END DO
C**END 3-MODE INTEGRATION
          DO IRH=1,ICOUNT4
            IRHS1=IRL4(IRH,1)
            IR=IRL4(IRH,2)
            DO ILH=1,ICOUNT4
              ILHS1=IRL4(ILH,1)
              IL=IRL4(ILH,2)
              TEMP4(ILH,IRH)=
     1        TEMP4(ILH,IRH)+
     2        X0(ILHS1,IRHS1,M1)*TEMP3(IL,IR)
            END DO
          END DO
C**END 4-MODE INTEGRATION
        END DO
C**NSIZE IS NO. UNIQUE INTEGRALS (5-DIM)
        DO IRHS=1,NSIZE
          IR=IP4(IRHS)
          IRTAU=IP(IRHS,MODE5)
          J0=IRHS*(IRHS-1)/2
          DO ILHS=1,IRHS
            IL=IP4(ILHS)
            ILTAU=IP(ILHS,MODE5)
            XA(ILHS+J0)=XA(ILHS+J0)+
     1      TEMP4(IL,IR)*
     2      T0(ILTAU,IRTAU,MTAU)*DSTAU(ITAU)
          END DO
        END DO
      END DO
C**END TAU LOOP (5-MODE INTEGRATION)
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM4A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDP4(NMODE,MODE1,MODE2,MODE3,MODE4,
     1NAMODE,XA,XK,NSIZE,IP,ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP4,ISIZE4)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP4(ISIZE4,4)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL
      COMMON/WHICH/IWHICH
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM4A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDP4'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
        NL3=IP(ILHS,MODE3,MSL)
        NL4=IP(ILHS,MODE4,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP4(IL,1).AND.NL2.EQ.IP4(IL,2).AND.
     1       NL3.EQ.IP4(IL,3).AND.NL4.EQ.IP4(IL,4))GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.K.NE.MODE3.AND.K.NE.
     1      MODE4.AND.(IP(IRHS,K,MSR).NE.IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
          NR3=IP(IRHS,MODE3,MSR)
          NR4=IP(IRHS,MODE4,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP4(IR,1).AND.NR2.EQ.IP4(IR,2).AND.
     1         NR3.EQ.IP4(IR,3).AND.NR4.EQ.IP4(IR,4))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.MODE3.EQ.NAMODE-2.
     1AND.MODE4.EQ.NAMODE-3.AND.ICOUPL.EQ.4)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        CALL FLUSH(IOUT)
        ITIM4A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE VDV4(NMODE,MODE1,MODE2,MODE3,MODE4,NAMODE,XA,XK,NSIZE,
     1IP,ISIZMX,ISIZEL,ISIZER,MSL,MSR,IP5,ISIZE5)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IP(ISIZMX,NMODE,1)
      DIMENSION XA(ISIZER),XK(1),IP5(ISIZE5,5)
      COMMON/INDWR/INDW,INDR
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/WHICH/IWHICH
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/FILASS/IOUT,INP
      IF(ITIM4A.EQ.0)THEN
        WRITE(IOUT,*)'Calculating VDV4'
        CALL FLUSH(IOUT)
        CALL TIMIT(1)
      END IF

      IND96=INDW
      IND97=INDR
      DO ILHS=1,ISIZEL
        READ(INDR)XA
        NL1=IP(ILHS,MODE1,MSL)
        NL2=IP(ILHS,MODE2,MSL)
        NL3=IP(ILHS,MODE3,MSL)
        NL4=IP(ILHS,MODE4,MSL)
        NLTAU=IP(ILHS,NMODE,MSL)
C**FIND RHS INDEX
        DO IL=1,NSIZE
          IF(NL1.EQ.IP5(IL,1).AND.NL2.EQ.IP5(IL,2).AND.
     1    NL3.EQ.IP5(IL,3).AND.NL4.EQ.IP5(IL,4).AND.NLTAU.EQ.IP5(IL,5))
     2    GO TO 1000
        END DO
1000    CONTINUE
        DO IRHS=1,ISIZER
C**OVERLAP OF REMAINING STATES
          IS=1
          DO K=1,NMODE
            IF(IS.EQ.0)GO TO 3000
            IF(K.NE.MODE1.AND.K.NE.MODE2.AND.K.NE.MODE3.AND.K.NE.
     1      MODE4.AND.K.NE.NMODE.AND.(IP(IRHS,K,MSR).NE.
     2      IP(ILHS,K,MSL)))IS=0
          END DO
C**OVERLAP OF REMAINING STATES
          NR1=IP(IRHS,MODE1,MSR)
          NR2=IP(IRHS,MODE2,MSR)
          NR3=IP(IRHS,MODE3,MSR)
          NR4=IP(IRHS,MODE4,MSR)
          NRTAU=IP(IRHS,NMODE,MSR)
C**FIND LHS INDEX
          DO IR=1,NSIZE
            IF(NR1.EQ.IP5(IR,1).AND.NR2.EQ.IP5(IR,2).AND.
     1      NR3.EQ.IP5(IR,3).AND.NR4.EQ.IP5(IR,4).AND.NRTAU.EQ.
     2      IP5(IR,5))GO TO 2000
          END DO
2000      CONTINUE
C**GET MATRIX ELEMENT
          MR=IR
          ML=IL
          IF(IR.LT.IL)THEN
            MR=IL
            ML=IR
          END IF
          I=MR*(MR-1)/2+ML
          X=XK(I)
          XA(IRHS)=XA(IRHS)+X*IS
3000      CONTINUE
        END DO
        WRITE(INDW)XA
      END DO
      REWIND INDW
      REWIND INDR
      IF(MODE1.EQ.NAMODE.AND.MODE2.EQ.NAMODE-1.AND.MODE3.EQ.NAMODE-2.
     1AND.MODE4.EQ.NAMODE-3.AND.ICOUPL.EQ.4)THEN
        IF(INDW.NE.96)THEN
          DO I=1,ISIZEL
            READ(INDW)XA
            WRITE(INDR)XA
          END DO
        END IF
      ELSE
        INDW=IND97
        INDR=IND96
      END IF
      IF(ITIM4A.EQ.0)THEN
        CALL TIMIT(3)
        ITIM4A=1
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE OUTDIP(XA,ISIZER,ISIZEL,JDIP,IND,IND1,LDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION XA(ISIZER)
      COMMON/FILASS/IOUT
      IF(LDUMP.EQ.7.OR.LDUMP.EQ.8)THEN
        DO I=1,ISIZEL
          READ(IND1)XA
          WRITE(IND+JDIP)(XA(J),J=1,ISIZER)
        END DO
      ELSE
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE DIPTOT(NDUMP,NVSYM,MAXSYM,XK,MAXDMP,VCI,MAXCI,XA,
     1IDIML,IDIMR,ISIZEL,ISIZER,MSL,MSR,TEMP,EVAL,IDIP,JDIP,LDUMP,
     2ILOOP,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 CHSYM(8)
      CHARACTER*2 SYMBOL(100)
      LOGICAL TRIAT
      DIMENSION NDUMP(NVSYM,ILOOP),EVAL(MAXDMP,MAXSYM,1)
      DIMENSION XK(MAXDMP,MAXDMP)
      DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,1),XA(IDIML,IDIMR)
      DIMENSION TEMP(ISIZEL,1)
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NVVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/DIPNO/NUMDIP
      COMMON/TRIATO/TRIAT
      COMMON/REACTL/JREACT
      COMMON/FILASS/IOUT,INP
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LLDUMP
C**TEMPORARY
C     WRITE(IOUT,*)'DIPTOT INPUT PARAMETERS'
C     WRITE(IOUT,*)'NDUMP,NVSYM,MAXSYM,MAXDMP,MAXCI,LDUMP,ILOOP,IND'
C     WRITE(IOUT,*)NDUMP,NVSYM,MAXSYM,MAXDMP,MAXCI,LDUMP,ILOOP,IND
C     WRITE(IOUT,*)'MSL,MSR = ',MSL,MSR
C     WRITE(IOUT,*)'IDIP,JDIP = ',IDIP,JDIP
C     WRITE(IOUT,*)'IDIML,IDIMR = ',IDIML,IDIMR
C     WRITE(IOUT,*)'ISIZEL,ISIZER = ',ISIZEL,ISIZER
C     WRITE(IOUT,*)'FIRST LHS COEFF.'
C     WRITE(IOUT,*)(VCI(I,1,MSL,1),I=1,ISIZEL)
C     WRITE(IOUT,*)'LAST LHS COEFF.'
C     WRITE(IOUT,*)(VCI(I,NDUMP(MSL,1),MSL,1),I=1,ISIZEL)
C     WRITE(IOUT,*)'FIRST RHS COEFF.'
C     WRITE(IOUT,*)(VCI(I,1,MSR,1),I=1,ISIZER)
C     WRITE(IOUT,*)'LAST RHS COEFF.'
C     WRITE(IOUT,*)(VCI(I,NDUMP(MSR,1),MSR,1),I=1,ISIZER)
C**TEMPORARY
101   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1',1X,I5,' FUNCTIONS',/)
102   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2',1X,I5,' FUNCTIONS',/)
103   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1',1X,I5,' FUNCTIONS',/)
104   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2',1X,I5,' FUNCTIONS',/)
105   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1g',1X,I5,' FUNCTIONS',/)
106   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2g',1X,I5,' FUNCTIONS',/)
107   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1g',1X,I5,' FUNCTIONS',/)
108   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2g',1X,I5,' FUNCTIONS',/)
109   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1u',1X,I5,' FUNCTIONS',/)
110   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2u',1X,I5,' FUNCTIONS',/)
111   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1u',1X,I5,' FUNCTIONS',/)
112   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2u',1X,I5,' FUNCTIONS',/)
201   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1',1X,I5,' FUNCTIONS',/)
202   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2',1X,I5,' FUNCTIONS',/)
203   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1',1X,I5,' FUNCTIONS',/)
204   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2',1X,I5,' FUNCTIONS',/)
205   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1g',1X,I5,' FUNCTIONS',/)
206   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2g',1X,I5,' FUNCTIONS',/)
207   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1g',1X,I5,' FUNCTIONS',/)
208   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2g',1X,I5,' FUNCTIONS',/)
209   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1u',1X,I5,' FUNCTIONS',/)
210   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2u',1X,I5,' FUNCTIONS',/)
211   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1u',1X,I5,' FUNCTIONS',/)
212   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2u',1X,I5,' FUNCTIONS',/)
300   FORMAT(5D14.6)
301   FORMAT(//,1X,'X-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
302   FORMAT(//,1X,'Y-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
303   FORMAT(//,1X,'Z-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
304   FORMAT(//,1X,'EXPECTATION VALUES OF Q FOR SYMMETRY ',A3,/)
305   FORMAT(//,1X,'EXPECTATION VALUES OF Q**2 FOR SYMMETRY ',A3,/)
306   FORMAT(1X,D14.6,5X,10(F5.2,1X),/,20X,10(F5.2,1X),/)
307   FORMAT(//,1X,'USER-DEFINED PROPERTIES FOR SYMMETRY ',A3,/)
308   FORMAT(//,1X,'FRANCK-CONDON FACTORS FOR SYMMETRY ',A3,/)
309   FORMAT(/,1X,'LEFT-HAND FUNCTION',I5,': ',D14.6)
401   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A',1X,I5,' FUNCTIONS',/)
402   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B',1X,I5,' FUNCTIONS',/)
501   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A',1X,I5,' FUNCTIONS',/)
502   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B',1X,I5,' FUNCTIONS',/)
C**RHS
C**CALL MATRIX MULT. ROUTINE MXMA TO SET UP TEMP(IY,I2)
      IF(LDUMP.EQ.6)THEN
        DO I=1,ISIZEL
          READ(IND)XA
          CALL DGEMM('T','N',1,NDUMP(MSR,1),ISIZER,1.0D0,
     &    XA(1,1),IDIML,VCI(1,1,1,1),MAXCI,0.0D0,TEMP(I,1),ISIZEL)
        END DO
      ELSE
        DO I=1,ISIZEL
          READ(IND)XA
C**TEMPORARY
C     IF(I.EQ.1)WRITE(IOUT,*)'FIRST COLUMN XA'
C     IF(I.EQ.ISIZEL)WRITE(IOUT,*)'LAST COLUMN XA'
C     IF(I.EQ.1.OR.I.EQ.ISIZEL)WRITE(IOUT,*)(XA(J,1),J=1,ISIZER)
C**TEMPORARY
          CALL DGEMM('T','N',1,NDUMP(MSR,1),ISIZER,1.0D0,
     &    XA(1,1),IDIML,VCI(1,1,MSR,1),MAXCI,0.0D0,TEMP(I,1),ISIZEL)
        END DO
      END IF
      NDUMPL=NDUMP(MSL,1)
      IF(JDUMP(MSL).NE.0.AND.LDUMP.EQ.1)NDUMPL=IABS(JDUMP(MSL))
      IF(NDUMPL.GT.NDUMP(MSL,1))NDUMPL=NDUMP(MSL,1)
      IF(LDUMP.EQ.1)THEN
C**LHS
C**CALL MXMA TO MULT. TEMP() BY LHS CFS
        CALL DGEMM('T','N',NDUMPL,NDUMP(MSR,1),ISIZEL,1.0D0,
     &   VCI(1,1,MSL,1),MAXCI,TEMP,ISIZEL,0.0D0,XK(1,1),MAXDMP)
C**WRITE LHS SYMMETRY AND ENERGIES
        IF(NVSYM.EQ.8)THEN
          WRITE(IOUT,*)'****** USES C2V + INVERSION TERMINOLOGY ******'
          WRITE(IOUT,*)
          IF(MSL.EQ.1)WRITE(IOUT,105)NDUMPL
          IF(MSL.EQ.2)WRITE(IOUT,106)NDUMPL
          IF(MSL.EQ.3)WRITE(IOUT,107)NDUMPL
          IF(MSL.EQ.4)WRITE(IOUT,108)NDUMPL
          IF(MSL.EQ.5)WRITE(IOUT,109)NDUMPL
          IF(MSL.EQ.6)WRITE(IOUT,110)NDUMPL
          IF(MSL.EQ.7)WRITE(IOUT,111)NDUMPL
          IF(MSL.EQ.8)WRITE(IOUT,112)NDUMPL
        ELSEIF(NVSYM.EQ.4)THEN
          IF(MSL.EQ.1)WRITE(IOUT,101)NDUMPL
          IF(MSL.EQ.2)WRITE(IOUT,102)NDUMPL
          IF(MSL.EQ.3)WRITE(IOUT,103)NDUMPL
          IF(MSL.EQ.4)WRITE(IOUT,104)NDUMPL
        ELSE
          IF(MSL.EQ.1)WRITE(IOUT,401)NDUMPL
          IF(MSL.EQ.2)WRITE(IOUT,402)NDUMPL
        END IF
        WRITE(IOUT,300)(EVAL(I,MSL,1)*WAVENM,I=1,NDUMPL)
C**WRITE RHS SYMMETRY AND ENERGIES
        IF(NVSYM.EQ.8)THEN
          IF(MSR.EQ.1)WRITE(IOUT,205)NDUMP(MSR,1)
          IF(MSR.EQ.2)WRITE(IOUT,206)NDUMP(MSR,1)
          IF(MSR.EQ.3)WRITE(IOUT,207)NDUMP(MSR,1)
          IF(MSR.EQ.4)WRITE(IOUT,208)NDUMP(MSR,1)
          IF(MSR.EQ.5)WRITE(IOUT,209)NDUMP(MSR,1)
          IF(MSR.EQ.6)WRITE(IOUT,210)NDUMP(MSR,1)
          IF(MSR.EQ.7)WRITE(IOUT,211)NDUMP(MSR,1)
          IF(MSR.EQ.8)WRITE(IOUT,212)NDUMP(MSR,1)
        ELSEIF(NVSYM.EQ.4)THEN
          IF(MSR.EQ.1)WRITE(IOUT,201)NDUMP(MSR,1)
          IF(MSR.EQ.2)WRITE(IOUT,202)NDUMP(MSR,1)
          IF(MSR.EQ.3)WRITE(IOUT,203)NDUMP(MSR,1)
          IF(MSR.EQ.4)WRITE(IOUT,204)NDUMP(MSR,1)
        ELSE
          IF(MSR.EQ.1)WRITE(IOUT,501)NDUMP(MSR,1)
          IF(MSR.EQ.2)WRITE(IOUT,502)NDUMP(MSR,1)
        END IF
        WRITE(IOUT,300)(EVAL(I,MSR,1)*WAVENM,I=1,NDUMP(MSR,1))
C**WRITE DIPOLE COMPONENT
        IF(JDIP.EQ.1)WRITE(IOUT,301),CHSYM(IDIP)
        IF(JDIP.EQ.2)WRITE(IOUT,302),CHSYM(IDIP)
        IF(JDIP.EQ.3)WRITE(IOUT,303),CHSYM(IDIP)
C**WRITE MATRIX
        DO ILHS=1,NDUMPL
          WRITE(IOUT,309)ILHS,EVAL(ILHS,MSL,1)*WAVENM
          WRITE(IOUT,300)(XK(ILHS,IRHS),IRHS=1,NDUMP(MSR,1))
          WRITE(IOUT,*)
        END DO
      ELSE
        NUMST=1
        IF(TRIAT)NUMST=2
        IF(LDUMP.LT.6)THEN
          DO ILHS=1,NDUMP(MSL,1)
            Z=0
            DO IRHS=1,ISIZEL
              Z=Z+VCI(IRHS,ILHS,MSL,1)*TEMP(IRHS,ILHS)
            END DO
            XK(ILHS,JDIP)=Z
          END DO
          DO I=1,NWSYM
            DO J=1,NSYM(I)
              IF(JDIP.EQ.ISYM(I,J))N=I
            END DO
          END DO
          IF(JDIP.EQ.NUMDIP)THEN
            IF(LDUMP.EQ.2)WRITE(IOUT,304)CHSYM(MSL)
            IF(LDUMP.EQ.3)WRITE(IOUT,305)CHSYM(MSL)
            IF(LDUMP.EQ.5)WRITE(IOUT,307)CHSYM(MSL)
            DO ILHS=1,NDUMP(MSL,1)
              WRITE(IOUT,306)EVAL(ILHS,MSL,1)*WAVENM,(XK(ILHS,IRHS),
     1        IRHS=NUMST,NUMDIP)
            END DO
          END IF
        ELSE
C**LHS
C**CALL MXMA TO MULT. TEMP() BY LHS CFS
          CALL DGEMM('T','N',NDUMP(MSL,2),NDUMP(MSR,1),ISIZEL,
     &    1.0D0,VCI(1,1,1,2),MAXCI,TEMP,ISIZEL,0.0D0,XK(1,1),MAXDMP)
C**WRITE LHS SYMMETRY AND ENERGIES
          IF(NVSYM.EQ.8)THEN
            IF(MSL.EQ.1)WRITE(IOUT,105)NDUMP(MSL,2)
            IF(MSL.EQ.2)WRITE(IOUT,106)NDUMP(MSL,2)
            IF(MSL.EQ.3)WRITE(IOUT,107)NDUMP(MSL,2)
            IF(MSL.EQ.4)WRITE(IOUT,108)NDUMP(MSL,2)
            IF(MSL.EQ.5)WRITE(IOUT,109)NDUMP(MSL,2)
            IF(MSL.EQ.6)WRITE(IOUT,110)NDUMP(MSL,2)
            IF(MSL.EQ.7)WRITE(IOUT,111)NDUMP(MSL,2)
            IF(MSL.EQ.8)WRITE(IOUT,112)NDUMP(MSL,2)
          ELSEIF(NVSYM.EQ.4)THEN
            IF(MSL.EQ.1)WRITE(IOUT,101)NDUMP(MSL,2)
            IF(MSL.EQ.2)WRITE(IOUT,102)NDUMP(MSL,2)
            IF(MSL.EQ.3)WRITE(IOUT,103)NDUMP(MSL,2)
            IF(MSL.EQ.4)WRITE(IOUT,104)NDUMP(MSL,2)
          ELSE
            IF(MSL.EQ.1)WRITE(IOUT,401)NDUMP(MSL,2)
            IF(MSL.EQ.2)WRITE(IOUT,402)NDUMP(MSL,2)
          END IF
          WRITE(IOUT,300)(EVAL(I,MSL,2)*WAVENM,I=1,NDUMP(MSL,2))
C**WRITE RHS SYMMETRY AND ENERGIES
          IF(NVSYM.EQ.8)THEN
            IF(MSR.EQ.1)WRITE(IOUT,205)NDUMP(MSR,1)
            IF(MSR.EQ.2)WRITE(IOUT,206)NDUMP(MSR,1)
            IF(MSR.EQ.3)WRITE(IOUT,207)NDUMP(MSR,1)
            IF(MSR.EQ.4)WRITE(IOUT,208)NDUMP(MSR,1)
            IF(MSR.EQ.5)WRITE(IOUT,209)NDUMP(MSR,1)
            IF(MSR.EQ.6)WRITE(IOUT,210)NDUMP(MSR,1)
            IF(MSR.EQ.7)WRITE(IOUT,211)NDUMP(MSR,1)
            IF(MSR.EQ.8)WRITE(IOUT,212)NDUMP(MSR,1)
          ELSEIF(NVSYM.EQ.4)THEN
            IF(MSR.EQ.1)WRITE(IOUT,201)NDUMP(MSR,1)
            IF(MSR.EQ.2)WRITE(IOUT,202)NDUMP(MSR,1)
            IF(MSR.EQ.3)WRITE(IOUT,203)NDUMP(MSR,1)
            IF(MSR.EQ.4)WRITE(IOUT,204)NDUMP(MSR,1)
          ELSE
            IF(MSR.EQ.1)WRITE(IOUT,501)NDUMP(MSR,1)
            IF(MSR.EQ.2)WRITE(IOUT,502)NDUMP(MSR,1)
          END IF
          WRITE(IOUT,300)(EVAL(I,MSR,1)*WAVENM,I=1,NDUMP(MSR,1))
C**WRITE FRANCK-CONDON FACTORS
          WRITE(IOUT,308)CHSYM(MSL)
          DO ILHS=1,NDUMP(MSL,2)
            WRITE(IOUT,309)ILHS,EVAL(ILHS,MSL,2)*WAVENM
            WRITE(IOUT,300)(XK(ILHS,IRHS),IRHS=1,NDUMP(MSR,1))
            WRITE(IOUT,*)
          END DO
        END IF
      END IF
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE TRANVB(NDUMP,NVSYM,MAXSYM,XK,MAXDMP,VCI,MAXCI,XA,
     1IDIML,IDIMR,TEMP,TEMP1,EVAL,ILOOP,JSTORE,J21MAX,JLEFT,IGETL,
     2JRIGHT,IGETR,IND,INDDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*3 CHSYM(8)
      CHARACTER*2 SYMBOL(100)
      LOGICAL TRIAT
      DIMENSION NDUMP(MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION EVAL(MAXDMP,MAXSYM,ILOOP,JSTORE,J21MAX)
C     DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION VCI(MAXCI,MAXDMP,MAXSYM,ILOOP,JSTORE)
      DIMENSION XK(MAXDMP*NVSYM,MAXDMP*NVSYM),XA(IDIML,IDIMR)
      DIMENSION TEMP(IDIML,1),TEMP1(MAXCI)
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/FSYMM/NFTOT(10,2)
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/DIPNO/NUMDIP
C**RPH ODD K
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU,IFLAUD
      COMMON/REACTL/JREACT
C**RPH ODD K
      COMMON/FILASS/IOUT,INP
C**RPH ODD K
      COMMON/DUMP/JDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
C**RPH ODD K
      COMMON/TRIATO/TRIAT
      COMMON/AXES/MX(3),MXDIP(5),MXROT(3),ISYMT
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/MATRIX/NVAL,NVALR,KSTEP,KSIGN,NVALCF
101   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1',1X,I5,' FUNCTIONS',/)
102   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2',1X,I5,' FUNCTIONS',/)
103   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1',1X,I5,' FUNCTIONS',/)
104   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2',1X,I5,' FUNCTIONS',/)
105   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1g',1X,I5,' FUNCTIONS',/)
106   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2g',1X,I5,' FUNCTIONS',/)
107   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1g',1X,I5,' FUNCTIONS',/)
108   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2g',1X,I5,' FUNCTIONS',/)
109   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A1u',1X,I5,' FUNCTIONS',/)
110   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B2u',1X,I5,' FUNCTIONS',/)
111   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B1u',1X,I5,' FUNCTIONS',/)
112   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A2u',1X,I5,' FUNCTIONS',/)
201   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1',1X,I5,' FUNCTIONS',/)
202   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2',1X,I5,' FUNCTIONS',/)
203   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1',1X,I5,' FUNCTIONS',/)
204   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2',1X,I5,' FUNCTIONS',/)
205   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1g',1X,I5,' FUNCTIONS',/)
206   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2g',1X,I5,' FUNCTIONS',/)
207   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1g',1X,I5,' FUNCTIONS',/)
208   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2g',1X,I5,' FUNCTIONS',/)
209   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A1u',1X,I5,' FUNCTIONS',/)
210   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B2u',1X,I5,' FUNCTIONS',/)
211   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B1u',1X,I5,' FUNCTIONS',/)
212   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A2u',1X,I5,' FUNCTIONS',/)
300   FORMAT(5D14.6)
301   FORMAT(//,1X,'X-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
302   FORMAT(//,1X,'Y-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
303   FORMAT(//,1X,'Z-COMPONENT OF DIPOLE, SYMMETRY ',A3,/)
304   FORMAT(//,1X,'EXPECTATION VALUES OF Q FOR SYMMETRY ',A3,/)
305   FORMAT(//,1X,'EXPECTATION VALUES OF Q**2 FOR SYMMETRY ',A3,/)
306   FORMAT(1X,D14.6,5X,10(F5.2,1X),/,20X,10(F5.2,1X),/)
307   FORMAT(//,1X,'USER-DEFINED PROPERTIES FOR SYMMETRY ',A3,/)
308   FORMAT(//,1X,'FRANCK-CONDON FACTORS FOR SYMMETRY ',A3,/)
309   FORMAT(/,1X,'LEFT-HAND FUNCTION',I5,': ',D14.6)
401   FORMAT(//,1X,'LEFT-HAND SYMMETRY: A',1X,I5,' FUNCTIONS',/)
402   FORMAT(//,1X,'LEFT-HAND SYMMETRY: B',1X,I5,' FUNCTIONS',/)
501   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: A',1X,I5,' FUNCTIONS',/)
502   FORMAT(//,1X,'RIGHT-HAND SYMMETRY: B',1X,I5,' FUNCTIONS',/)

      WRITE(IOUT,*)'Calculating TRANVB'
      CALL TIMIT(1)
      CALL FLUSH(IOUT)

      IF(LDUMP.EQ.9)RETURN
      MPUTL=195+5*(IGETL-1)
      MPUTR=195+5*(IGETR-1)
      NUMST=1
      IF(TRIAT)NUMST=2
C**RPH ODD K
      KLOOP=1
      IF(JREACT.GT.0.AND.(LDUMP.EQ.7.OR.LDUMP.EQ.8))KLOOP=IFLAUD
C**RPH ODD K
      NJMAXR=2*JRIGHT+1
      NJMAXL=2*JLEFT+1
C**RHS Ka
      DO LLR=1,NJMAXR,KSTEP
        KAR=LLR/2
C**RPH ODD K
        KKR=1+MOD(KAR,2)
C**RPH ODD K
        REWIND MPUTR
C**READ RHS COEFFS. FOR THIS LLR
        MMSS=NVSYM
        DO IVSYM=1,MMSS
          READ(MPUTR)JSIZE
          IF(JSIZE.NE.0)THEN
            DO KROT=1,NJMAXR,KSTEP
              JJDUMP=NDUMP(IVSYM,1,IGETR,KROT)
              DO J=1,JJDUMP
                IF(KROT.LE.LLR)THEN
                  READ(MPUTR)(VCI(IY,J,IVSYM,1,2),IY=1,JSIZE)
                ELSE
                  READ(MPUTR)(TEMP1(IY),IY=1,JSIZE)
                END IF
              END DO
            END DO
          END IF
        END DO
C**LHS Ka
        DO LLL=1,NJMAXL,KSTEP
          KAL=LLL/2
C**RPH ODD K
          KKL=1+MOD(KAL,2)
C**RPH ODD K
C**ONLY ALLOW Ka -> Ka AND Ka-1 -> Ka
          IF(IABS(KAL-KAR).GT.1.AND.LDUMP.NE.8)GO TO 90000
          IF(IABS(KAL-KAR).GT.2.AND.LDUMP.EQ.8)GO TO 90000
          REWIND MPUTL
C**READ RHS COEFFS. FOR THIS LLL
          MMSS=MVSYM
          IF(JLEFT.GT.0)MMSS=NVSYM
          DO IYSYM=1,MMSS
            IF(JLEFT.EQ.0)THEN
              IVSYM=MWSYM(IYSYM)
            ELSE
              IVSYM=IYSYM
            END IF
            READ(MPUTL)JSIZE
            IF(JSIZE.NE.0)THEN
              DO KROT=1,NJMAXL,KSTEP
                JJDUMP=NDUMP(IVSYM,1,IGETL,KROT)
                DO J=1,JJDUMP
                  IF(KROT.LE.LLL)THEN
                    READ(MPUTL)(VCI(IY,J,IVSYM,1,1),IY=1,JSIZE)
                  ELSE
                    READ(MPUTL)(TEMP1(IY),IY=1,JSIZE)
                  END IF
                END DO
              END DO
            END IF
          END DO
C**PA X,Y,Z COMPONENTS
          DO JDIP=NUMST,NUMDIP
            INDIP=IND+JDIP
            REWIND INDIP
            JNDIP=INDDIP+JDIP
C**RELATE TO SYMMETRY AXES
            IDIP=MXDIP(JDIP)
C**RHS VIB SYM
            IROFF=0
            DO MSR=1,NVSYM
              MSRR=MSR
              IF(MOD(KAR,2).NE.0)MSRR=ISYMP(MSR,ISYMT)
C**MSRR IS ACTUAL SYMMETRY
              NDUMPR=NDUMP(MSR,1,IGETR,LLR)
              ISIZER=NFTOT(MSR,1)
C**MSR IS STORED SYMMETRY
              IF(ISIZER.EQ.0)GO TO 9002
C**LHS VIB SYM
              ILOFF=0
              DO MSL=1,NVSYM
                MSLL=MSL
                IF(MOD(KAL,2).NE.0)MSLL=ISYMP(MSL,ISYMT)
C**MSLL IS ACTUAL SYMMETRY
                NDUMPL=NDUMP(MSL,1,IGETL,LLL)
                ISIZEL=NFTOT(MSL,1)
C**MSL IS STORED SYMMETRY
                IF(ISIZEL.EQ.0)GO TO 9001
C*****************************************************************
C*****************************************************************
C**NEEDS SELECTION CRITERION HERE FOR SYMMETRY-ALLOWED DIPOLES
C*****************************************************************
C*****************************************************************
C**
C               ICROSS=ISYMP(MSLL,MSRR)
C               IF(ISYMP(ICROSS,IDIP).NE.1)GO TO 9001
C**FIND RELEVANT INTEGRAL THIS IDIP,MSR,MSL,KKR,KKL
C**
C**RPH ODD K
C**KLOOP=1 - COS,SIN(M.TAU)
C**KLOOP=2 - SIN,COS(M.TAU/2)
                DO 9000 KROTR=1,KLOOP
                KARR=KROTR/2
                MSSR=MSR
                IF(MOD(KARR,2).NE.0)MSSR=ISYMP(MSR,ISYMT)
                DO 9000 KROTL=1,KLOOP
                KALL=KROTL/2
                MSSL=MSL
                IF(MOD(KALL,2).NE.0)MSSL=ISYMP(MSL,ISYMT)
C**RPH ODD K
C*****************************************************************
C*****************************************************************
C**NEEDS SELECTION CRITERION HERE FOR SYMMETRY-ALLOWED DIPOLES
C*****************************************************************
C*****************************************************************
                IF(.NOT.TRIAT)THEN
CCCC              ICROSS=ISYMP(MSL,MSR)
                  JCROSS=ISYMP(MSSL,MSSR)
                  IF(ISYMP(JCROSS,IDIP).NE.1)GO TO 8999
                ELSE
C**TEST IF C2V
                  IF(NVSYM.EQ.4.OR.(NVSYM.EQ.2.AND.TRIAT))THEN
C**A1 COMPONENT
                    IF(IDIP.EQ.1)THEN
                      IF(MSL.NE.MSR)GO TO 8999
                    END IF
C**B2 COMPONENT
                    IF(IDIP.EQ.2)THEN
                      IF(MSR.EQ.3.AND.MSL.EQ.2)GO TO 8999
                      IF(MSR.EQ.2.AND.MSL.EQ.3)GO TO 8999
                      IF(MSL.NE.MSR-1.AND.MSR.NE.MSL-1)GO TO 8999
                    END IF
C**B1 COMPONENT
                    IF(IDIP.EQ.3)THEN
                      IF(MSL.NE.MSR-2.AND.MSR.NE.MSL-2)GO TO 8999
                    END IF
                  END IF
C**TEST IF CS (OR C2)
                  IF((NVSYM.EQ.2.AND..NOT.TRIAT).OR.
     1               (NVSYM.EQ.1.AND.TRIAT))THEN
C**A' COMPONENTS
                    IF(IDIP.EQ.1.OR.IDIP.EQ.2)THEN
                      IF(MSL.NE.MSR)GO TO 8999
                    END IF
C**A" COMPONENTS
                    IF(IDIP.EQ.3)THEN
                      IF(MSL.EQ.MSR)GO TO 8999
                    END IF
                  END IF
                END IF
C
C**RPH ODD K
                IF(KLOOP.EQ.2.AND.(KROTL.NE.KKL.OR.KROTR.NE.KKR))THEN
C               IF(KROTL.NE.KKL.OR.KROTR.NE.KKR)THEN
                  DO I=1,ISIZEL
                    READ(INDIP)(XA(J,1),J=1,ISIZER)
                  END DO
                  GO TO 8999
                END IF
C**RPH ODD K
C**RHS
C**CALL MATRIX MULT. ROUTINE MXMA TO SET UP TEMP(IY,I2)
      DO I=1,ISIZEL
        READ(INDIP)(XA(J,1),J=1,ISIZER)
        CALL DGEMM('T','N',1,NDUMPR,ISIZER,1.0D0,XA(1,1),IDIML,
C    &  VCI(1,1,MSR,1,IGETR,LLR),MAXCI,0.0D0,TEMP(I,1),IDIML)
     &  VCI(1,1,MSR,1,2),MAXCI,0.0D0,TEMP(I,1),IDIML)
      END DO
C**LHS
C**CALL MXMA TO MULT. TEMP() BY LHS CFS
      CALL DGEMM('T','N',NDUMPL,NDUMPR,ISIZEL,1.0D0,
C    &VCI(1,1,MSL,1,IGETL,LLL),MAXCI,TEMP,IDIML,0.0D0,
     &VCI(1,1,MSL,1,1),MAXCI,TEMP,IDIML,0.0D0,
     &XK(1+ILOFF,1+IROFF),MAXDMP*NVSYM)

C               DO I=1,NDUMPR
C                 WRITE(JNDIP)(XK(J,I),J=1,NDUMPL)
C               END DO

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C**TEMPORARY COMMENT
C               IF(ISYMP(ICROSS,IDIP).NE.1)GO TO 8999
C**TEMPORARY COMMENT
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C**TEMPORARY
C**WRITE LHS SYMMETRY AND ENERGIES
        IF(NVSYM.EQ.8)THEN
          IF(MSLL.EQ.1)WRITE(IOUT,105)NDUMPL
          IF(MSLL.EQ.2)WRITE(IOUT,106)NDUMPL
          IF(MSLL.EQ.3)WRITE(IOUT,107)NDUMPL
          IF(MSLL.EQ.4)WRITE(IOUT,108)NDUMPL
          IF(MSLL.EQ.5)WRITE(IOUT,109)NDUMPL
          IF(MSLL.EQ.6)WRITE(IOUT,110)NDUMPL
          IF(MSLL.EQ.7)WRITE(IOUT,111)NDUMPL
          IF(MSLL.EQ.8)WRITE(IOUT,112)NDUMPL
        ELSE
          IF(NVSYM.EQ.4.OR.(NVSYM.EQ.2.AND.TRIAT))THEN
            IF(MSL.EQ.1)WRITE(IOUT,101)NDUMPL
            IF(MSL.EQ.2)WRITE(IOUT,102)NDUMPL
            IF(MSL.EQ.3)WRITE(IOUT,103)NDUMPL
            IF(MSL.EQ.4)WRITE(IOUT,104)NDUMPL
          ELSE
            IF(MSL.EQ.1)WRITE(IOUT,401)NDUMPL
            IF(MSL.EQ.2)WRITE(IOUT,402)NDUMPL
          END IF
        END IF
C       WRITE(IOUT,300)(EVAL(I,MSL,1,IGETL,LLL)*WAVENM,I=1,NDUMPL)
        WRITE(IOUT,300)(EVAL(I,MSL,1,IGETL,LLL)*WAVENM,I=1,10)
C**TEMPORARY
CC    WRITE(IOUT,100)(VCI(I,1,MSL,1,1),I=1,10)
100   FORMAT(10F8.4)
C**TEMPORARY
C**WRITE RHS SYMMETRY AND ENERGIES
        IF(NVSYM.EQ.8)THEN
          IF(MSRR.EQ.1)WRITE(IOUT,205)NDUMPR
          IF(MSRR.EQ.2)WRITE(IOUT,206)NDUMPR
          IF(MSRR.EQ.3)WRITE(IOUT,207)NDUMPR
          IF(MSRR.EQ.4)WRITE(IOUT,208)NDUMPR
          IF(MSRR.EQ.5)WRITE(IOUT,209)NDUMPR
          IF(MSRR.EQ.6)WRITE(IOUT,210)NDUMPR
          IF(MSRR.EQ.7)WRITE(IOUT,211)NDUMPR
          IF(MSRR.EQ.8)WRITE(IOUT,212)NDUMPR
        ELSE
          IF(NVSYM.EQ.4.OR.(NVSYM.EQ.2.AND.TRIAT))THEN
            IF(MSR.EQ.1)WRITE(IOUT,201)NDUMPR
            IF(MSR.EQ.2)WRITE(IOUT,202)NDUMPR
            IF(MSR.EQ.3)WRITE(IOUT,203)NDUMPR
            IF(MSR.EQ.4)WRITE(IOUT,204)NDUMPR
          ELSE
            IF(MSR.EQ.1)WRITE(IOUT,501)NDUMPR
            IF(MSR.EQ.2)WRITE(IOUT,502)NDUMPR
          END IF
        END IF
CC      WRITE(IOUT,300)(EVAL(I,MSR,1,IGETR,LLR)*WAVENM,I=1,NDUMPR)
C       WRITE(IOUT,300)(EVAL(I,MSR,1,IGETR,LLR)*WAVENM,I=1,10)
C**TEMPORARY
CC    WRITE(IOUT,100)(VCI(I,1,MSR,1,2),I=1,10)
C**TEMPORARY
C**WRITE DIPOLE COMPONENT
        IF(JDIP.EQ.1)WRITE(IOUT,301),CHSYM(IDIP)
        IF(JDIP.EQ.2)WRITE(IOUT,302),CHSYM(IDIP)
        IF(JDIP.EQ.3)WRITE(IOUT,303),CHSYM(IDIP)
C**WRITE MATRIX
CC      DO ILHS=1,NDUMPL
C       DO ILHS=1,10
CCCC      WRITE(IOUT,309)ILHS,EVAL(ILHS,MSL,1,IGETL)*WAVENM
C         WRITE(IOUT,300)(XK(ILHS+ILOFF,IRHS+IROFF),
CC   1    IRHS=1,NDUMPR)
C    1    IRHS=1,10)
CCCC      WRITE(IOUT,*)
C       END DO
      CALL FLUSH(IOUT)
C**TEMPORARY

8999            CONTINUE
C**RPH ODD K
9000            CONTINUE
C**RPH ODD K
9001            CONTINUE
                ILOFF=ILOFF+NDUMPL
              END DO
9002          CONTINUE
              IROFF=IROFF+NDUMPR
            END DO
            DO I=1,IROFF
              WRITE(JNDIP)(XK(J,I),J=1,ILOFF)
            END DO
          END DO
90000     CONTINUE
        END DO
      END DO

      CALL TIMIT(3)
      CALL FLUSH(IOUT)

      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE TRANRT(W,NDUMP,IDUMP,NVSYM,MAXSYM,XK,MAXDMP,RCI,NRSYM,
     1MAXRT,XA,IDIML,IDIMR,TEMP,RVAL,ILOOP,JSTORE,J21MAX,JLEFT,IGETL,
     2JRIGHT,IGETR,WRK,DDPM,KSSX,IND,NMODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL TRIAT
C**************************************************ASSIGN TOTAL STORAGE
      DIMENSION W(1)
      COMMON/CMEMO/NADD,NSEG,KFREE,LFREE,KINF,MADD
C**CURRENT SETTINGS
      COMMON/CADDR/
     &LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LOLDH,LXK,LOLDXQ,LXW,LNBF,
     1LMBF,LSCF,LSX,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
     2LAB,LB,LAA,LBB,LQQ,LMVB,LH,LXQ,LTEMP,LCONTR,
     3LDUM2A(2),LV1,LV2,LV3,LV4,LDUM2B(4),
     4LDUM3A(3),LXK0,LXL0,LXN0,LXM0,LDUM3B(3),
     5LISIZE,LW21,LSS,LSSX,LX21,LE21,LIDUMP,LNDUMP,LIP,LVCI,
     6LNFC,LRCI,LRVAL,LWRK,LDDPM,LXDIP,LRASS,LDUM6(3),
     7LDUM7(10),
     8LXA,LXA1,LXA2,LXA3,LXA4,LEVAL,LIP1,LIP2,LIP3,LIP4,
     9LPD1,LPD2,LPD3,LPD4,LPD5,LPD6,LPD7,LMXBAS,LKDUMP,LNVF,
     1LMODNT,LJP1,LJP2,LJP3,LJP4,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,
     2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
     3LDUM8(10),
     4LDUM9(10),
     5LDUM10(10),
     6LDUM11(10),
     7LDUM12(4),LXP,LJP6,LXPLOT,LYPLOT,LFPLOT
C**CURRENT SETTINGS
C**************************************************ASSIGN TOTAL STORAGE
      DIMENSION NDUMP(MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION IDUMP(MAXSYM,ILOOP,JSTORE,J21MAX)
      DIMENSION RVAL(MAXDMP,NRSYM,ILOOP,JSTORE)
      DIMENSION RCI(MAXRT,MAXDMP,NRSYM,ILOOP,JSTORE)
      DIMENSION XK(MAXDMP*NVSYM,MAXDMP*NVSYM),XA(IDIML,IDIMR)
      DIMENSION TEMP(IDIML,1),WRK(1)
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/FSYMM/NFTOT(10,2),NRTOT(10,2,2)
      COMMON/SYMM/MRSYM
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/SYMM0/MVSYM0
      COMMON/DIPNO/NUMDIP
      COMMON/FILASS/IOUT,INP
      COMMON/DUMP/JDUMP(10),IIDUMP,KDUMP,MDUMP,LDUMP
      COMMON/TRIATO/TRIAT
      COMMON/AXES/MX(3),MXDIP(5),MXROT(3),ISYMT
      COMMON/REACTL/JREACT
      COMMON/NVALV/NVALV(2)
      COMMON/MATRIX/NVAL,NVALR,KSTEP,KSIGN,NVALCF

      WRITE(IOUT,*)'Calculating TRANRT'
      CALL TIMIT(1)
      CALL FLUSH(IOUT)

C**NUMBER 'Ka' BLOCKS
      NJMAXR=2*JRIGHT+1
      NJMAXL=2*JLEFT+1
C**SIZE OF EACH BLOCK
      NVALVR=NVALV(IGETR)
      NVALVL=NVALV(IGETL)
C**DETERMINE ROTATIONAL SYMMETRIES
      NSYMR=MVSYM
      NSYML=MVSYM
C     WRITE(IOUT,*)'IGETL,IGETR,NVALVL,NVALVR = ',IGETL,IGETR,NVALVL,
C    1NVALVR
C**IF JLEFT=0, NEEDS SPECIAL ACTION (SHOULD BE ALREADY FIXED?)
      IF(JLEFT.EQ.0)NSYML=MVSYM0
C     WRITE(IOUT,*)'NSYML,NSYMR = ',NSYML,NSYMR
C**RHS ROT SYMMETRY
      DO NNSR=1,NSYMR
        NSR=MWSYM(NNSR)
C**NSR IS SEQUENCE OF ROVIBRATIONAL SYMMETRY (EVEN-J)
        JSR=MOD(JRIGHT,2)+1
C       WRITE(IOUT,*)'*********************************'
C       WRITE(IOUT,*)'RIGHT-HAND ROVIBRATIONAL SYMMETRY'
C       WRITE(IOUT,*)'JRIGHT = ',JRIGHT,' SEQUENCE = ',NSR,
C    1  ' ACTUAL = ',ISYMP(NSR,ISYMD(1,JSR))
C**NSRR IS ACTUAL RHS ROVIBRATIONAL SYMMETRY
        NSRR=ISYMP(NSR,ISYMD(1,JSR))
        NDUMPR=IDUMP(NSR,1,IGETR,1)
        ISIZER=NRTOT(NSR,1,IGETR)
        IF(ISIZER.EQ.0)GO TO 9002
C**LHS ROT SYMMETRY
        DO NNSL=1,NSYML
          NSL=MWSYM(NNSL)
C**NSL IS SEQUENCE OF ROVIBRATIONAL SYMMETRY (EVEN-J)
          JSL=MOD(JLEFT,2)+1
C         WRITE(IOUT,*)
C         WRITE(IOUT,*)'LEFT-HAND ROVIBRATIONAL SYMMETRY'
C         WRITE(IOUT,*)'JLEFT = ',JLEFT,' SEQUENCE = ',NSL,
C    1    ' ACTUAL = ',ISYMP(NSL,ISYMD(1,JSL))
C**NSLL IS ACTUAL LHS ROVIBRATIONAL SYMMETRY
          NSLL=ISYMP(NSL,ISYMD(1,JSL))
          NDUMPL=IDUMP(NSL,1,IGETL,1)
          ISIZEL=NRTOT(NSL,1,IGETL)
          IF(ISIZEL.EQ.0)GO TO 9001
          IF(LDUMP.EQ.9)GO TO 9005
          REWIND 51
          REWIND 52
          REWIND 53
          REWIND 54
          REWIND 55
C**Changes 'E' - store real & complex parts of R
          CALL MEMO(3,LXA,2*NDUMPL*NDUMPR,LXDIP,2*NVALVL*NVALVR,LTEMP,
     1    MAXDMP*MAXDMP,0,0,0,0)
C**ZEROISE MATRIX FOR THIS RO-VIB SYMMETRY PAIR
          CALL ZERDIP(W(LXA),NDUMPL,NDUMPR)
          IF(TRIAT)THEN
C**START B2 (IF EXISTS)
            IR=2
            IF(NSR.LE.NVSYM)THEN
C**NUMBER 'Ka' BLOCKS
              NJMAXR=JRIGHT+1
C**ROTATION ELEMENTS 1,3,5,...
              KOFFR=1
C**START A1 (A')
              IF(NSR.EQ.1)IR=1
            ELSE
C**NUMBER 'Ka' BLOCKS
              NJMAXR=JRIGHT
C**ROTATION ELEMENTS 2,4,6,...
              KOFFR=2
C**START A1 (A')
              IF(NSR.EQ.NVSYM+1)IR=1
            END IF
          ELSE
            IR0=NSR
            IR=NSR
          END IF
C**RHS Ka - LLR POINTS TO ROT FUNCTION IF > 3 ATOMS
          NOFFR=0
          DO LLR=1,NJMAXR
            KROTR=LLR
1           IF(KROTR.GT.4)THEN
              KROTR=KROTR-4
              GO TO 1
            END IF
            KAR=LLR/2
            IF(.NOT.TRIAT)THEN
              IRR=ISYMP(ISYMD(KROTR,JSR),NSRR)
C**IRR IS ACTUAL VIBRATIONAL SYMMETRY
              IF(MOD(KAR,2).NE.0)IR=ISYMP(IRR,ISYMT)
C**IR IS STORED SYMMETRY
              KSIZER=NFTOT(IR,1)
C**KSIZER IS SIZE THIS VIB BLOCK
C             WRITE(IOUT,*)'RIGHT-HAND VIBRATIONAL SYMMETRY FOR LLR = ',
C    1        LLR
C             WRITE(IOUT,*)'KROTR = ',KROTR,' SEQUENCE ',IR,' ACTUAL ',
C    1        IRR
C             WRITE(IOUT,*)'KSIZER = ',KSIZER
              IF(KSIZER.EQ.0)GO TO 9006
            END IF
            IF(MOD((LLR-1),KSTEP).EQ.0)THEN
              IREADR=1
              LLLR=LLR
            ELSE
              IREADR=0
            END IF
            IF(TRIAT)THEN
              LXR=2*(LLR-1)+KOFFR
            ELSE
              LXR=LLR
            END IF
            IF(TRIAT)THEN
C**START B2 (IF EXISTS)
              IL=2
              IF(NSL.LE.NVSYM)THEN
C**NUMBER 'Ka' BLOCKS
                NJMAXL=JLEFT+1
C**ROTATION ELEMENTS 1,3,5,...
                KOFFL=1
C**START A1 (A')
                IF(NSL.EQ.1)IL=1
              ELSE
C**NUMBER 'Ka' BLOCKS
                NJMAXL=JLEFT
C**ROTATION ELEMENTS 2,4,6,...
                KOFFL=2
C**START A1 (A')
                IF(NSL.EQ.NVSYM+1)IL=1
              END IF
            ELSE
              IL0=NSL
              IL=NSL
            END IF
C**LHS Ka - LLL POINTS TO ROT FUNCTION IF > 3 ATOMS
            NOFFL=0
            DO LLL=1,NJMAXL
              KROTL=LLL
2             IF(KROTL.GT.4)THEN
                KROTL=KROTL-4
                GO TO 2
              END IF
              KAL=LLL/2
              IF(.NOT.TRIAT)THEN
                ILL=ISYMP(ISYMD(KROTL,JSL),NSLL)
C**ILL IS ACTUAL VIBRATIONAL SYMMETRY
                IF(MOD(KAL,2).NE.0)IL=ISYMP(ILL,ISYMT)
C**IL IS STORED SYMMETRY
                KSIZEL=NFTOT(IL,1)
C**KSIZEL IS SIZE THIS VIB BLOCK
C             WRITE(IOUT,*)'LEFT-HAND VIBRATIONAL SYMMETRY FOR LLL = ',
C    1        LLL
C             WRITE(IOUT,*)'KROTL = ',KROTL,' SEQUENCE ',IL,' ACTUAL ',
C    1        ILL
C             WRITE(IOUT,*)'KSIZEL = ',KSIZEL
                IF(KSIZEL.EQ.0)GO TO 9007
              END IF
              IF(MOD((LLL-1),KSTEP).EQ.0)THEN
                IREADL=1
                LLLL=LLL
              ELSE
                IREADL=0
              END IF
              IF(TRIAT)THEN
                LXL=2*(LLL-1)+KOFFL
              ELSE
                LXL=LLL
              END IF
C**ONLY ALLOW Ka -> Ka AND Ka-1 -> Ka
              IF(IABS(KAL-KAR).GT.1.AND.LDUMP.NE.8)GO TO 9000
              IF(IABS(KAL-KAR).GT.2.AND.LDUMP.EQ.8)GO TO 9000
              IDUMPR=0
              DO MSR=1,NVSYM
                IDUMPR=IDUMPR+NDUMP(MSR,1,IGETR,LLLR)
              END DO
              IDUMPL=0
              DO MSL=1,NVSYM
                IDUMPL=IDUMPL+NDUMP(MSL,1,IGETL,LLLL)
              END DO
C**ZEROISE DIPOLE MATRIX
C             CALL ZERDIP(W(LXDIP),NVALVL,NVALVR)
C**PA X,Y,Z COMPONENTS
              NUMST=1
              IF(TRIAT)NUMST=2
              DO JDIP=NUMST,NUMDIP
                INDIP=IND+JDIP
                IF(IREADR.NE.0.AND.IREADL.NE.0)THEN
                  DO I=1,IDUMPR
                    READ(INDIP)(XK(J,I),J=1,IDUMPL)
                  END DO
                END IF
C**RELATE TO SYMMETRY AXES
                IDIP=MXDIP(JDIP)
C**RHS VIB SYM
                IROFF=0
                DO MSR=1,NVSYM
                  MSRR=MSR
                  IF(MOD(KAR,2).NE.0)MSRR=ISYMP(MSR,ISYMT)
C**MSRR IS ACTUAL SYMMETRY
                  MDUMPR=NDUMP(MSR,1,IGETR,LLLR)
                  ISIZER=NFTOT(MSR,1)
C**MSR IS STORED SYMMETRY
                  IF(ISIZER.EQ.0)GO TO 9003
C**LHS VIB SYM
                  ILOFF=0
                  DO MSL=1,NVSYM
                    MSLL=MSL
                    IF(MOD(KAL,2).NE.0)MSLL=ISYMP(MSL,ISYMT)
C**MSLL IS ACTUAL SYMMETRY
                    MDUMPL=NDUMP(MSL,1,IGETL,LLLL)
                    ISIZEL=NFTOT(MSL,1)
C**MSL IS STORED SYMMETRY
                    IF(ISIZEL.EQ.0)GO TO 9004
C*****************************************************************
C*****************************************************************
C**NEEDS SELECTION CRITERION HERE FOR SYMMETRY-ALLOWED DIPOLES
C*****************************************************************
C*****************************************************************
                    IF(.NOT.TRIAT)THEN
CCCC                  ICROSS=ISYMP(MSL,MSR)
                      ICROSS=ISYMP(MSLL,MSRR)
                      IF(ISYMP(ICROSS,IDIP).NE.1)GO TO 9004
                    ELSE
C**TEST IF C2V
                      IF(NVSYM.EQ.4.OR.(NVSYM.EQ.2.AND.TRIAT))THEN
C**A1 COMPONENT
                        IF(IDIP.EQ.1)THEN
                          IF(MSL.NE.MSR)GO TO 9004
                        END IF
C**B2 COMPONENT
                        IF(IDIP.EQ.2)THEN
                          IF(MSR.EQ.3.AND.MSL.EQ.2)GO TO 9004
                          IF(MSR.EQ.2.AND.MSL.EQ.3)GO TO 9004
                          IF(MSL.NE.MSR-1.AND.MSR.NE.MSL-1)GO TO 9004
                        END IF
C**B1 COMPONENT
                        IF(IDIP.EQ.3)THEN
                          IF(MSL.NE.MSR-2.AND.MSR.NE.MSL-2)GO TO 9004
                        END IF
                      END IF
C**TEST IF CS (OR C2)
                      IF((NVSYM.EQ.2.AND..NOT.TRIAT).OR.
     1                   (NVSYM.EQ.1.AND.TRIAT))THEN
C**A' COMPONENTS
                        IF(IDIP.EQ.1.OR.IDIP.EQ.2)THEN
                          IF(MSL.NE.MSR)GO TO 9004
                        END IF
C**A" COMPONENTS
                        IF(IDIP.EQ.3)THEN
                          IF(MSL.EQ.MSR)GO TO 9004
                        END IF
                      END IF
                    END IF
C**READ DIPOLE MATRIX ELEMENTS UNTIL SYMMETRIES MATCH
C                   DO I=1,MDUMPR
C                     READ(INDIP)(XK(J,I),J=1,MDUMPL)
C                   END DO
                    IF(MSLL.NE.ILL.OR.MSRR.NE.IRR)GO TO 9004
C     WRITE(IOUT,*)'DIPOLE SEQUENCE JDIP = ',JDIP,' ACTUAL = ',IDIP
C**ZEROISE DIPOLE MATRIX
                    CALL ZERDIP(W(LXDIP),NVALVL,NVALVR)
C**MULTIPLY DIPOLE MATRIX BY TMX, TMY, TMZ DEPENDING ON COMPONENT
                    CALL XYZDIP(W(LXK),MAXDMP,W(LXDIP),NVALVL,NVALVR,
     1              MDUMPL,MDUMPR,W(LDDPM),KSSX,IL,IR,LXL,LXR,JDIP,
     2              NVSYM,ILOFF,IROFF)
C**MATRIX MULTIPLY (ROTATIONS)
                    CALL MTRDIP(W(LXA),NDUMPL,NDUMPR,W(LTEMP),
     1              W(LXDIP),NVALVL,NVALVR,RCI,MAXRT,MAXDMP,NRSYM,
     2              ILOOP,NSL,NSR,IGETL,IGETR,NOFFL,NOFFR)
9004                CONTINUE
                    ILOFF=ILOFF+MDUMPL
                  END DO
9003              CONTINUE
                  IROFF=IROFF+MDUMPR
                END DO
              END DO
9000          CONTINUE
C***************************************************************
C**UPDATE VIBRATIONAL SYMMETRY FOR NEXT TIME IF REQUIRED (LHS)
C***************************************************************
              IF(TRIAT)THEN
                IL=IL+1
                IF(IL.GT.NVSYM)IL=1
              END IF
              NOFFL=NOFFL+NVALVL
9007          CONTINUE
            END DO
C***************************************************************
C**UPDATE VIBRATIONAL SYMMETRY FOR NEXT TIME IF REQUIRED (RHS)
C*******************************************************
            IF(TRIAT)THEN
              IR=IR+1
              IF(IR.GT.NVSYM)IR=1
            END IF
            NOFFR=NOFFR+NVALVR
9006        CONTINUE
          END DO
C**SQUARE THIS CONTRIBUTION THIS ROTATIONAL SYMMETRY COMBINATION
          CALL SQDIP(W(LXA),NDUMPL,NDUMPR)
9005      CONTINUE
C**WRITE FINAL OUTPUT FILE THIS RO-VIB SYMMETRY COMBINATION
C         CALL FINDIP(JLEFT,JRIGHT,NSL,NSR,RVAL,MAXDMP,NRSYM,ILOOP,
          CALL FINDIP(JLEFT,JRIGHT,NSL,NSR,NSLL,NSRR,RVAL,MAXDMP,NRSYM,
     1    ILOOP,STORE,W(LXA),NDUMPL,NDUMPR,W(LRASS),IGETL,IGETR,NMODE)
          IF(LDUMP.EQ.9)GO TO 9001
C**Changes 'E' - store real & complex parts of R
          CALL MEMO(-3,LXA,2*NDUMPL*NDUMPR,LXDIP,2*NVALVL*NVALVR,LTEMP,
     1    MAXDMP*MAXDMP,0,0,0,0)
9001      CONTINUE
        END DO
9002    CONTINUE
      END DO

      CALL TIMIT(3)
      CALL FLUSH(IOUT)

      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE FACDIP(F,NF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION F(NF)
      F(1)=1
      DO I=2,NF
        I1=I-1
        F(I)=F(I1)*SQRT(1.D0*I1)
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE J0CDIP(RCI,MAXRT,MAXDMP,MAXSYM,ILOOP,JSTORE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION RCI(MAXRT,MAXDMP,MAXSYM,ILOOP,JSTORE)
      DO IX=1,MAXSYM
        DO I=1,MAXDMP
          DO J=1,MAXRT
            IF(J.EQ.I)RCI(J,I,IX,1,1)=1
            IF(J.NE.I)RCI(J,I,IX,1,1)=0
          END DO
        END DO
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE J0EDIP(RVAL,EVAL,MAXDMP,NRSYM,MAXSYM,ILOOP,JSTORE,
     1J21MAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION RVAL(MAXDMP,NRSYM,ILOOP,JSTORE)
      DIMENSION EVAL(MAXDMP,MAXSYM,ILOOP,JSTORE)
      DO IX=1,MAXSYM
        DO I=1,MAXDMP
          RVAL(I,IX,1,1)=EVAL(I,IX,1,1)
C**ZERO POINT DEFINED AS ZERO (FIRST FUNCTION OF FIRST SYMMETRY)
          IF(IX.EQ.1.AND.I.EQ.1)RVAL(1,1,1,1)=0
        END DO
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE J0ADIP(LRASS,LCASS,NMODE,MAXDMP,NRSYM,MAXSYM,JSTORE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION LRASS(2+NMODE,MAXDMP,NRSYM,JSTORE)
      DIMENSION LCASS(2+NMODE,MAXDMP,MAXSYM,JSTORE)
      DO IX=1,MAXSYM
        DO IY=1,MAXDMP
          DO I=1,2+NMODE
            LRASS(I,IY,IX,1)=LCASS(I,IY,IX,1)
          END DO
        END DO
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE ZERDIP(XK,NDIPL,NDIPR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**Changes 'E'
      DIMENSION XK(NDIPL,NDIPR,2)
      DO K=1,2
        DO I=1,NDIPR
          DO J=1,NDIPL
            XK(J,I,K)=0
          END DO
        END DO
      END DO
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE XYZDIP(XK,MAXDMP,XDIP,NVALVL,NVALVR,NDIPL,NDIPR,DDPM,
     1KSSX,IL,IR,LXL,LXR,JDIP,NVSYM,ILOFF,IROFF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL TRIAT
      COMMON/DUMP/JDUMP(10),IIDUMP,KDUMP,MDUMP,LDUMP
      COMMON/FILASS/IOUT
C**Changes 'E'
      DIMENSION XK(MAXDMP*NVSYM,MAXDMP*NVSYM),XDIP(NVALVL,NVALVR,2),
     1DDPM(5,KSSX,KSSX)
      COMMON/TRIATO/TRIAT
      COMMON/REACTL/JREACT
      IF(LDUMP.EQ.8)GO TO 100
C**Changes 'D' - interchange +1 & -1 (1:tau=1; 2:tau=-1; 3:tau=0)
      TMX=(DDPM(2,LXL,LXR)-DDPM(1,LXL,LXR))/SQRT(2.D0)
      TMY=-(DDPM(2,LXL,LXR)+DDPM(1,LXL,LXR))/SQRT(2.D0)
      TMZ=DDPM(3,LXL,LXR)
C
C
C**Changes 'E'
      IF(TRIAT)THEN
        DO IXR=1,NDIPR
          DO IXL=1,NDIPL
C**X COMPONENT
            IF(JDIP.EQ.1)XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1      TMY*XK(IXL+ILOFF,IXR+IROFF)
C**Y COMPONENT
            IF(JDIP.EQ.2)XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1      TMX*XK(IXL+ILOFF,IXR+IROFF)
C**Z COMPONENT
            IF(JDIP.EQ.3)XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1      TMZ*XK(IXL+ILOFF,IXR+IROFF)
          END DO
        END DO
      ELSE
        DO IXR=1,NDIPR
          DO IXL=1,NDIPL
C**X COMPONENT 
            IF(JDIP.EQ.1)THEN
              IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1          TMX*XK(IXL+ILOFF,IXR+IROFF)
C    1          TMY*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                IF(MOD(LXL,2).NE.0)THEN
                  XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)-
     1            TMX*XK(IXL+ILOFF,IXR+IROFF)
C    1            TMY*XK(IXL+ILOFF,IXR+IROFF)
                ELSE
                  XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1            TMX*XK(IXL+ILOFF,IXR+IROFF)
C    1            TMY*XK(IXL+ILOFF,IXR+IROFF)
                END IF
              END IF
            END IF
C**Y COMPONENT 
            IF(JDIP.EQ.2)THEN
              IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1          TMY*XK(IXL+ILOFF,IXR+IROFF)
C    1          TMX*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                IF(MOD(LXL,2).EQ.0)THEN
                  XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)-
     1            TMY*XK(IXL+ILOFF,IXR+IROFF)
C    1            TMX*XK(IXL+ILOFF,IXR+IROFF)
                ELSE
                  XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1            TMY*XK(IXL+ILOFF,IXR+IROFF)
C    1            TMX*XK(IXL+ILOFF,IXR+IROFF)
                END IF
              END IF
            END IF
C**Z COMPONENT 
            IF(JDIP.EQ.3)THEN
              IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1          TMZ*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                IF(MOD(LXL,2).EQ.0)THEN
                  XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)-
     1            TMZ*XK(IXL+ILOFF,IXR+IROFF)
                ELSE
                  XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1            TMZ*XK(IXL+ILOFF,IXR+IROFF)
                END IF
              END IF
            END IF
          END DO
        END DO
      END IF
      RETURN
100   CONTINUE
C**New tau values for Raman (1:tau=0; 2:tau=-1; 3:tau=1; 4:tau=-2;
C**5:tau=2........NB THESE ARE BRINK & SATCHLER QUANTA = (-1)*OURS)
      TMZZ=DDPM(1,LXL,LXR)
      TMYZ=DDPM(2,LXL,LXR)-DDPM(3,LXL,LXR)
      TMXZ=DDPM(2,LXL,LXR)+DDPM(3,LXL,LXR)
      TMXY=DDPM(4,LXL,LXR)-DDPM(5,LXL,LXR)
      TMXXYY=DDPM(4,LXL,LXR)+DDPM(5,LXL,LXR)
      DO IXR=1,NDIPR
        DO IXL=1,NDIPL
C** ZZ COMPONENT 
          IF(JDIP.EQ.1)THEN
            IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
              XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1        TMZZ*XK(IXL+ILOFF,IXR+IROFF)
            ELSE
              IF(MOD(LXL,2).EQ.0)THEN
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)-
     1          TMZZ*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1          TMZZ*XK(IXL+ILOFF,IXR+IROFF)
              END IF
            END IF
          END IF
C** iYZ COMPONENT 
          IF(JDIP.EQ.2)THEN
            IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
              XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1        TMYZ*XK(IXL+ILOFF,IXR+IROFF)
            ELSE
              IF(MOD(LXL,2).EQ.0)THEN
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1          TMYZ*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)-
     1          TMYZ*XK(IXL+ILOFF,IXR+IROFF)
              END IF
            END IF
          END IF
C** XZ COMPONENT 
          IF(JDIP.EQ.3)THEN
            IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
              XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1        TMXZ*XK(IXL+ILOFF,IXR+IROFF)
            ELSE
              IF(MOD(LXL,2).EQ.0)THEN
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)-
     1          TMXZ*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1          TMXZ*XK(IXL+ILOFF,IXR+IROFF)
              END IF
            END IF
          END IF
C** iXY COMPONENT 
          IF(JDIP.EQ.2)THEN
            IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
              XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1        TMXY*XK(IXL+ILOFF,IXR+IROFF)
            ELSE
              IF(MOD(LXL,2).EQ.0)THEN
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1          TMXY*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)-
     1          TMXY*XK(IXL+ILOFF,IXR+IROFF)
              END IF
            END IF
          END IF
C** XX-YY COMPONENT 
          IF(JDIP.EQ.3)THEN
            IF(MOD(LXL,2).EQ.MOD(LXR,2))THEN
              XDIP(IXL,IXR,1)=XDIP(IXL,IXR,1)+
     1        TMXXYY*XK(IXL+ILOFF,IXR+IROFF)
            ELSE
              IF(MOD(LXL,2).EQ.0)THEN
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)-
     1          TMXXYY*XK(IXL+ILOFF,IXR+IROFF)
              ELSE
                XDIP(IXL,IXR,2)=XDIP(IXL,IXR,2)+
     1          TMXXYY*XK(IXL+ILOFF,IXR+IROFF)
              END IF
            END IF
          END IF
        END DO
      END DO
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE MTRDIP(XA,NVALRL,NVALRR,TEMP,XDIP,NVALVL,
     1NVALVR,RCI,MAXRT,MAXDMP,MAXSYM,ILOOP,NSL,NSR,IGETL,IGETR,
     2NOFFL,NOFFR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**Changes 'E'
      LOGICAL TRIAT
      COMMON/TRIATO/TRIAT
      DIMENSION XA(NVALRL,NVALRR,2),TEMP(MAXDMP,MAXDMP),
     1XDIP(NVALVL,NVALVR,2)
      DIMENSION RCI(MAXRT,MAXDMP,MAXSYM,ILOOP,1)
      COMMON/FILASS/IOUT
C**Changes 'E'
      ICOMP=2
      IF(TRIAT)ICOMP=1
      DO I=1,ICOMP
C************************************DGEMM (RHS)
        CALL DGEMM('N','N',NVALVL,NVALRR,NVALVR,1.0D0,XDIP(1,1,I),
     1  NVALVL,RCI(1+NOFFR,1,NSR,1,IGETR),MAXRT,0.0D0,TEMP,MAXDMP)
C************************************DGEMM (LHS)
        CALL DGEMM('T','N',NVALRL,NVALRR,NVALVL,1.0D0,
     1  RCI(1+NOFFL,1,NSL,1,IGETL),MAXRT,TEMP,MAXDMP,1.0D0,
     2  XA(1,1,I),NVALRL)
      END DO
C************************************************************
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE SQDIP(XA,NVALRL,NVALRR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**Changes 'E'
      LOGICAL TRIAT
      COMMON/TRIATO/TRIAT
      DIMENSION XA(NVALRL,NVALRR,2)
      IF(TRIAT)THEN
        DO I=1,NVALRR
          DO J=1,NVALRL
            X=XA(J,I,1)
            XA(J,I,1)=X*X
          END DO
        END DO
      ELSE
        DO I=1,NVALRR
          DO J=1,NVALRL
            X=XA(J,I,1)
            XA(J,I,1)=X*X
            Y=XA(J,I,2)
            XA(J,I,1)=XA(J,I,1)+Y*Y
          END DO
        END DO
      END IF
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE S3JDIP(DDPM,KSSL,KSSR,JLEFT,JRIGHT,VAL,F,NF,
     1KSSX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/FILASS/IOUT
      DIMENSION DDPM(5,KSSX,KSSX),VAL(5),F(NF)
      DIMENSION ISG(5)
      COMMON/DUMP/JDUMP(10),IIDUMP,KDUMP,MDUMP,LDUMP
      IF(LDUMP.EQ.8)GO TO 100
C**Changes 'C' - values of Tau
      ISG(1)=1
      ISG(2)=-1
      ISG(3)=0
      XJL=JLEFT
      XJR=JRIGHT
      CONST=SQRT(2*XJL+1)*SQRT(2*XJR+1)
      ISIGR=-1
      KR=0
      CR=1
C********************K-BLOCKS (RHS)
      DO LXR=1,KSSR
        ISIGR=-ISIGR
        IF(KR.GT.0)CR=1/SQRT(2.D0)
        ISIGL=-1
        KL=0
        CL=1
C********************K-BLOCKS (LHS)
        DO LXL=1,KSSL
          ISIGL=-ISIGL
          IF(KL.GT.0)CL=1/SQRT(2.D0)
          DO IX=1,3
            DDPM(IX,LXL,LXR)=0
          END DO
          KKR=-KR
C**Changes 'B' - insert comments
C         IF(IABS(KR-KL).GT.1)GO TO 120
          XKKR=KKR
          XKL=KL
C**Changes 'B' - interchange columns
          TL1=THREEJ(1,XJR,XJL,-1,XKKR,XKL,F,NF)
          TL2=THREEJ(1,XJR,XJL,1,XKKR,XKL,F,NF)
          TL3=THREEJ(1,XJR,XJL,0,XKKR,XKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          DO IX=1,3
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KR+ISG(IX))*VAL(IX)*
     2      CONST
          END DO
120       IF(KL.EQ.0)GO TO 130
          KKL=-KL
C         IF(IABS(KR-KKL).GT.1)GO TO 130
          XKKR=KKR
          XKKL=KKL
          TL1=THREEJ(1,XJR,XJL,-1,XKKR,XKKL,F,NF)
          TL2=THREEJ(1,XJR,XJL,1,XKKR,XKKL,F,NF)
          TL3=THREEJ(1,XJR,XJL,0,XKKR,XKKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          DO IX=1,3
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KR+ISG(IX))*ISIGL*VAL(IX)*
     2      CONST
          END DO
130       IF(KR.EQ.0)GO TO 140
          KKR=-KR
C         IF(IABS(KKR-KL).GT.1)GO TO 140
          XKR=KR
          XKL=KL
          TL1=THREEJ(1,XJR,XJL,-1,XKR,XKL,F,NF)
          TL2=THREEJ(1,XJR,XJL,1,XKR,XKL,F,NF)
          TL3=THREEJ(1,XJR,XJL,0,XKR,XKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          DO IX=1,3
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KKR+ISG(IX))*ISIGR*VAL(IX)*
     2      CONST
          END DO
140       IF(KR.EQ.0.OR.KL.EQ.0)GO TO 150
C         IF(IABS(KKR-KKL).GT.1)GO TO 150
          XKR=KR
          XKKL=KKL
          TL1=THREEJ(1,XJR,XJL,-1,XKR,XKKL,F,NF)
          TL2=THREEJ(1,XJR,XJL,1,XKR,XKKL,F,NF)
          TL3=THREEJ(1,XJR,XJL,0,XKR,XKKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          DO IX=1,3
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KKR+ISG(IX))*ISIGL*ISIGR*
     2      VAL(IX)*CONST
          END DO
150       CONTINUE
          KL=KL+MOD(LXL,2)
          ISIGL=ISIGL*(-1)**(MOD(LXL,2))
        END DO
        KR=KR+MOD(LXR,2)
        ISIGR=ISIGR*(-1)**(MOD(LXR,2))
      END DO
      RETURN
100   CONTINUE
C**New tau values for Raman (1:tau=0; 2:tau=-1; 3:tau=1; 4:tau=-2;
C**5:tau=2........NB THESE ARE BRINK & SATCHLER QUANTA = (-1)*OURS)
      ISG(1)=0
      ISG(2)=-1
      ISG(3)=1
      ISG(4)=-2
      ISG(5)=2
      XJL=JLEFT
      XJR=JRIGHT
      CONST=SQRT(2*XJL+1)*SQRT(2*XJR+1)
      ISIGR=-1
      KR=0
      CR=1
C********************K-BLOCKS (RHS)
      DO LXR=1,KSSR
        ISIGR=-ISIGR
        IF(KR.GT.0)CR=1/SQRT(2.D0)
        ISIGL=-1
        KL=0
        CL=1
C********************K-BLOCKS (LHS)
        DO LXL=1,KSSL
          ISIGL=-ISIGL
          IF(KL.GT.0)CL=1/SQRT(2.D0)
          DO IX=1,3
            DDPM(IX,LXL,LXR)=0
          END DO
          KKR=-KR
          XKKR=KKR
          XKL=KL
          TL1=THREEJ(2,XJR,XJL,0,XKKR,XKL,F,NF)
          TL2=THREEJ(2,XJR,XJL,-1,XKKR,XKL,F,NF)
          TL3=THREEJ(2,XJR,XJL,1,XKKR,XKL,F,NF)
          TL4=THREEJ(2,XJR,XJL,-2,XKKR,XKL,F,NF)
          TL5=THREEJ(2,XJR,XJL,2,XKKR,XKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          VAL(4)=TL4
          VAL(5)=TL5
          DO IX=1,5
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KR+ISG(IX))*VAL(IX)*
     2      CONST
          END DO
160       IF(KL.EQ.0)GO TO 170
          KKL=-KL
          XKKR=KKR
          XKKL=KKL
          TL1=THREEJ(2,XJR,XJL,0,XKKR,XKKL,F,NF)
          TL2=THREEJ(2,XJR,XJL,-1,XKKR,XKKL,F,NF)
          TL3=THREEJ(2,XJR,XJL,1,XKKR,XKKL,F,NF)
          TL4=THREEJ(2,XJR,XJL,-2,XKKR,XKKL,F,NF)
          TL5=THREEJ(2,XJR,XJL,2,XKKR,XKKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          VAL(4)=TL4
          VAL(5)=TL5
          DO IX=1,5
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KR+ISG(IX))*ISIGL*VAL(IX)*
     2      CONST
          END DO
170       IF(KR.EQ.0)GO TO 180
          KKR=-KR
          XKR=KR
          XKL=KL
          TL1=THREEJ(2,XJR,XJL,0,XKR,XKL,F,NF)
          TL2=THREEJ(2,XJR,XJL,-1,XKR,XKL,F,NF)
          TL3=THREEJ(2,XJR,XJL,1,XKR,XKL,F,NF)
          TL4=THREEJ(2,XJR,XJL,-2,XKR,XKL,F,NF)
          TL5=THREEJ(2,XJR,XJL,2,XKR,XKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          VAL(4)=TL4
          VAL(5)=TL5
          DO IX=1,5
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KKR+ISG(IX))*ISIGR*VAL(IX)*
     2      CONST
          END DO
180       IF(KR.EQ.0.OR.KL.EQ.0)GO TO 190
          XKR=KR
          XKKL=KKL
          TL1=THREEJ(2,XJR,XJL,0,XKR,XKKL,F,NF)
          TL2=THREEJ(2,XJR,XJL,-1,XKR,XKKL,F,NF)
          TL3=THREEJ(2,XJR,XJL,1,XKR,XKKL,F,NF)
          TL4=THREEJ(2,XJR,XJL,-2,XKR,XKKL,F,NF)
          TL5=THREEJ(2,XJR,XJL,2,XKR,XKKL,F,NF)
          VAL(1)=TL1
          VAL(2)=TL2
          VAL(3)=TL3
          VAL(4)=TL4
          VAL(5)=TL5
          DO IX=1,5
            DDPM(IX,LXL,LXR)=
     1      DDPM(IX,LXL,LXR)+CL*CR*(-1)**(-KKR+ISG(IX))*ISIGL*ISIGR*
     2      VAL(IX)*CONST
          END DO
190       CONTINUE
          KL=KL+MOD(LXL,2)
          ISIGL=ISIGL*(-1)**(MOD(LXL,2))
        END DO
        KR=KR+MOD(LXR,2)
        ISIGR=ISIGR*(-1)**(MOD(LXR,2))
      END DO
      RETURN
      END
C***************************************************************
C***************************************************************
      DOUBLE PRECISION FUNCTION THREEJ(IA,XIB,XIC,JA,XJB,XJC,F,NF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION F(NF)
      THREEJ=0.D0
      JBCP=(XJB+XJC)
      IF(JA+JBCP.NE.0)RETURN
      IBCM=(XIB-XIC)
      ICBM=(XIC-XIB)
      IBCP=(XIB+XIC)
      IF((IA+IBCM).LT.0)RETURN
      IF((IA+ICBM).LT.0)RETURN
      IF((IBCP-IA).LT.0)RETURN
      IBJCP=(XIB+XJC)
      IBJBP=(XIB+XJB)
      ICJCP=(XIC+XJC)
      IBJBM=(XIB-XJB)
      ICJCM=(XIC-XJC)
      ICJBM=(XIC-XJB)
      CONST=(-1)**(IA-IBJCP)*F(IA+IBCM+1)*F(IA+ICBM+1)*
     1F(IBCP-IA+1)/F(IA+IBCP+2)
      CONST=CONST*F(IA+JA+1)*F(IA-JA+1)
      CONST=CONST*F(IBJBP+1)*F(IBJBM+1)
      CONST=CONST*F(ICJCP+1)*F(ICJCM+1)
      MINUS=1
      TERM=0.D0
      NU=0
1     CONTINUE
      IF((IA-JA-NU).LT.0)GO TO 2
      IF((ICBM+JA+NU).LT.0)GO TO 3
      IF((IBJBP-NU).LT.0)GO TO 2
      IF((ICJBM-IA+NU).LT.0)GO TO 3
      IF((IA+IBCM-NU).LT.0)GO TO 2
      FACT=1.D0/(F(IA-JA-NU+1)*F(ICBM+JA+NU+1)*F(IBJBP-NU+1)*
     1F(ICJBM-IA+NU+1)*F(NU+1)*F(IA+IBCM-NU+1))
      FACT=FACT*FACT
      TERM=TERM+MINUS*FACT
3     MINUS=-MINUS
      NU=NU+1
      GO TO 1
2     THREEJ=CONST*TERM
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE FINDIP(JLEFT,JRIGHT,NSL,NSR,NSLL,NSRR,RVAL,MAXDMP,
     1MAXSYM,ILOOP,JSTORE,XA,NDUMPL,NDUMPR,IASS,IGETL,IGETR,NMODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*1 P1,P2
      LOGICAL TRIAT
      COMMON/TRIATO/TRIAT
      COMMON/DUMP/JJDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/TRANS/TEMP,TCUT,ECUT
      COMMON/AXES/MX(3),MXDIP(5),MXROT(3)
      COMMON/FILASS/IOUT,INP,MOUTIN,INP4,INP5,INP6,INP7,INP8,
     1INP9,INP10
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/ROTS/JMAX,KMAX,J21,KEL21,KEL
      COMMON/SPIN/NSPSYM(10),NSPIN(5,10),NSINDL(10),NSINDR(10)
      COMMON/QPART/QCALC
      DIMENSION RVAL(MAXDMP,MAXSYM,ILOOP,JSTORE),XA(NDUMPL,NDUMPR)
      DIMENSION IASS(2+NMODE,MAXDMP,MAXSYM,JSTORE)
100   FORMAT(1X,I2,1X,4I3,1X,A1,1X,F9.2,2X,I2,1X,4I3,A1,1X,F9.2,3X,
     1F10.2,2X,E12.6)
C**UPDATE LHS & RHS SYMMETRY INDICATORS
      NSINDL(NSLL)=NSINDL(NSLL)+1
      NSINDR(NSRR)=NSINDR(NSRR)+1
      K1=NSLL
      K2=NSRR
      IF(NRSYM.GE.4)NS=2
      IF(NRSYM.EQ.2)NS=1
      IF(NRSYM.EQ.1)NS=0
C**LHS PARITY
      IF(NS.EQ.0)P1='+'
      IF(NS.EQ.1)THEN
        IF(MOD(JLEFT,2).EQ.0)THEN
          IF(MOD(K1,2).EQ.0)THEN
            P1='-'
          ELSE
            P1='+'
          END IF
        ELSE
          IF(MOD(K1,2).EQ.0)THEN
            P1='+'
          ELSE
            P1='-'
          END IF
        END IF
      END IF
      IF(NS.EQ.2)THEN
C       IF((MOD(JLEFT,2).EQ.0.AND.MXDIP(2).EQ.1).OR.MXDIP(3).EQ.1)THEN
C         IF(K1.LE.NS)THEN
C           IF(MOD(K1,2).EQ.0)THEN
C             P1='-'
C           ELSE
C             P1='+'
C           END IF
C         ELSE
C           IF(MXDIP(2).EQ.1)THEN
C             IF(MOD(K1,2).EQ.0)THEN
C               P1='-'
C             ELSE
C               P1='+'
C             END IF
C           ELSE
C             IF(MOD(K1,2).EQ.0)THEN
C               P1='+'
C             ELSE
C               P1='-'
C             END IF
C           END IF
C         END IF
C       ELSE
C         IF(MOD(K1,2).EQ.0)THEN
C           P1='+'
C         ELSE
C           P1='-'
C         END IF
C       END IF
        IF(K1.GT.4)K1=K1-4
        IF(K1.EQ.1.OR.K1.EQ.4)P1='+'
        IF(K1.EQ.2.OR.K1.EQ.3)P1='-'
      END IF
C**RHS PARITY
      IF(NS.EQ.0)P2='+'
      IF(NS.EQ.1)THEN
        IF(MOD(JRIGHT,2).EQ.0)THEN
          IF(MOD(K2,2).EQ.0)THEN
            P2='-'
          ELSE
            P2='+'
          END IF
        ELSE
          IF(MOD(K2,2).EQ.0)THEN
            P2='+'
          ELSE
            P2='-'
          END IF
        END IF
      END IF
      IF(NS.EQ.2)THEN
C       IF((MOD(JRIGHT,2).EQ.0.AND.MXDIP(2).EQ.1).OR.MXDIP(3).EQ.1)THEN
C         IF(K2.LE.NS)THEN
C           IF(MOD(K2,2).EQ.0)THEN
C             P2='-'
C           ELSE
C             P2='+'
C           END IF
C         ELSE
C           IF(MXDIP(2).EQ.1)THEN
C             IF(MOD(K2,2).EQ.0)THEN
C               P2='-'
C             ELSE
C               P2='+'
C             END IF
C           ELSE
C             IF(MOD(K2,2).EQ.0)THEN
C               P2='+'
C             ELSE
C               P2='-'
C             END IF
C           END IF
C         END IF
C       ELSE
C         IF(MOD(K2,2).EQ.0)THEN
C           P2='+'
C         ELSE
C           P2='-'
C         END IF
C       END IF
        IF(K2.GT.4)K2=K2-4
        IF(K2.EQ.1.OR.K2.EQ.4)P2='+'
        IF(K2.EQ.2.OR.K2.EQ.3)P2='-'
      END IF
C**TEMPORARY
      IF(LDUMP.NE.9)THEN
        WRITE(INP10,*)'RO-VIB SYMMETRY (RHS) ',NSRR
        WRITE(INP10,*)'RO-VIB SYMMETRY (LHS) ',NSLL
      END IF
C**TEMPORARY
      IF(LDUMP.EQ.8)GO TO 200
C**TEMPORARY
C     WRITE(IOUT,*)'JMAX,JLEFT,JRIGHT',JMAX,JLEFT,JRIGHT
C     WRITE(IOUT,*)'NDUMPL,NDUMPR',NDUMPL,NDUMPR
C     WRITE(IOUT,*)'NSL,NSR,NSLL,NSRR',NSL,NSR,NSLL,NSRR
C     WRITE(IOUT,*)'QCALC',QCALC
C     WRITE(IOUT,*)
C**TEMPORARY
      DO IRHS=1,NDUMPR
        E2=RVAL(IRHS,NSR,1,IGETR)*WAVENM
        WT2=1
        IF(TEMP.GT.0)WT2=EXP(-E2/(0.69D0*TEMP))
        DO ILHS=1,NDUMPL
          E1=RVAL(ILHS,NSL,1,IGETL)*WAVENM
          WT1=1
          IF(TEMP.GT.0)WT1=EXP(-E1/(0.69D0*TEMP))
C
C**   CALL USER ROUTINE TO DETERMINE LHS AND RHS SYMMETRIES IN 'PARENT'
C**   POINT GROUP (EG Td IF CH4 FROM D2 SYMMETRIES)
C**   ON ENTRY TO FINDIP, NSLL AND NSRR CONTAIN 'REDUCED' SYMMETRIES.
C**   ON EXIT FROM USER ROUTINE, NSLX AND NSRX CONTAIN 'PARENT'
C**   SYMMETRIES WITHIN 'REDUCED' SYMMETRIES.
          CALL REDSYM(JLEFT,JRIGHT,NSLL,NSRR,NSLX,NSRX,ILHS,IRHS,IRET)
          IF(NSINDL(NSLL).EQ.1.AND.IRHS.EQ.1.AND.JLEFT.NE.JRIGHT)THEN
            QCALC=QCALC+(2*JLEFT+1)*NSPIN(NSLX,NSLL)*WT1
C**TEMPORARY
C     WRITE(IOUT,*)'NSL,NSLL,NSPIN,JLEFT,ILHS,QCALC',NSL,NSLL,
C    1NSPIN(NSLX,NSLL),
C    1JLEFT,ILHS,QCALC
C**TEMPORARY
          END IF
          IF(NSINDR(NSRR).EQ.1.AND.ILHS.EQ.1.AND.JLEFT.NE.JRIGHT)THEN
            IF(JRIGHT.EQ.JMAX.AND.KMAX.GT.0)THEN
              QCALC=QCALC+(2*JRIGHT+1)*NSPIN(NSRX,NSRR)*WT2
C**TEMPORARY
C     WRITE(IOUT,*)'NSR,NSRR,NSPIN,JRIGHT,IRHS,QCALC',NSR,NSRR,
C    1NSPIN(NSRX,NSRR),
C    1JRIGHT,IRHS,QCALC
C**TEMPORARY
            END IF
          END IF
C**   SKIP IF FORBIDDEN ON NUCLEAR SPIN GROUNDS
          IF(IRET.EQ.0.OR.LDUMP.EQ.9)GO TO 9999

          DELTA=E1-E2
          TTOL=0.0001D0
          IF(DELTA.GT.0)THEN
            IF(WT2.LT.TTOL*WT2/EXP(-E2/(0.69D0*300)))GO TO 9999
          ELSE
            IF(WT1.LT.TTOL*WT1/EXP(-E1/(0.69D0*300)))GO TO 9999
          END IF
          T=XA(ILHS,IRHS)
          IF(DABS(T).LE.TCUT)GO TO 9999
          IF(ECUT.LE.0.AND.DABS(DELTA).LT.DABS(ECUT))GO TO 9999
          IF(ECUT.GT.0.AND.DABS(DELTA).GT.ECUT)GO TO 9999
          IF(DELTA.GE.0)THEN
CC          WRITE(INP10,100)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,4),P2,
CC   1      E2,JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,4),P1,E1,DELTA,T
            WRITE(INP10,*)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),P1,E1,
     2      DELTA,T
            WRITE(INP6)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,NSRX,NSRR
            WRITE(INP6)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,DELTA,T
          END IF
          IF(DELTA.LT.0.AND.JLEFT.NE.JRIGHT)THEN
CC          WRITE(INP10,100)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,4),P1,
CC   1      E1,JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,4),P2,E2,
            WRITE(INP10,*)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),P2,E2,
     2      DABS(DELTA),T
            WRITE(INP6)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,NSLX,NSLL
            WRITE(INP6)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,DABS(DELTA),T
          END IF
9999      CONTINUE
        END DO
      END DO
      GO TO 201
200   CONTINUE
C**RAMAN
      DO IRHS=1,NDUMPR
        E2=RVAL(IRHS,NSR,1,IGETR)*WAVENM
        WT2=1
        IF(TEMP.GT.0)WT2=EXP(-E2/(0.69D0*TEMP))
        DO ILHS=1,NDUMPL
          E1=RVAL(ILHS,NSL,1,IGETL)*WAVENM
          WT1=1
          IF(TEMP.GT.0)WT1=EXP(-E1/(0.69D0*TEMP))
C**   CALL USER ROUTINE TO DETERMINE LHS AND RHS SYMMETRIES IN 'PARENT'
C**   POINT GROUP (EG Td IF CH4 FROM D2 SYMMETRIES)
C**   ON ENTRY TO FINDIP, NSLL AND NSRR CONTAIN 'REDUCED' SYMMETRIES.
C**   ON EXIT FROM USER ROUTINE, NSLX AND NSRX CONTAIN 'PARENT'
C**   SYMMETRIES WITHIN 'REDUCED' SYMMETRIES.
          CALL REDSYM(JLEFT,JRIGHT,NSLL,NSRR,NSLX,NSRX,ILHS,IRHS,IRET)
C**   SKIP IF FORBIDDEN ON NUCLEAR SPIN GROUNDS
          IF(IRET.EQ.0)GO TO 9998
          DELTA=E1-E2
C         IF(DELTA.GT.0)THEN
C           IF(WT2.LT.0.0001D0)GO TO 9998
C         ELSE
C           IF(WT1.LT.0.0001D0)GO TO 9998
C         END IF
          IF(WT1.LT.0.0001D0.AND.WT2.LT.0.0001D0)GO TO 9998
          T=XA(ILHS,IRHS)
          IF(DABS(T).LE.TCUT)GO TO 9998
          IF(ECUT.LE.0.AND.DABS(DELTA).LT.DABS(ECUT))GO TO 9998
          IF(ECUT.GT.0.AND.DABS(DELTA).GT.ECUT)GO TO 9998
          IF(DELTA.GE.0)THEN
            WRITE(INP10,*)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),P1,E1,
     2      DELTA,T
            WRITE(INP6)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,NSRX,NSRR
            WRITE(INP6)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,NSLX,NSLL,DELTA,T
          END IF
          IF(DELTA.LT.0.AND.JLEFT.NE.JRIGHT)THEN
            WRITE(INP10,*)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),P2,E2,
     2      DABS(DELTA),T
            WRITE(INP6)JLEFT,(IASS(N1,ILHS,NSL,IGETL),N1=1,2+NMODE),
     1      P1,E1,NSLX,NSLL
            WRITE(INP6)JRIGHT,(IASS(N2,IRHS,NSR,IGETR),N2=1,2+NMODE),
     1      P2,E2,NSRX,NSRR,DABS(DELTA),T
          END IF
9998      CONTINUE
        END DO
      END DO
201   CONTINUE
C**TEMPORARY
      IF(LDUMP.NE.9)THEN
        WRITE(INP10,*)'************************************'
      END IF
C**TEMPORARY
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE REDSYM(JLEFT,JRIGHT,NSLL,NSRR,NSLX,NSRX,ILHS,IRHS,IRET)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**SPECIFIC TO CH4 IN D2 --- ONLY 'REDUCED' SYMMETRY 1 CONTAINS TWO 
C**'PARENT' SYMMETRIES A(1) AND E(2)
C**ONLY ENERGIES TO 5000 cm-1 CONSIDERED
      DIMENSION J0(30),J1(60),J2(110)
C     DATA J0/ 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2,
C    1         1, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0/
      DATA J0/ 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2,
     1         2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0/
C     DATA J1/ 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2,
C    1         2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2,
C    2         2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 0, 0, 0,
C    3         0, 0, 0/
      DATA J1/ 1, 2, 2, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 2,
     1         2, 1, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2,
     2         2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 2, 2, 1, 0, 0, 0,
     3         0, 0, 0/
C     DATA J2/ 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2,
C    1         2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2,
C    2         2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2,
C    3         2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1,
C    4         2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1,
C    5         2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0/
      DATA J2/ 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2,
     1         2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2,
     2         2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 1, 2, 2, 2,
     3         2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 2, 2, 2, 1,
     4         2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 2, 1,
     5         2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0/
C*********************************************************************
C**NORMAL EXIT IF IRET=1
      IRET=1
C**SET DEFAULT 'PARENT' SYMMETRIES
      NSLX=1
      NSRX=1
C**TEMPORARY - HOOH
      RETURN
C**TEMPORARY - HOOH
C**
C**CH4 ONLY
C**ONLY JLEFT CAN BE J=0
      IF(JLEFT.EQ.0.AND.NSLL.EQ.1)THEN
        IF(ILHS.LE.30)THEN
          NSLX=J0(ILHS)
        ELSE
          NSLX=0
        END IF
      END IF
C**BOTH JLEFT AND JRIGHT CAN BE J=1
      IF(JLEFT.EQ.1.AND.NSLL.EQ.1)THEN
        IF(ILHS.LE.60)THEN
          NSLX=J1(ILHS)
        ELSE
          NSLX=0
        END IF
      END IF
      IF(JRIGHT.EQ.1.AND.NSRR.EQ.1)THEN
        IF(IRHS.LE.60)THEN
          NSRX=J1(IRHS)
        ELSE
          NSRX=0
        END IF
      END IF
C**BOTH JLEFT AND JRIGHT CAN BE J=2
      IF(JLEFT.EQ.2.AND.NSLL.EQ.1)THEN
        IF(ILHS.LE.110)THEN
          NSLX=J2(ILHS)
        ELSE
          NSLX=0
        END IF
      END IF
      IF(JRIGHT.EQ.2.AND.NSRR.EQ.1)THEN
        IF(IRHS.LE.110)THEN
          NSRX=J2(IRHS)
        ELSE
          NSRX=0
        END IF
      END IF
C**D2 SYMMETRIES DIFFERENT - SKIP --- A
C     IF(NSLL.NE.NSRR)THEN
C**IF Td SYMMETRIES (A,E) WITH F - SKIP --- B
      IF((NSLL.EQ.1.AND.NSRR.GT.1.).OR.(NSLL.GT.1.AND.NSRR.EQ.1))THEN
        IRET=0
        RETURN
      END IF
C**NOT 'REDUCED' SYMMETRY 1 - RETURN WITH DEFAULTS
      IF(NSLL.NE.1.OR.NSRR.NE.1)RETURN
C**ENERGY > 5000 cm-1 - SKIP
      IF(NSLX.EQ.0.OR.NSRX.EQ.0)IRET=0
C**IF Td SYMMETRIES A WITH E - SKIP
      IF(NSLX.NE.NSRX)IRET=0
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE TRANSP(FILEB,FILEG,NMODE,T,QR,FREQ0,WDT,IV1,
     1IV2,IROT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*80 FILEB,FILEG
      CHARACTER*1 PLMI1,PLMI2,IROT,LAB
      LOGICAL ALL
      COMMON/DUMP/JJDUMP(10),IDUMP,KDUMP,MDUMP,LDUMP
      COMMON/WHICH/IWHICH
      COMMON/FILASS/IOUT,INP,MOUTIN,INP4,INP5,INP6,INP7,INP8,INP9
      COMMON/MAXMIN/TRMIN,TRMAX
      COMMON/SPIN/NSPSYM(10),NSPIN(5,10)
      COMMON/QPART/QCALC
C**BOLTZMANN FACTOR
      DATA B/0.695D0/
      DATA FACTOR/3054.6D0/
      DATA DEBYE/2.54158D0/
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      DIMENSION IV1(60),IV2(60),IX1(60),IX2(60)
C*******************************************************
100   FORMAT(1X,I2,1X,4I3,1X,A1,1X,F9.2,2X,I2,1X,4I3,A1,1X,
     1F9.2,3X,F10.2,2X,E12.6)
101   FORMAT(2I3,F8.2,I3,2F8.2,4E11.4,1X,(A))
102   FORMAT(5X,F8.2,5X,E11.4)
103   FORMAT(2I3,2I2,2I3,F8.2,2I3,2I2,I3,2F8.2,4E11.4,1X,A1)
104   FORMAT(/,'MAX. INTENSITY = ',E11.4)
105   FORMAT(/,'INTEGRATED BAND INTENSITY = ',E11.4)
C
500   FORMAT(///25X,' *** P,Q,R SPECTRUM *** ',///)
501   FORMAT(/' OUTPUT BRANCH FILE [.PQR]: ',/,A80)
502   FORMAT(/' COMPLETE OR SPECIAL [0/1] ? ',I2)
503   FORMAT(/' TEMPERATURE : ',F10.5)
504   FORMAT(/' PARTITION SUM (INPUT AND CALCULATED) : ',F10.5,2X,F10.5)
5055  FORMAT(/' NO. ACTUAL SYMMETRIES FOR EACH RO-VIB SYMMETRY: ',10I3)
505   FORMAT(/' NUCLEAR SPIN STATISTICS FOR EACH SYMMETRY: ',10I3)
506   FORMAT(' H-X-H => A1: g= 1,3  ')
507   FORMAT('       => B1: g= 3,1  ')
508   FORMAT(2I5)
5088  FORMAT(/' GAUSS LINE-WIDTH : ',F10.5)
5888  FORMAT(/' LOWER-UPPER TRANSITION ENERGIES: ',F10.5,5X,F10.5)
509   FORMAT(/' INITIAL VIBRATIONAL LEVEL [v1,v2,v3,...]: ',3I5)
510   FORMAT(/' FINAL VIBRATIONAL LEVEL [v1,v2,v3,...]: ',3I5)
511   FORMAT(/' ROTATIONAL BRANCH [P,Q,R,A{all}]: ',A1)

C*******************************************************
      SMAX=0
      SINT=0
      IF(LDUMP.NE.9)THEN
        WRITE(IOUT,500)
        WRITE(IOUT,501)FILEB
        WRITE(IOUT,502)IWHICH
        WRITE(IOUT,503)T
      END IF
      IF(LDUMP.NE.8)THEN
C       WRITE(IOUT,504)QR,QCALC
        WRITE(IOUT,*)' PARTITION SUM (INPUT AND CALCULATED) : ',QR,QCALC
        IF(QR.EQ.0)QR=QCALC
      ELSE
        WRITE(IOUT,*)' INPUT FREQUENCY : ',FREQ0
      END IF
      WRITE(IOUT,5055)(NSPSYM(I),I=1,NRSYM)
      WRITE(IOUT,505)((NSPIN(J,I),J=1,NSPSYM(I)),I=1,NRSYM)
      IF(LDUMP.EQ.9)RETURN
      WRITE(IOUT,5088)WDT
      WRITE(IOUT,5888)TRMIN,TRMAX
      IF(IWHICH.NE.0)THEN
        WRITE(IOUT,509)(IV1(I),I=1,NMODE)
        WRITE(IOUT,510)(IV2(I),I=1,NMODE)
        WRITE(IOUT,511)IROT
        IF(IROT.EQ.'A')ALL=.TRUE.
        IF(IROT.NE.'A')ALL=.FALSE.
      END IF
      REWIND INP6
      IF(LDUMP.NE.8)
     1WRITE(INP7,*)'  J" U"V"W" L" NS   E"    J'' U''V''W'' L''  E''',
     2    '      E''-E"   R2(AU)   R2(DEBYE) S(1/ATM/CM2) S(CM/MOLE)'
      IF(LDUMP.EQ.8)
     1WRITE(INP7,*)'  J" U"V"W" L" NS   E"    J'' U''V''W'' L''  E''',
     2    '      E''-E"   R2(AU)   RALEIGH      STOKES   ANTISTOKES '
1     CONTINUE
      WRITE(INP7,*)'   *************************************************
     1*'
      IF(LDUMP.EQ.8)GO TO 200
      READ(INP6,ERR=9999,END=9999) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,
     1PLMI1,E1,NS1,NS2
      READ(INP6,ERR=9999,END=9999)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,
     1PLMI2,E2,EDIF,R2
      NS=NSPIN(NS1,NS2)
      LAB=' '
      IF (MAXJ2.EQ.MAXJ1) LAB='Q'
      IF (MAXJ2.EQ.MAXJ1+1) LAB='R'
      IF (MAXJ2.EQ.MAXJ1-1) LAB='P'
      RD=R2*DEBYE*DEBYE
      RF=RD*NS
      S=FACTOR*EDIF*RF/(QR*T)
      S=S*EXP(-E1/(B*T))*(1.D0-EXP(-EDIF/(B*T)))
C     SCMM=S/2.4464D19
      TFACT=2.686754D19*273.15D0/T
      SCMM=S/TFACT
C***********************************************************************
C**COMPLETE
      IF(IWHICH.EQ.0)THEN
        WRITE(INP7,*) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,NS,E1
        WRITE(INP7,*)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,E2,EDIF,R2,RD,S,
     1  SCMM,LAB
        WRITE(INP8) EDIF,S
        IF(S.GT.SMAX)THEN
          EMAX=EDIF
          SMAX=S
        END IF
        GO TO 1
      END IF
C**********************************************************************
C**SPECIAL
      IF((.NOT.ALL).AND.(LAB.EQ.IROT))THEN
C**P,Q,R
        DO M=1,NMODE
          IF((IV1(M).NE.IX1(M)).OR.(IV2(M).NE.IX2(M)))GO TO 11
        END DO
        WRITE(INP7,*) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,NS,E1
        WRITE(INP7,*)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,E2,EDIF,R2,RD,
     1  S,SCMM,LAB
        SINT=SINT+S
        IF(S.GT.SMAX)THEN
          EMAX=EDIF
          SMAX=S
        END IF
        WRITE(INP8) EDIF,S
        GO TO 1
11      CONTINUE
      END IF
C**ALL
      IF(ALL)THEN
        DO M=1,NMODE
          IF((IV1(M).NE.IX1(M)).OR.(IV2(M).NE.IX2(M)))GO TO 111
        END DO
        WRITE(INP7,*) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,NS,E1
        WRITE(INP7,*)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,E2,EDIF,R2,RD,
     1  S,SCMM,LAB
        SINT=SINT+S
        IF(S.GT.SMAX)THEN
          EMAX=EDIF
          SMAX=S
        END IF
        WRITE(INP8) EDIF,S
        GO TO 1
111     CONTINUE
      END IF
C
      GO TO 1
200   CONTINUE
C**RAMAN
C******************
C     CONST=???????
      CONST=1
      SCDUM=0
C******************
      READ(INP6,ERR=9999,END=9999) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,
     1PLMI1,E1,NS1,NS2
      READ(INP6,ERR=9999,END=9999)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,
     1PLMI2,E2,NS3,NS4,EDIF,R2
      NSS=NSPIN(NS1,NS2)
      NSA=NSPIN(NS3,NS4)
C**SHOULD THIS BE A LOWER LIMIT?
      IF(EDIF.EQ.0)THEN
C**RAYLEIGH SCATTERING
        NS=NSS
        S=EXP(-E1/(B*T))*NS*R2*FREQ0**4
        SCMMR=CONST*S
        WRITE(INP7,*) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,NS,E1
        WRITE(INP7,*)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,E2,EDIF,R2,
     1  SCMMR,SCDUM,SCDUM
        GO TO 1
      END IF
C**STOKES (E1 -> E2)
      NS=NSS
      S=EXP(-E1/(BT))*NS*R2*(FREQ0+EDIF)**4
      SCMMS=CONST*S
        WRITE(INP7,*) MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,NS,E1
        WRITE(INP7,*)MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,E2,EDIF,R2,
     1  SCDUM,SCMMS,SCDUM
C**ANTISTOKES (E2 -> E1)
      NS=NSA
      S=EXP(-E2/(BT))*NS*R2*(FREQ0-EDIF)**4
      SCMMA=CONST*S
        WRITE(INP7,*) MAXJ2,(IX2(I),I=1,NMODE),KA2,KC2,NS,E2
        WRITE(INP7,*)MAXJ1,(IX1(I),I=1,NMODE),KA1,KC1,E1,EDIF,R2,
     1  SCDUM,SCDUM,SCMMA
C
      GO TO 1
9999  CONTINUE
      IF(IWHICH.NE.0)THEN
        IF(.NOT.ALL)WRITE(IOUT,104)SMAX
        IF(.NOT.ALL)WRITE(IOUT,*)' DELTA(ENERGY)= ',EMAX
        IF(ALL)WRITE(IOUT,105)SINT
      END IF
      WRITE(IOUT,104)SMAX
      CALL SPECTRUM(FILEG,WDT)
      CLOSE(INP8)
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDP0(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(1)
      V=0
      DO I=1,NPOT
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,1,IDIP).EQ.0)THEN
          V=V+CPOT(I,IDIP)
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDP1(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(1)
      V=0
      DO I=1,NPOT
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,2,IDIP).EQ.0)THEN
          K=IPOT(I,1,IDIP)
          L=JPOT(I,1,IDIP)
          TERM=QQ(K)**L
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDP2(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,2,IDIP).NE.0.AND.IPOT(I,3,IDIP).EQ.0)THEN
          DO J=1,2
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDP3(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,3,IDIP).NE.0.AND.IPOT(I,4,IDIP).EQ.0)THEN
          DO J=1,3
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDP4(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,4,IDIP).NE.0)THEN
          DO J=1,4
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDV0(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(1)
      V=0
      DO I=1,NPOT
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,1,IDIP).EQ.0)THEN
          V=V+CPOT(I,IDIP)
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDV1(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(1)
      V=0
      DO I=1,NPOT
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,2,IDIP).EQ.0)THEN
          K=IPOT(I,1,IDIP)
          L=JPOT(I,1,IDIP)
          TERM=QQ(K)**L
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDV2(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,2,IDIP).NE.0.AND.IPOT(I,3,IDIP).EQ.0)THEN
          DO J=1,2
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDV3(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,3,IDIP).NE.0.AND.IPOT(I,4,IDIP).EQ.0)THEN
          DO J=1,3
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE GETDV4(V,NPOT,IPOT,JPOT,CPOT,NMODE,QQ,IDIP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION IPOT(NPOT,6,3),JPOT(NPOT,6,3),CPOT(NPOT,3),QQ(NMODE)
      V=0
      DO I=1,NPOT
        TERM=1
C**MAXIMUM OF 6 MODES COUPLED
        IF(IPOT(I,4,IDIP).NE.0)THEN
          DO J=1,4
            K=IPOT(I,J,IDIP)
            L=JPOT(I,J,IDIP)
            TERM=TERM*QQ(K)**L
          END DO
          V=V+CPOT(I,IDIP)*TERM
        END IF
      END DO
      RETURN
      END
C****************************************************************
C****************************************************************
      SUBROUTINE PLOTIN(W,MAXCON,MAXPTS,MAXCI,MAXDMP,NDUMP,KDUMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL LINEAR,TRIAT
      CHARACTER*3 CHSYM(8)
      CHARACTER*2 SYMBOL(100),tpdn,ch1
      CHARACTER*1 ch2,space
      DIMENSION NDUMP(1),KDUMP(MAXDMP,1)
C**************************************************ASSIGN TOTAL STORAGE
      DIMENSION W(1)
      COMMON/CMEMO/NADD,NSEG,KFREE,LFREE,KINF,MADD
C**CURRENT SETTINGS
      COMMON/CADDR/
     &LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LOLDH,LXK,LOLDXQ,LXW,LNBF,
     1LMBF,LSCF,LSX,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
     2LAB,LB,LAA,LBB,LQQ,LMVB,LH,LXQ,LTEMP,LCONTR,
     3LDUM2A(2),LV1,LV2,LV3,LV4,LDUM2B(4),
     4LDUM3A(3),LXK0,LXL0,LXN0,LXM0,LDUM3B(3),
     5LISIZE,LW21,LSS,LSSX,LX21,LE21,LIDUMP,LNDUMP,LIP,LVCI,
     6LDUM6(10),
     7LDUM7(10),
     8LXA,LXA1,LXA2,LXA3,LXA4,LEVAL,LIP1,LIP2,LIP3,LIP4,
     9LPD1,LPD2,LPD3,LPD4,LPD5,LPD6,LPD7,LMXBAS,LKDUMP,LNVF,
     1LMODNT,LJP1,LJP2,LJP3,LJP4,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,
     2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
     3LDUM8(10),
     4LDUM9(10),
     5LDUM10(10),
     6LDUM11(10),
     7LDUM12(4),LXP,LJP6,LXPLOT,LYPLOT,LFPLOT
C**CURRENT SETTINGS
C**************************************************ASSIGN TOTAL STORAGE
      COMMON/DIPNO/NUMDIP
C*****
      COMMON/TITLE/TITLE
      COMMON/HERM/IHERM
      COMMON/CHECK/MCHECK
      COMMON/SADDLE/JNORM
      COMMON/PATH/ISCFCI
      COMMON/CYCLE/ICYCLE
      COMMON/DUMP/JJDUMP(10),IDUMP,KKDUMP,MDUMP,LLDUMP
      COMMON/VMIN/VMIN
      COMMON/RETURN/IRET
      COMMON/CURVE/ICURV,ICORR
      COMMON/REACTN/IREACT,MMTAU,INIT,INCTAU
      COMMON/REACTL/JREACT
      COMMON/ENTER/IENTER,IENTMX(5),NTOT1,NTOT2,NTOT3,NTOT4,NTOT5
      COMMON/SINCOS/ICS
      COMMON/AVCON/AVCON
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FITTER/MFIT,MFIT1(4),XFIT1,MFIT2(4),XFIT2,MFIT3(4),XFIT3,
     1MFIT4(4),XFIT4
      COMMON/LANCZO/LANCZ,LANZA,LANZB
      COMMON/TRIATO/TRIAT
      COMMON/LANTOL/TOLLAN
      COMMON/CYCLES/NCYCLE
      COMMON/MAXLAN/LANMAX,LLAN20,INP20
      COMMON/GIVEN/LGIV,IGIV
      COMMON/MATSIZ/MATSIZ
      COMMON/TYPE/LINEAR
      COMMON/ECKIND/INDECK
      COMMON/ROTIND/ANGSAV(3),INDROT
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/FILASS/IOUT,INP
      COMMON/PRINT/IPRINT,JPRINT
      COMMON/TOLS/TOL,EPS
      COMMON/ECKCNT/ICNT,INTC
      COMMON/ABINIT/ABINIT
      COMMON/EVL/EVL,CUT
      COMMON/COUPLE/ICOUPL,JCOUPL,ICOUPC,JCOUPC
      COMMON/WHICH/IWHICH
      COMMON/NCPOT/NPOT
      COMMON/VCIMAX/NMAX
      COMMON/ROTS/JMAX,KMAX,J21,KEL21,KEL
      COMMON/RPHROT/IROTV
      COMMON/ESTATE/IORDER
      COMMON/JKAKC/JTHIS,KA,KC
      COMMON/AXES/MX(3),MXDIP(5),MXROT(3)
      COMMON/CIDIAG/ICID,ICI,JCI
      COMMON/FBASIS/NBAS(6,2,2),MAXSUM(6,2,2)
      COMMON/TBASIS/NTBAS(6,2),NTAU(6)
C**TEMPORARY (DIMENSIONS)
      COMMON/SYMM/NRSYM,NVSYM,NWSYM,NSYM(10),ISYM(10,100),NTOT(10)
      COMMON/SYMMS/MVSYM,MWSYM(10)
      COMMON/SYMMP/ISYMP(10,10),ISYMPG,ISYMD(4,2)
      COMMON/PLSYM/IPLSM(10),IPLFN(60,10)
      COMMON/CONTDP/ICONDP
      COMMON/CSAVES/NNMODS,NAMODS,NVMODS,ICOUPS,JREACS,NREACS
      COMMON/NCREC/NREC(6),MAXBUF(6),NUNITR,NUNITW
      COMMON/CVAL/NCVAL(2,10),NCSIZE(10)
      COMMON/CSIZES/ISIZM1,ISIZM2,NVAL1,NVAL2,ICSIZ1,ICSIZ2,
     1IPSIZ1,IPSIZ2
      COMMON/CONTX/LCOUNT,ISIZC(2,10)
      COMMON/FCONTS/NCONT(2)
      COMMON/CONTZ/NONC1,NONC2
      COMMON/CONSCH/NC1,NC2,NCL1(5),NCR1(5),NCL2(5),NCR2(5),MC1(5),
     1MC2(5),JC1(5),JC2(5)
      COMMON/UNITNO/I61,I62,I63,I64,I71,I72,I73,I74,I81,I82,I83,I84,
     1I91,I92,I93,I94
      COMMON/UNITEX/I75,I76
C************************
      COMMON/TIMER/ITIM1A,ITIM1B,ITIM2A,ITIM2B,ITIM3A,ITIM3B,
     1ITIM4A,ITIM4B,ITIM5A,ITIM5B,ITIM6A,ITIM6B,ITIM
      COMMON/MAXPT/MBFMAX,MBFMX1,MBFMX2,MBFMX3,MBFMX4,MBFMIN
      COMMON/DISC/IDISC
      COMMON/MODES/NMODE,NATOM
      COMMON/NORMOD/NAMODE,LINBND,NONLIN,MODD
      COMMON/VIBMOD/NSMODE,NVMODE,NNMODE
      COMMON/DISCSZ/KLC0,KEJK0,KLV1,KLC1,KEJK1,KLV2,KLC2,KEJK2,
     1KLV3,KLC3,KEJK3,KLV4,KLC4,KEJK4
      COMMON/SIZES/KTEMP,ISIZE1,ISIZE2,ISIZE3,ISIZE4,ISIZE5,ISIZE6,
     1IISIZE,JSIZE,ISIZMX
      COMMON/KJSZS/KJP1,KJP2,KJP3,KJP4,KJP5,KJP6
      COMMON/KPSZS/KIP1,KIP2,KIP3,KIP4,KIP5,KIP6,JCC1,JCC2,JCC3,JCC4,
     1JCC5,JCC6
      COMMON/IPSZS/KPPP1,KPPP2,KPPP3,KPPP4,KPPP5,KPPP6
      COMMON/SIZEJ/JSIZE1(2),JSIZE2(2),JSIZE3(2),JSIZE4(2),JSIZE5(2),
     1JSIZE6(2)
      COMMON/TOTALS/ITOT1(2),ITOT2(2),ITOT3(2),ITOT4(2),ITOT5(2),
     1ITOT6(2),ITOT
      COMMON/TOTK/KTOT(6,2)
      COMMON/MATRIX/NVAL,NVALR,KSTEP,KSIGN,NVALCF
c ---------------------------------------------------------- RT start
      COMMON/PLGRID/XMIN,XMAX,YMIN,YMAX,NPLOT(2),IPCOUNT,ICCOUNT
      common/outcom/iunit
c ---------------------------------------------------------- RT end
C**************************************************************
C**************************************************************
100   FORMAT(3I4)
101   FORMAT(4F15.7)
104   FORMAT(20I4)
247   FORMAT(//,1X,'PLOT NUMBER = ',I4,'    FUNCTION NUMBER = ',I5,//)
248   FORMAT(1X,'FUNCTIONS:',20I5,/)
249   FORMAT(//,1X,'GRID MINIMA AND MAXIMA (DEFAULTS IF ZERO)',/,
     11X,'XMIN = ',F10.5,' XMAX = ',F10.5,' YMIN = ',F10.5,
     2' YMAX = ',F10.5,/)
250   FORMAT(//,1X,'FOR VIBRATIONAL SYMMETRY = ',I2,' NO. PLOTS = ',I4,
     1/)
251   FORMAT(//,1X,'WITH REMAINING MODES FIXED AT ZERO, PLOT MODES',
     12I4,/)
252   FORMAT(//,1X,'FOR 3-DIM SYMMETRY = ',I2,' NO. PLOTS = ',I4,/)
      DO I=1,NVSYM
        READ(INP,*)
        READ(INP,*)IPLSM(I)
C**************************NUMBER PLOTS THIS SYMMETRY
        IF(IPLSM(I).LT.0)IPLSM(I)=0
        IF(IPLSM(I).GT.60)IPLSM(I)=60
        IF(IPLSM(I).GT.0)THEN
          READ(INP,*)
          READ(INP,*)(IPLFN(J,I),J=1,IPLSM(I))
        END IF
C**********************************FUNCTION NUMBERS THIS SYMMETRY
        WRITE(IOUT,250)I,IPLSM(I)
        IF(IPLSM(I).GT.0)WRITE(IOUT,248)(IPLFN(J,I),J=1,IPLSM(I))
      END DO
      ICNT=0
      DO I=1,NVSYM
        IF(IPLSM(I).GT.0)ICNT=ICNT+1
      END DO
      IF(ICNT.EQ.0)STOP 'NOTHING TO PLOT'

      space=' '
      tpdn='00'
      READ(INP,*)
      READ(INP,*)NUMCOM
      DO LOOP=1,NUMCOM
        READ(INP,*)
        READ(INP,*)XMIN,XMAX,YMIN,YMAX
C*************************************GRID MINIMA AND MAXIMA
        WRITE(IOUT,249)XMIN,XMAX,YMIN,YMAX
C**********************PLOT MODES (REMAINING FIXED AT ZERO)
        READ(INP,*)
        READ(INP,*)NPLOT(1),NPLOT(2)
        WRITE(IOUT,251)NPLOT(1),NPLOT(2)
        CALL FLUSH(IOUT)
c ----------------------------------------------------------- RT start
c  psplot initialization 
C       IF(JREACT.EQ.0)call newdev('vrscf.ps',8)
C       IF(JREACT.NE.0)call newdev('react.ps',8)
        itpdn1=LOOP/10
        itpdn2=MOD(LOOP,10)
        tpdn=char(itpdn1+48)//char(itpdn2+48)
        IF(JREACT.EQ.0)call newdev('vrscf'//tpdn//'.ps',10)
        IF(JREACT.NE.0)call newdev('react'//tpdn//'.ps',10)
        call psinit(.true.)
        call factrr(0.5)
C***********************************
C       call plot(0.,21.,-3)
C       ipcount=0
C       ICCOUNT=0
C***********************************
c ----------------------------------------------------------- RT end
C**SET COORDINATE RANGES
        CALL FIX3D(W(LXQ),MAXPTS,NMODE,W(LMVB),MP1,MP2)
        KPLOT=MAX0(MP1,MP2)
        CALL MEMO(3,LXPLOT,KPLOT,LYPLOT,KPLOT,LFPLOT,KPLOT*KPLOT,
     1  0,0,0,0)
        IPLOT=0
        IF(LOOP.GT.9)THEN
          ich1=LOOP/10
          ich2=MOD(LOOP,10)
          ch1=char(ich1+48)//char(ich2+48)
        ELSE
          ch1=space//char(LOOP+48)
        END IF
C**3-D CONTOUR PLOT
        IF(NPLOT(1).NE.0.AND.NPLOT(2).NE.0)THEN
C**LOOP ROUND SYMMETRIES
        DO M7=1,NVSYM
C***********************************
          call plot(0.,21.,-3)
          ipcount=0
          ICCOUNT=0
C***********************************
          IF(IPLSM(M7).NE.0)THEN
            WRITE(IOUT,252)M7,IPLSM(M7)
            DO I=1,IPLSM(M7)
              ITHIS=IPLFN(I,M7)
              WRITE(IOUT,247)I,ITHIS
              IF(M7.EQ.1)ITHIS=ITHIS+1
              JDUMP=NDUMP(M7)
              DO J=1,JDUMP
                IDUMP=KDUMP(J,M7)
                IF(ITHIS.EQ.IDUMP)
     1          CALL PLOT3D(W,ITHIS,W(LISIZE),M7,W(LXQ),MAXCI,MAXDMP,
     2          MAXCON,MAXPTS,NMODE,W(LVCI),W(LIP),W(LXPLOT),W(LYPLOT),
     3          W(LFPLOT),KPLOT,W(LEVAL),IPLOT,MP1,MP2,W(LNVF),W(LMVB))
              END DO
            END DO
          END IF
C***************************************
          call plot(-4.6*ICCOUNT,0.,-3)
C**TEMPORARY FIGURE No.
          call plot(0.,-5.2,-3) 
          call plot(4.6,0.,-3)
          ch2=char(M7+48)
          call keksym(0.1,0.1,0.28,'Figure '//ch1//'.'//ch2//'',0.,11,
     1    0)
          call plot(-4.6*2,0.,-3)
C**TEMPORARY FIGURE No.
C***************************************
          call chopit(0.,0.)
        END DO
        ELSE
C**2-D X-Y PLOT
        DO M7=1,NVSYM
C***********************************
          IF(IPLSM(M7).NE.0)THEN
            WRITE(IOUT,252)M7,IPLSM(M7)
            DO I=1,IPLSM(M7)
              ITHIS=IPLFN(I,M7)
C             WRITE(IOUT,247)I,ITHIS
              IF(M7.EQ.1)ITHIS=ITHIS+1
              JDUMP=NDUMP(M7)
              DO J=1,JDUMP
                IDUMP=KDUMP(J,M7)
                IF(ITHIS.EQ.IDUMP)
     1          CALL PLOT2D(W,ITHIS,W(LISIZE),M7,W(LXQ),MAXCI,MAXDMP,
     2          MAXCON,MAXPTS,NMODE,W(LVCI),W(LIP),W(LXPLOT),W(LYPLOT),
     3          W(LFPLOT),KPLOT,W(LEVAL),IPLOT,MP1,MP2,W(LNVF),W(LMVB))
              END DO
            END DO
          END IF
C***************************************
        END DO
        END IF
        CALL MEMO(-3,LXPLOT,KPLOT,LYPLOT,KPLOT,LFPLOT,KPLOT*KPLOT,
     1  0,0,0,0)
C**SC
C***************************************
c       call plot(-4.6*ICCOUNT,0.,-3)
C**TEMPORARY FIGURE No.
C       call plot(0.,-5.2,-3) 
C       call plot(4.6,0.,-3)
C       call keksym(0.1,0.1,0.28,9hFigure. 1,0.,9,0)
C       call plot(-4.6*2,0.,-3)
C**TEMPORARY FIGURE No.
        IF(NPLOT(1).NE.0.AND.NPLOT(2).NE.0)call plotnd
C***************************************
      END DO
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE FIX3D(XQ,MAXPTS,NMODE,MVB,M1,M2)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION XQ(MAXPTS,NMODE),MVB(NMODE)
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/PLGRID/XMIN,XMAX,YMIN,YMAX,NPLOT(2),IPCOUNT,ICCOUNT
      COMMON/FILASS/IOUT
100   FORMAT(1X,'PLOTS DEFINED FOR XMIN,XMAX,YMIN,YMAX AS:',/,
     11X,4F15.5,/)
      IF(XMIN.EQ.-1.AND.XMAX.EQ.-1)NPLOT(1)=0
      IF(YMIN.EQ.-1.AND.YMAX.EQ.-1)NPLOT(2)=0
      IF(NPLOT(1).EQ.0)THEN
        XMIN=0
        XMAX=0
      END IF
      IF(NPLOT(2).EQ.0)THEN
        YMIN=0
        YMAX=0
      END IF
      M1=0
      IF(NPLOT(1).NE.0)THEN
        M1=MVB(NPLOT(1))
        IF(NPLOT(1).EQ.NMODE)THEN
          XMIN=XMIN/RAD
          XMAX=XMAX/RAD
        END IF
        IF(XMIN.EQ.0)XMIN=XQ(1,NPLOT(1))
        IF(XMAX.EQ.0)XMAX=XQ(M1,NPLOT(1))
      END IF
      M2=0
      IF(NPLOT(2).NE.0)THEN
        M2=MVB(NPLOT(2))
        IF(NPLOT(2).EQ.NMODE)THEN
          YMIN=YMIN/RAD
          YMAX=YMAX/RAD
        END IF
        IF(YMIN.EQ.0)YMIN=XQ(1,NPLOT(2))
        IF(YMAX.EQ.0)YMAX=XQ(M2,NPLOT(2))
      END IF
C     IF((XMIN.NE.0.OR.XMAX.NE.0.AND.XMIN.GE.XMAX).OR.
C    1(YMIN.NE.0.OR.YMAX.NE.0.AND.YMIN.GE.YMAX))
C    1STOP 'XMIN.GE.XMAX OR YMIN.GE.YMAX'
      WRITE(IOUT,100)XMIN,XMAX,YMIN,YMAX
      CALL FLUSH(IOUT)
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE PLOT2D(W,ITHIS,ISIZE,M7,XQ,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1NMODE,VCI,IP,XX,YY,FUN,KPLOT,EVAL,IPLOT,MP1,MP2,NVF,MVB)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION W(1)
      DIMENSION XQ(MAXPTS,NMODE),ISIZE(1),EVAL(MAXDMP,1),MVB(NMODE)
      DIMENSION VCI(MAXCI,MAXDMP,1),IP(MAXCI,NMODE,1),NVF(NMODE)
      DIMENSION XX(KPLOT),YY(KPLOT),FUN(KPLOT)
      COMMON/PLSYM/IPLSM(10),IPLFN(60,10)
      COMMON/PLGRID/XMIN,XMAX,YMIN,YMAX,NPLOT(2),IPCOUNT,ICCOUNT
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/REACTL/JREACT
      COMMON/FILASS/IOUT
c**********************************************************
100   FORMAT(8F10.5)
101   FORMAT(//,' GRID FOR LEVEL',F10.1,' BAND ORIGIN',F12.5,' MODES ',
     12I3,/)
102   FORMAT(2I5)
103   FORMAT(//,' NUMBER OF X-POINTS, NUMBER OF Y-POINTS',/)
104   FORMAT(//,' X-POINTS',/)
105   FORMAT(//,' Y-POINTS',/)
247   FORMAT(////,1X,'PLOT NUMBER = ',I4,'    FUNCTION NUMBER = ',I5)
300   FORMAT(F7.5,1X,F7.5,1X,F8.5)
301   FORMAT(F7.5,   f8.2,1X,F8.5)
302   FORMAT(F7.5,1X,F7.5,   f8.2)
400   FORMAT(80(1H*))
500   FORMAT()
c**********************************************************
      VMAX=1.D-20
      fscale=0.d0
      IBLOCK=ISIZE(M7)
      M1=NPLOT(1)
      M2=NPLOT(2)
      Q1MIN=XMIN
      Q1MAX=XMAX
      Q2MIN=YMIN
      Q2MAX=YMAX
C**TEMPORARY
C     WRITE(IOUT,*)'M7,IBLOCK,M1,M2,MP1,MP2,Q1MIN,Q1MAX,Q2MIN,Q2MAX',
C    1M7,IBLOCK,M1,M2,MP1,MP2,Q1MIN,Q1MAX,Q2MIN,Q2MAX
C**TEMPORARY
      IF(M2.EQ.0)THEN
        IQ2=0
        IQ1=0
        DO I1=1,MP1
          IF(XQ(I1,M1).LT.Q1MIN.OR.XQ(I1,M1).GT.Q1MAX)GO TO 5
          IQ1=IQ1+1
          CALL GETWAV(W,ITHIS,IBLOCK,M7,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1    NMODE,V,I1,I2,VCI,IP,NVF,MVB,fscale)
          FUN(IQ1)=V
          X=FUN(IQ1)
          IF(dabs(X).GT.dabs(VMAX)) VMAX=X
          XX(IQ1)=XQ(I1,M1)
5         CONTINUE
        END DO
      END IF

      IF(M1.EQ.0)THEN
        IQ1=0
        IQ2=0
        DO I2=1,MP2
          IF(XQ(I2,M2).LT.Q2MIN.OR.XQ(I2,M2).GT.Q2MAX)GO TO 4
          IQ2=IQ2+1
          CALL GETWAV(W,ITHIS,IBLOCK,M7,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1    NMODE,V,I1,I2,VCI,IP,NVF,MVB,fscale)
          FUN(IQ2)=V
          X=FUN(IQ2)
          IF(dabs(X).GT.dabs(VMAX)) VMAX=X
          YY(IQ2)=XQ(I2,M2)
C**TEMPORARY
C     WRITE(IOUT,*)'I2,IQ2,YY(IQ2),X',I2,IQ2,YY(IQ2),X
C**TEMPORARY
4         CONTINUE
        END DO
      END IF
      NUMX=IQ1
      NUMY=IQ2
      NUM=MAX0(IQ1,IQ2)

C**TEMPORARY
C     STOP 'TEST 2-D'
C**TEMPORARY

      DO I=1,NUM
        FUN(I)= FUN(I)/VMAX
      END DO

      fscale=DABS(VMAX)
C*************************************WRITE GRID HERE
      IF(IPLOT.EQ.0)THEN
        WRITE(IOUT,103)
        WRITE(IOUT,102)NUMX,NUMY
      END IF
      IPLOT=IPLOT+1

      WRITE(IOUT,247)IPLOT,ITHIS
      ZZ=(ITHIS-1)*10+M7
      IF(M7.NE.1)ZZ=ITHIS*10+M7
      WRITE(IOUT,101) ZZ,EVAL(ITHIS,M7)*WAVENM,NPLOT(1),NPLOT(2)
      IF(NUMY.EQ.0)THEN
        WRITE(IOUT,104)
        DO I=1,NUMX
          IF(JREACT.EQ.0)THEN
            WRITE(IOUT,100)XX(I),FUN(I)
          ELSE
            WRITE(IOUT,100)XX(I)*RAD,FUN(I)
          END IF
        END DO
      END IF
      IF(NUMX.EQ.0)THEN
        WRITE(IOUT,105)
        DO I=1,NUMY
          IF(JREACT.EQ.0)THEN
            WRITE(IOUT,100)YY(I),FUN(I)
          ELSE
            WRITE(IOUT,100)YY(I)*RAD,FUN(I)
          END IF
        END DO
      END IF
      CALL FLUSH(IOUT)

      IF(JREACT.EQ.0)THEN
        IF(NUMY.EQ.0)THEN
          DO IX=1,NUMX
            WRITE(MOUT,*)XX(IX),FUN(IX)
          END DO
          WRITE(MOUT,500)
        ELSE
          DO IY=1,NUMY
            WRITE(MOUT,*)YY(IY),FUN(IY)
          END DO
          WRITE(MOUT,500)
        END IF
      END IF

      IF(JREACT.GT.0)THEN
        IF(NPLOT(1).EQ.NMODE)THEN
          DO IX=1,NUMX
      WRITE(MOUT,*)XX(IX)*180.d0/dacos(-1.d0),FUN(IX)
            WRITE(MOUT,500)
          END DO
        END IF
      END IF

      IF(JREACT.GT.0)THEN
        IF(NPLOT(2).EQ.NMODE)THEN
          DO IY=1,NUMY
      WRITE(MOUT,*)YY(IY)*180.d0/dacos(-1.d0),FUN(IY)
            WRITE(MOUT,500)
          END DO
        END IF
      END IF

      WRITE(MOUT,400)
      RETURN
      END
C***************************************************************
C***************************************************************
      SUBROUTINE PLOT3D(W,ITHIS,ISIZE,M7,XQ,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1NMODE,VCI,IP,XX,YY,FUN,KPLOT,EVAL,IPLOT,MP1,MP2,NVF,MVB)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION W(1)
      DIMENSION XQ(MAXPTS,NMODE),ISIZE(1),EVAL(MAXDMP,1),MVB(NMODE)
      DIMENSION VCI(MAXCI,MAXDMP,1),IP(MAXCI,NMODE,1),NVF(NMODE)
c ----------------------------------------------------------- RT start
      DIMENSION XX(KPLOT),YY(KPLOT),FUN(KPLOT,KPLOT)
c ----------------------------------------------------------- RT end
      COMMON/PLGRID/XMIN,XMAX,YMIN,YMAX,NPLOT(2),IPCOUNT,ICCOUNT
      COMMON/MOLPRO/MOLPRO,MOUT,MINP,SYMBOL,CHSYM,MOLINC
      COMMON/FUNDAM/WAVENM,ATTOJ,BOHR,ELMASS,RAD
      COMMON/REACTL/JREACT
      COMMON/FILASS/IOUT
c ----------------------------------------------------------- RT start
c  psplot common
      common/outcom/iunit
      common /conpar/ ispec,ioffp,spval,ilegg,ilabb,nhii,
     >                ndeccn,nlbbl,lscal,ldash,hgtlab
c
      dimension cvalm(19),cvalp(19),f(300,150)
      real*4 cvalm,cvalp,f,spval,xlen,ylen,ee
C**TEMPORARY
      character*1 ch
C**TEMPORARY
      data (cvalm(i),i=1,9) /-0.10,-0.20,
     >            -0.30,-0.40,
     >            -0.50,-0.60,
     >            -0.70,-0.80,
     >            -0.90/
      data (cvalp(i),i=1,9) /0.10, 0.20,
     >             0.30, 0.40,
     >             0.50, 0.60,
     >             0.70, 0.80,
     >             0.90/
c     data (cvalm(i),i=1,19) /-0.05,-0.10,-0.15,-0.20,
c    >            -0.25,-0.30,-0.35,-0.40,
c    >            -0.45,-0.50,-0.55,-0.60,
c    >            -0.65,-0.70,-0.75,-0.80,
c    >            -0.85,-0.90,-0.95/
c     data (cvalp(i),i=1,19) / 0.05, 0.10, 0.15, 0.20,
c    >             0.25, 0.30, 0.35, 0.40,
c    >             0.45, 0.50, 0.55, 0.60,
c    >             0.65, 0.70, 0.75, 0.80,
c    >             0.85, 0.90, 0.95/
c     data cvalp /0.1 , 0.2 , 0.3 , 0.4 , 0.5 ,
c    >            0.6 , 0.7 , 0.8 , 0.9 , 1.0 ,
c    >            1.1 , 1.2 , 1.3 , 1.4 , 1.5 ,
c    >            1.6 , 1.7 , 1.8 , 1.9 , 2.0 ,
c    >            2.1 , 2.2 , 2.3 , 2.4 , 2.5 /
c     data cvalp /0.05, 0.10, 0.15, 0.20, 0.25,
c    >            0.30, 0.35, 0.40, 0.45, 0.50,
c    >            0.55, 0.60, 0.65, 0.70, 0.75,
c    >            0.80, 0.85, 0.90, 0.95, 1.0 ,
c    >            1.05, 1.10, 1.15, 1.20, 1.25/
c**********************************************************
100   FORMAT(8F10.5)
101   FORMAT(//,' GRID FOR LEVEL',F10.1,' BAND ORIGIN',F12.5,' MODES ',
     12I3,/)
102   FORMAT(2I5)
103   FORMAT(//,' NUMBER OF X-POINTS, NUMBER OF Y-POINTS',/)
104   FORMAT(//,' X-POINTS',/)
105   FORMAT(//,' Y-POINTS',/)
300   FORMAT(F7.5,1X,F7.5,1X,F8.5)
301   FORMAT(F7.5,   f8.2,1X,F8.5)
302   FORMAT(F7.5,1X,F7.5,   f8.2)
400   FORMAT(80(1H*))
500   FORMAT()
c**********************************************************
      VMAX=1.D-20
      fscale=0.d0
c ----------------------------------------------------------- RT end
      IBLOCK=ISIZE(M7)
      M1=NPLOT(1)
      M2=NPLOT(2)
      Q1MIN=XMIN
      Q1MAX=XMAX
      Q2MIN=YMIN
      Q2MAX=YMAX
      IQ1=0
      DO I1=1,MP1
        IF(XQ(I1,M1).LT.Q1MIN.OR.XQ(I1,M1).GT.Q1MAX)GO TO 5
        IQ1=IQ1+1
        IQ2=0
        DO I2=1,MP2
          IF(XQ(I2,M2).LT.Q2MIN.OR.XQ(I2,M2).GT.Q2MAX)GO TO 4
          IQ2=IQ2+1
c ----------------------------------------------------------- RT start
          CALL GETWAV(W,ITHIS,IBLOCK,M7,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1    NMODE,V,I1,I2,VCI,IP,NVF,MVB,fscale)
          FUN(IQ1,IQ2)=V
          X=FUN(IQ1,IQ2)
          IF(dabs(X).GT.dabs(VMAX)) VMAX=X
          XX(IQ1)=XQ(I1,M1)
          YY(IQ2)=XQ(I2,M2)
4         CONTINUE
        END DO
5       CONTINUE
      END DO
      NUMX=IQ1
      NUMY=IQ2

C**NOT NEEDED?
CC    fscmax=0.d0
CC    if (fscale.gt.fscmax) fscmax=fscale
C**NOT NEEDED?

      DO I=1,NUMY
        DO J=1,NUMX
          FUN(J,I)= FUN(J,I)/VMAX
CC        FUN(J,I)=FUN(J,I)*fscale/fscmax
        END DO
      END DO

C**SC
      fscale=DABS(VMAX)
c ----------------------------------------------------------- RT end
C*************************************WRITE GRID HERE
      IF(IPLOT.EQ.0)THEN
        WRITE(IOUT,103)
        WRITE(IOUT,102)NUMX,NUMY
        WRITE(IOUT,104)
        WRITE(IOUT,100)(XX(I),I=1,NUMX)
        WRITE(IOUT,105)
        WRITE(IOUT,100)(YY(I),I=1,NUMY)
      END IF
      IPLOT=IPLOT+1
      ZZ=(ITHIS-1)*10+M7
      IF(M7.NE.1)ZZ=ITHIS*10+M7
      WRITE(IOUT,101) ZZ,EVAL(ITHIS,M7)*WAVENM,NPLOT(1),NPLOT(2)
      CALL FLUSH(IOUT)
      DO J=1,NUMY
        WRITE(IOUT,100)(FUN(I,J),I=1,NUMX)
      END DO

      IF(JREACT.EQ.0)THEN
        DO IY=1,NUMY
          DO IX=1,NUMX
            WRITE(MOUT,*)XX(IX),YY(IY),FUN(IX,IY)
          END DO
          WRITE(MOUT,500)
        END DO
      END IF

      IF(JREACT.GT.0)THEN
        IF(NPLOT(1).EQ.NMODE)THEN
          DO IY=1,NUMY
            DO IX=1,NUMX
      WRITE(MOUT,*)XX(IX)*180.d0/dacos(-1.d0),YY(IY),FUN(IX,IY)
            END DO
            WRITE(MOUT,500)
          END DO
        END IF
      END IF

      IF(JREACT.GT.0)THEN
        IF(NPLOT(2).EQ.NMODE)THEN
          DO IY=1,NUMY
            DO IX=1,NUMX
      WRITE(MOUT,*)XX(IX),YY(IY)*180.d0/dacos(-1.d0),FUN(IX,IY)
            END DO
            WRITE(MOUT,500)
          END DO
        END IF
      END IF

      WRITE(MOUT,400)
c ----------------------------------------------------------- RT start
c
c  psplot
c
C**SC
      IHEAD=0
      IF(ICCOUNT.EQ.0)THEN
C**NEW LINE IF ICCOUNT=0
        if(numx.gt.150.or.numy.gt.150) then
           write (iout,*) 'NUMX=',numx,'NUMY=',numy
           stop 'numx or numy > 150'
        endif
C**PRINT HEADING ONCE ONLY 
C       if(ipcount.eq.0)then
C         call keksym(0.,4.7,0.28,5hMODES,0.,2,0)
C         IHEAD=1
C       end if
        ipcount=ipcount+1
        if(ipcount.gt.4) then
C**NEW PAGE IF IPCOUNT=4
          call chopit(0.,0.)
          call plot(0.,21.,-3)
          ipcount=1
        endif
        call plot(0.,-5.2,-3) 
C       ee=eval(ITHIS,M7)*WAVENM
C       call keknum(0.,4.6,0.28,ee,0.,1,0)
C       call keksym(1.50,4.6,0.28,2hcm,0.,2,0)
C       call super(2h-1,2,0.28,0.)
      END IF
      ICCOUNT=ICCOUNT+1
      ee=eval(ITHIS,M7)*WAVENM
      call keknum(0.,4.6,0.28,ee,0.,1,0)
      call keksym(1.50,4.6,0.28,2hcm,0.,2,0)
      call super(2h-1,2,0.28,0.)
C**SC
c  
c   draw axes
      call setlw (0.02)
      call border(4.5,4.5,1111,1111,1,1,1,1)

CC    ee=1.D0
      ee=ZZ
CCCC  call keknum(0.1,0.1,0.28,ee,0.,-1,0)
C**TEMPORARY
      IF(ITHIS.EQ.1)ch='0'
      IF(ITHIS.EQ.3)ch='1'
      IF(ITHIS.EQ.4)ch='1'
      IF(ITHIS.EQ.6)ch='1'
      IF(ITHIS.EQ.9)ch='2'
      IF(ITHIS.EQ.17)ch='2'
      IF(ITHIS.EQ.24)ch='2'
      IF(ITHIS.EQ.26)ch='2'
      IF(ITHIS.EQ.56)ch='3'
      IF(ITHIS.EQ.59)ch='3'
      IF(ITHIS.EQ.61)ch='3'
      IF(ITHIS.EQ.86)ch='3'
      IF(ITHIS.EQ.88)ch='3'
      IF(ITHIS.EQ.118)ch='4'
      IF(ITHIS.EQ.167)ch='4'
      IF(ITHIS.EQ.170)ch='4'
      IF(ITHIS.EQ.173)ch='4'
      IF(ITHIS.EQ.231)ch='4'
      IF(ITHIS.EQ.238)ch='4'
      IF(ITHIS.EQ.303)ch='5'
      IF(ITHIS.EQ.311)ch='5'
      IF(ITHIS.EQ.409)ch='5'
      IF(ITHIS.EQ.410)ch='5'
      IF(ITHIS.EQ.417)ch='5'
      IF(ITHIS.EQ.552)ch='5'
C     call keksym(0.1,0.1,0.28,2hv=,0.,2,0)
C     call keksym(0.6,0.1,0.28,ch,0.,1,0)
C**TEMPORARY
      ee=fscale
CCCC  call keknum(3.2,4.0,0.28,ee,0.,3,0)
c
c     draw positive parts of wavefunction
c
      do ix=1,numx
        do iy=1,numy
          f(iy,ix)=fun(ix,iy)
        enddo
      enddo
      numy2=numy
      ispec=1
      ilegg=0
      ilabb=-999  
      nhii=-1
      ldash=0
      call setlw(0.006)
      call conrec(f,300,numy2,numx,4.5,4.5,cvalp,9)
c
c     draw negative parts of wavefunction
c
      do ix=1,numx
        do iy=1,numy
          f(iy,ix)=fun(ix,iy)
        enddo
      enddo
      numy2=numy
      ispec=1
      ilegg=0
      ilabb=-999
      nhii=-1
      ldash=10
      call setlw (0.006)
      call conrec(f,300,numy2,numx,4.5,4.5,cvalm,9)
      IF(IHEAD.EQ.0)call plot(4.6,0.,-3)
C     IF(IHEAD.EQ.1)call plot(4.7,0.,-3)
C**SC
      IF(ICCOUNT.EQ.3)THEN
        IF(IHEAD.EQ.0)call plot(-4.6*3,0.,-3)
C       IF(IHEAD.EQ.1)call plot(-4.7*3,0.,-3)
C**SET NEW LINE
        ICCOUNT=0
      END IF
c ----------------------------------------------------------- RT end
      RETURN
      END
C***********************************************************
C***********************************************************
      SUBROUTINE GETWAV(W,J,ISIZE,ISYM,MAXCI,MAXDMP,MAXCON,MAXPTS,
     1NMODE,V,M1,M2,VCI,IP,NVF,MVB,fscale)
C**ISYM = CURRENT SYMMETRY
C**ISIZE = SIZE VCI MATRIX (AND IP BASIS)
C**J = EIGENVALUE (JDUMP)
C**M1 = X POINT
C**M2 = Y POINT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION W(1),NVF(NMODE)
      DIMENSION VCI(MAXCI,MAXDMP,1),IP(MAXCI,NMODE,1),MVB(NMODE)
C**CURRENT SETTINGS
      COMMON/CADDR/
     &LIPOT,LJPOT,LCPOT,LOMEGA,LISTAT,LOLDH,LXK,LOLDXQ,LXW,LNBF,
     1LMBF,LSCF,LSX,LXM,LX0,LXL,LXZ,LXX,LR0,LRR,
     2LAB,LB,LAA,LBB,LQQ,LMVB,LH,LXQ,LTEMP,LCONTR,
     3LDUM2A(2),LV1,LV2,LV3,LV4,LDUM2B(4),
     4LDUM3A(3),LXK0,LXL0,LXN0,LXM0,LDUM3B(3),
     5LISIZE,LW21,LSS,LSSX,LX21,LE21,LIDUMP,LNDUMP,LIP,LVCI,
     6LDUM6(10),
     7LDUM7(10),
     8LXA,LXA1,LXA2,LXA3,LXA4,LEVAL,LIP1,LIP2,LIP3,LIP4,
     9LPD1,LPD2,LPD3,LPD4,LPD5,LPD6,LPD7,LMXBAS,LKDUMP,LNVF,
     1LMODNT,LJP1,LJP2,LJP3,LJP4,LXA0,LTEMP1,LTEMP2,LTEMP3,LXP0,
     2LMEFF,LIP5,LJP5,LKP,LLP,LTEMP4,LCASS,LWKC1,LWKC2,LWKC3,
     3LDUM8(10),
     4LDUM9(10),
     5LDUM10(10),
     6LDUM11(10),
     7LDUM12(4),LXP,LJP6,LXPLOT,LYPLOT,LFPLOT
C**CURRENT SETTINGS
C**************************************************ASSIGN TOTAL STORAGE
      COMMON/REACTL/JREACT
      COMMON/FILASS/IOUT
c ---------------------------------------------------------- RT start
      COMMON/PLGRID/XMIN,XMAX,YMIN,YMAX,NPLOT(2),IPCOUNT,ICCOUNT
c ---------------------------------------------------------- RT end
      ILOOP=1
      IF(JREACT.NE.0)ILOOP=2
      V=0
      fscale=0.d0
C**TEMPORARY
C     WRITE(IOUT,*)'ISIZE',ISIZE
C**TEMPORARY
      DO I=1,ISIZE
        PROD=1
        K3=0
        DO MODE=1,NMODE
          N=IP(I,MODE,ISYM)
          IF(MODE.EQ.NPLOT(1))M=M1
          IF(MODE.EQ.NPLOT(2))M=M2
C**TEMPORARY
C     IF(I.EQ.1)THEN
C     WRITE(IOUT,*)'MODE,N,NPLOT(1),NPLOT(2),M1,M2,M',
C    1MODE,N,NPLOT(1),NPLOT(2),M1,M2,M
C     END IF
C**TEMPORARY
          IF(MODE.NE.NPLOT(1).AND.MODE.NE.NPLOT(2))THEN
            M=MVB(MODE)
            MHALF=M/2
            TERM=HARFUN(MODE,W(LH),MAXCON,MAXPTS,N,MHALF,W(LXP+K3),
     1      NVF(MODE),MVB(MODE),I,ILOOP)
            TERM=TERM+
     1      HARFUN(MODE,W(LH),MAXCON,MAXPTS,N,MHALF+1,W(LXP+K3),
     2      NVF(MODE),MVB(MODE),I,ILOOP)
            TERM=TERM/2
          ELSE
            TERM=HARFUN(MODE,W(LH),MAXCON,MAXPTS,N,M,W(LXP+K3),
     1      NVF(MODE),MVB(MODE),I,ILOOP)
          END IF
          PROD=PROD*TERM
          K3=K3+MVB(MODE)*NVF(MODE)
        END DO
        V=V+VCI(I,J,ISYM)*PROD
C**TEMPORARY
C     WRITE(IOUT,*)'I,J,ISYM,VCI',I,J,ISYM,VCI(I,J,ISYM)
C     STOP '3-D'
C**TEMPORARY
C       fscale=fscale+VCI(I,J,ISYM)**2
      END DO
      RETURN
      END
C***********************************************************
C***********************************************************
      DOUBLE PRECISION FUNCTION HARFUN(MODE,H,MAXCON,MAXPTS,N,M,XP,
     1NV,MB,I,ILOOP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION H(MAXCON,MAXPTS,3,ILOOP,1),XP(NV,MB)
      COMMON/FILASS/IOUT
      HARFUN=H(N,M,1,1,MODE)/XP(N,M)
C**TEMPORARY
C     WRITE(IOUT,*)'N,M,MODE,H,XP',N,M,MODE,H(N,M,1,1,MODE),XP(N,M)
C**TEMPORARY
      RETURN
      END
